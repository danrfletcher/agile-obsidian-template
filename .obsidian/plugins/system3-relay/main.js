/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all2) => {
  for (var name in all2)
    __defProp(target, name, { get: all2[name], enumerable: true });
};
var __copyProps = (to, from3, except, desc) => {
  if (from3 && typeof from3 === "object" || typeof from3 === "function") {
    for (let key of __getOwnPropNames(from3))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from3[key], enumerable: !(desc = __getOwnPropDesc(from3, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/path-browserify/index.js
var require_path_browserify = __commonJS({
  "node_modules/path-browserify/index.js"(exports, module2) {
    "use strict";
    function assertPath(path) {
      if (typeof path !== "string") {
        throw new TypeError("Path must be a string. Received " + JSON.stringify(path));
      }
    }
    function normalizeStringPosix(path, allowAboveRoot) {
      var res = "";
      var lastSegmentLength = 0;
      var lastSlash = -1;
      var dots = 0;
      var code;
      for (var i2 = 0; i2 <= path.length; ++i2) {
        if (i2 < path.length)
          code = path.charCodeAt(i2);
        else if (code === 47)
          break;
        else
          code = 47;
        if (code === 47) {
          if (lastSlash === i2 - 1 || dots === 1) {
          } else if (lastSlash !== i2 - 1 && dots === 2) {
            if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
              if (res.length > 2) {
                var lastSlashIndex = res.lastIndexOf("/");
                if (lastSlashIndex !== res.length - 1) {
                  if (lastSlashIndex === -1) {
                    res = "";
                    lastSegmentLength = 0;
                  } else {
                    res = res.slice(0, lastSlashIndex);
                    lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                  }
                  lastSlash = i2;
                  dots = 0;
                  continue;
                }
              } else if (res.length === 2 || res.length === 1) {
                res = "";
                lastSegmentLength = 0;
                lastSlash = i2;
                dots = 0;
                continue;
              }
            }
            if (allowAboveRoot) {
              if (res.length > 0)
                res += "/..";
              else
                res = "..";
              lastSegmentLength = 2;
            }
          } else {
            if (res.length > 0)
              res += "/" + path.slice(lastSlash + 1, i2);
            else
              res = path.slice(lastSlash + 1, i2);
            lastSegmentLength = i2 - lastSlash - 1;
          }
          lastSlash = i2;
          dots = 0;
        } else if (code === 46 && dots !== -1) {
          ++dots;
        } else {
          dots = -1;
        }
      }
      return res;
    }
    function _format(sep2, pathObject) {
      var dir = pathObject.dir || pathObject.root;
      var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
      if (!dir) {
        return base;
      }
      if (dir === pathObject.root) {
        return dir + base;
      }
      return dir + sep2 + base;
    }
    var posix = {
      // path.resolve([from ...], to)
      resolve: function resolve() {
        var resolvedPath = "";
        var resolvedAbsolute = false;
        var cwd;
        for (var i2 = arguments.length - 1; i2 >= -1 && !resolvedAbsolute; i2--) {
          var path;
          if (i2 >= 0)
            path = arguments[i2];
          else {
            if (cwd === void 0)
              cwd = process.cwd();
            path = cwd;
          }
          assertPath(path);
          if (path.length === 0) {
            continue;
          }
          resolvedPath = path + "/" + resolvedPath;
          resolvedAbsolute = path.charCodeAt(0) === 47;
        }
        resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
        if (resolvedAbsolute) {
          if (resolvedPath.length > 0)
            return "/" + resolvedPath;
          else
            return "/";
        } else if (resolvedPath.length > 0) {
          return resolvedPath;
        } else {
          return ".";
        }
      },
      normalize: function normalize(path) {
        assertPath(path);
        if (path.length === 0)
          return ".";
        var isAbsolute = path.charCodeAt(0) === 47;
        var trailingSeparator = path.charCodeAt(path.length - 1) === 47;
        path = normalizeStringPosix(path, !isAbsolute);
        if (path.length === 0 && !isAbsolute)
          path = ".";
        if (path.length > 0 && trailingSeparator)
          path += "/";
        if (isAbsolute)
          return "/" + path;
        return path;
      },
      isAbsolute: function isAbsolute(path) {
        assertPath(path);
        return path.length > 0 && path.charCodeAt(0) === 47;
      },
      join: function join4() {
        if (arguments.length === 0)
          return ".";
        var joined;
        for (var i2 = 0; i2 < arguments.length; ++i2) {
          var arg = arguments[i2];
          assertPath(arg);
          if (arg.length > 0) {
            if (joined === void 0)
              joined = arg;
            else
              joined += "/" + arg;
          }
        }
        if (joined === void 0)
          return ".";
        return posix.normalize(joined);
      },
      relative: function relative2(from3, to) {
        assertPath(from3);
        assertPath(to);
        if (from3 === to)
          return "";
        from3 = posix.resolve(from3);
        to = posix.resolve(to);
        if (from3 === to)
          return "";
        var fromStart = 1;
        for (; fromStart < from3.length; ++fromStart) {
          if (from3.charCodeAt(fromStart) !== 47)
            break;
        }
        var fromEnd = from3.length;
        var fromLen = fromEnd - fromStart;
        var toStart = 1;
        for (; toStart < to.length; ++toStart) {
          if (to.charCodeAt(toStart) !== 47)
            break;
        }
        var toEnd = to.length;
        var toLen = toEnd - toStart;
        var length4 = fromLen < toLen ? fromLen : toLen;
        var lastCommonSep = -1;
        var i2 = 0;
        for (; i2 <= length4; ++i2) {
          if (i2 === length4) {
            if (toLen > length4) {
              if (to.charCodeAt(toStart + i2) === 47) {
                return to.slice(toStart + i2 + 1);
              } else if (i2 === 0) {
                return to.slice(toStart + i2);
              }
            } else if (fromLen > length4) {
              if (from3.charCodeAt(fromStart + i2) === 47) {
                lastCommonSep = i2;
              } else if (i2 === 0) {
                lastCommonSep = 0;
              }
            }
            break;
          }
          var fromCode = from3.charCodeAt(fromStart + i2);
          var toCode = to.charCodeAt(toStart + i2);
          if (fromCode !== toCode)
            break;
          else if (fromCode === 47)
            lastCommonSep = i2;
        }
        var out = "";
        for (i2 = fromStart + lastCommonSep + 1; i2 <= fromEnd; ++i2) {
          if (i2 === fromEnd || from3.charCodeAt(i2) === 47) {
            if (out.length === 0)
              out += "..";
            else
              out += "/..";
          }
        }
        if (out.length > 0)
          return out + to.slice(toStart + lastCommonSep);
        else {
          toStart += lastCommonSep;
          if (to.charCodeAt(toStart) === 47)
            ++toStart;
          return to.slice(toStart);
        }
      },
      _makeLong: function _makeLong(path) {
        return path;
      },
      dirname: function dirname2(path) {
        assertPath(path);
        if (path.length === 0)
          return ".";
        var code = path.charCodeAt(0);
        var hasRoot2 = code === 47;
        var end = -1;
        var matchedSlash = true;
        for (var i2 = path.length - 1; i2 >= 1; --i2) {
          code = path.charCodeAt(i2);
          if (code === 47) {
            if (!matchedSlash) {
              end = i2;
              break;
            }
          } else {
            matchedSlash = false;
          }
        }
        if (end === -1)
          return hasRoot2 ? "/" : ".";
        if (hasRoot2 && end === 1)
          return "//";
        return path.slice(0, end);
      },
      basename: function basename(path, ext) {
        if (ext !== void 0 && typeof ext !== "string")
          throw new TypeError('"ext" argument must be a string');
        assertPath(path);
        var start = 0;
        var end = -1;
        var matchedSlash = true;
        var i2;
        if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
          if (ext.length === path.length && ext === path)
            return "";
          var extIdx = ext.length - 1;
          var firstNonSlashEnd = -1;
          for (i2 = path.length - 1; i2 >= 0; --i2) {
            var code = path.charCodeAt(i2);
            if (code === 47) {
              if (!matchedSlash) {
                start = i2 + 1;
                break;
              }
            } else {
              if (firstNonSlashEnd === -1) {
                matchedSlash = false;
                firstNonSlashEnd = i2 + 1;
              }
              if (extIdx >= 0) {
                if (code === ext.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    end = i2;
                  }
                } else {
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }
          if (start === end)
            end = firstNonSlashEnd;
          else if (end === -1)
            end = path.length;
          return path.slice(start, end);
        } else {
          for (i2 = path.length - 1; i2 >= 0; --i2) {
            if (path.charCodeAt(i2) === 47) {
              if (!matchedSlash) {
                start = i2 + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i2 + 1;
            }
          }
          if (end === -1)
            return "";
          return path.slice(start, end);
        }
      },
      extname: function extname(path) {
        assertPath(path);
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var preDotState = 0;
        for (var i2 = path.length - 1; i2 >= 0; --i2) {
          var code = path.charCodeAt(i2);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i2 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i2 + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i2;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return "";
        }
        return path.slice(startDot, end);
      },
      format: function format(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") {
          throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
        }
        return _format("/", pathObject);
      },
      parse: function parse(path) {
        assertPath(path);
        var ret = { root: "", dir: "", base: "", ext: "", name: "" };
        if (path.length === 0)
          return ret;
        var code = path.charCodeAt(0);
        var isAbsolute = code === 47;
        var start;
        if (isAbsolute) {
          ret.root = "/";
          start = 1;
        } else {
          start = 0;
        }
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var i2 = path.length - 1;
        var preDotState = 0;
        for (; i2 >= start; --i2) {
          code = path.charCodeAt(i2);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i2 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i2 + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i2;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          if (end !== -1) {
            if (startPart === 0 && isAbsolute)
              ret.base = ret.name = path.slice(1, end);
            else
              ret.base = ret.name = path.slice(startPart, end);
          }
        } else {
          if (startPart === 0 && isAbsolute) {
            ret.name = path.slice(1, startDot);
            ret.base = path.slice(1, end);
          } else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
          }
          ret.ext = path.slice(startDot, end);
        }
        if (startPart > 0)
          ret.dir = path.slice(0, startPart - 1);
        else if (isAbsolute)
          ret.dir = "/";
        return ret;
      },
      sep: "/",
      delimiter: ":",
      win32: null,
      posix: null
    };
    posix.posix = posix;
    module2.exports = posix;
  }
});

// node_modules/diff-match-patch/index.js
var require_diff_match_patch = __commonJS({
  "node_modules/diff-match-patch/index.js"(exports, module2) {
    var diff_match_patch3 = function() {
      this.Diff_Timeout = 1;
      this.Diff_EditCost = 4;
      this.Match_Threshold = 0.5;
      this.Match_Distance = 1e3;
      this.Patch_DeleteThreshold = 0.5;
      this.Patch_Margin = 4;
      this.Match_MaxBits = 32;
    };
    var DIFF_DELETE = -1;
    var DIFF_INSERT = 1;
    var DIFF_EQUAL = 0;
    diff_match_patch3.Diff = function(op, text3) {
      return [op, text3];
    };
    diff_match_patch3.prototype.diff_main = function(text1, text22, opt_checklines, opt_deadline) {
      if (typeof opt_deadline == "undefined") {
        if (this.Diff_Timeout <= 0) {
          opt_deadline = Number.MAX_VALUE;
        } else {
          opt_deadline = new Date().getTime() + this.Diff_Timeout * 1e3;
        }
      }
      var deadline = opt_deadline;
      if (text1 == null || text22 == null) {
        throw new Error("Null input. (diff_main)");
      }
      if (text1 == text22) {
        if (text1) {
          return [new diff_match_patch3.Diff(DIFF_EQUAL, text1)];
        }
        return [];
      }
      if (typeof opt_checklines == "undefined") {
        opt_checklines = true;
      }
      var checklines = opt_checklines;
      var commonlength = this.diff_commonPrefix(text1, text22);
      var commonprefix = text1.substring(0, commonlength);
      text1 = text1.substring(commonlength);
      text22 = text22.substring(commonlength);
      commonlength = this.diff_commonSuffix(text1, text22);
      var commonsuffix = text1.substring(text1.length - commonlength);
      text1 = text1.substring(0, text1.length - commonlength);
      text22 = text22.substring(0, text22.length - commonlength);
      var diffs = this.diff_compute_(text1, text22, checklines, deadline);
      if (commonprefix) {
        diffs.unshift(new diff_match_patch3.Diff(DIFF_EQUAL, commonprefix));
      }
      if (commonsuffix) {
        diffs.push(new diff_match_patch3.Diff(DIFF_EQUAL, commonsuffix));
      }
      this.diff_cleanupMerge(diffs);
      return diffs;
    };
    diff_match_patch3.prototype.diff_compute_ = function(text1, text22, checklines, deadline) {
      var diffs;
      if (!text1) {
        return [new diff_match_patch3.Diff(DIFF_INSERT, text22)];
      }
      if (!text22) {
        return [new diff_match_patch3.Diff(DIFF_DELETE, text1)];
      }
      var longtext = text1.length > text22.length ? text1 : text22;
      var shorttext = text1.length > text22.length ? text22 : text1;
      var i2 = longtext.indexOf(shorttext);
      if (i2 != -1) {
        diffs = [
          new diff_match_patch3.Diff(DIFF_INSERT, longtext.substring(0, i2)),
          new diff_match_patch3.Diff(DIFF_EQUAL, shorttext),
          new diff_match_patch3.Diff(
            DIFF_INSERT,
            longtext.substring(i2 + shorttext.length)
          )
        ];
        if (text1.length > text22.length) {
          diffs[0][0] = diffs[2][0] = DIFF_DELETE;
        }
        return diffs;
      }
      if (shorttext.length == 1) {
        return [
          new diff_match_patch3.Diff(DIFF_DELETE, text1),
          new diff_match_patch3.Diff(DIFF_INSERT, text22)
        ];
      }
      var hm = this.diff_halfMatch_(text1, text22);
      if (hm) {
        var text1_a = hm[0];
        var text1_b = hm[1];
        var text2_a = hm[2];
        var text2_b = hm[3];
        var mid_common = hm[4];
        var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);
        var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);
        return diffs_a.concat(
          [new diff_match_patch3.Diff(DIFF_EQUAL, mid_common)],
          diffs_b
        );
      }
      if (checklines && text1.length > 100 && text22.length > 100) {
        return this.diff_lineMode_(text1, text22, deadline);
      }
      return this.diff_bisect_(text1, text22, deadline);
    };
    diff_match_patch3.prototype.diff_lineMode_ = function(text1, text22, deadline) {
      var a = this.diff_linesToChars_(text1, text22);
      text1 = a.chars1;
      text22 = a.chars2;
      var linearray = a.lineArray;
      var diffs = this.diff_main(text1, text22, false, deadline);
      this.diff_charsToLines_(diffs, linearray);
      this.diff_cleanupSemantic(diffs);
      diffs.push(new diff_match_patch3.Diff(DIFF_EQUAL, ""));
      var pointer = 0;
      var count_delete = 0;
      var count_insert = 0;
      var text_delete = "";
      var text_insert = "";
      while (pointer < diffs.length) {
        switch (diffs[pointer][0]) {
          case DIFF_INSERT:
            count_insert++;
            text_insert += diffs[pointer][1];
            break;
          case DIFF_DELETE:
            count_delete++;
            text_delete += diffs[pointer][1];
            break;
          case DIFF_EQUAL:
            if (count_delete >= 1 && count_insert >= 1) {
              diffs.splice(
                pointer - count_delete - count_insert,
                count_delete + count_insert
              );
              pointer = pointer - count_delete - count_insert;
              var subDiff = this.diff_main(text_delete, text_insert, false, deadline);
              for (var j = subDiff.length - 1; j >= 0; j--) {
                diffs.splice(pointer, 0, subDiff[j]);
              }
              pointer = pointer + subDiff.length;
            }
            count_insert = 0;
            count_delete = 0;
            text_delete = "";
            text_insert = "";
            break;
        }
        pointer++;
      }
      diffs.pop();
      return diffs;
    };
    diff_match_patch3.prototype.diff_bisect_ = function(text1, text22, deadline) {
      var text1_length = text1.length;
      var text2_length = text22.length;
      var max_d = Math.ceil((text1_length + text2_length) / 2);
      var v_offset = max_d;
      var v_length = 2 * max_d;
      var v1 = new Array(v_length);
      var v2 = new Array(v_length);
      for (var x = 0; x < v_length; x++) {
        v1[x] = -1;
        v2[x] = -1;
      }
      v1[v_offset + 1] = 0;
      v2[v_offset + 1] = 0;
      var delta = text1_length - text2_length;
      var front = delta % 2 != 0;
      var k1start = 0;
      var k1end = 0;
      var k2start = 0;
      var k2end = 0;
      for (var d = 0; d < max_d; d++) {
        if (new Date().getTime() > deadline) {
          break;
        }
        for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
          var k1_offset = v_offset + k1;
          var x1;
          if (k1 == -d || k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1]) {
            x1 = v1[k1_offset + 1];
          } else {
            x1 = v1[k1_offset - 1] + 1;
          }
          var y1 = x1 - k1;
          while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) == text22.charAt(y1)) {
            x1++;
            y1++;
          }
          v1[k1_offset] = x1;
          if (x1 > text1_length) {
            k1end += 2;
          } else if (y1 > text2_length) {
            k1start += 2;
          } else if (front) {
            var k2_offset = v_offset + delta - k1;
            if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
              var x2 = text1_length - v2[k2_offset];
              if (x1 >= x2) {
                return this.diff_bisectSplit_(text1, text22, x1, y1, deadline);
              }
            }
          }
        }
        for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
          var k2_offset = v_offset + k2;
          var x2;
          if (k2 == -d || k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1]) {
            x2 = v2[k2_offset + 1];
          } else {
            x2 = v2[k2_offset - 1] + 1;
          }
          var y2 = x2 - k2;
          while (x2 < text1_length && y2 < text2_length && text1.charAt(text1_length - x2 - 1) == text22.charAt(text2_length - y2 - 1)) {
            x2++;
            y2++;
          }
          v2[k2_offset] = x2;
          if (x2 > text1_length) {
            k2end += 2;
          } else if (y2 > text2_length) {
            k2start += 2;
          } else if (!front) {
            var k1_offset = v_offset + delta - k2;
            if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
              var x1 = v1[k1_offset];
              var y1 = v_offset + x1 - k1_offset;
              x2 = text1_length - x2;
              if (x1 >= x2) {
                return this.diff_bisectSplit_(text1, text22, x1, y1, deadline);
              }
            }
          }
        }
      }
      return [
        new diff_match_patch3.Diff(DIFF_DELETE, text1),
        new diff_match_patch3.Diff(DIFF_INSERT, text22)
      ];
    };
    diff_match_patch3.prototype.diff_bisectSplit_ = function(text1, text22, x, y, deadline) {
      var text1a = text1.substring(0, x);
      var text2a = text22.substring(0, y);
      var text1b = text1.substring(x);
      var text2b = text22.substring(y);
      var diffs = this.diff_main(text1a, text2a, false, deadline);
      var diffsb = this.diff_main(text1b, text2b, false, deadline);
      return diffs.concat(diffsb);
    };
    diff_match_patch3.prototype.diff_linesToChars_ = function(text1, text22) {
      var lineArray = [];
      var lineHash = {};
      lineArray[0] = "";
      function diff_linesToCharsMunge_(text3) {
        var chars = "";
        var lineStart = 0;
        var lineEnd = -1;
        var lineArrayLength = lineArray.length;
        while (lineEnd < text3.length - 1) {
          lineEnd = text3.indexOf("\n", lineStart);
          if (lineEnd == -1) {
            lineEnd = text3.length - 1;
          }
          var line = text3.substring(lineStart, lineEnd + 1);
          if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== void 0) {
            chars += String.fromCharCode(lineHash[line]);
          } else {
            if (lineArrayLength == maxLines) {
              line = text3.substring(lineStart);
              lineEnd = text3.length;
            }
            chars += String.fromCharCode(lineArrayLength);
            lineHash[line] = lineArrayLength;
            lineArray[lineArrayLength++] = line;
          }
          lineStart = lineEnd + 1;
        }
        return chars;
      }
      var maxLines = 4e4;
      var chars1 = diff_linesToCharsMunge_(text1);
      maxLines = 65535;
      var chars2 = diff_linesToCharsMunge_(text22);
      return { chars1, chars2, lineArray };
    };
    diff_match_patch3.prototype.diff_charsToLines_ = function(diffs, lineArray) {
      for (var i2 = 0; i2 < diffs.length; i2++) {
        var chars = diffs[i2][1];
        var text3 = [];
        for (var j = 0; j < chars.length; j++) {
          text3[j] = lineArray[chars.charCodeAt(j)];
        }
        diffs[i2][1] = text3.join("");
      }
    };
    diff_match_patch3.prototype.diff_commonPrefix = function(text1, text22) {
      if (!text1 || !text22 || text1.charAt(0) != text22.charAt(0)) {
        return 0;
      }
      var pointermin = 0;
      var pointermax = Math.min(text1.length, text22.length);
      var pointermid = pointermax;
      var pointerstart = 0;
      while (pointermin < pointermid) {
        if (text1.substring(pointerstart, pointermid) == text22.substring(pointerstart, pointermid)) {
          pointermin = pointermid;
          pointerstart = pointermin;
        } else {
          pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
      }
      return pointermid;
    };
    diff_match_patch3.prototype.diff_commonSuffix = function(text1, text22) {
      if (!text1 || !text22 || text1.charAt(text1.length - 1) != text22.charAt(text22.length - 1)) {
        return 0;
      }
      var pointermin = 0;
      var pointermax = Math.min(text1.length, text22.length);
      var pointermid = pointermax;
      var pointerend = 0;
      while (pointermin < pointermid) {
        if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text22.substring(text22.length - pointermid, text22.length - pointerend)) {
          pointermin = pointermid;
          pointerend = pointermin;
        } else {
          pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
      }
      return pointermid;
    };
    diff_match_patch3.prototype.diff_commonOverlap_ = function(text1, text22) {
      var text1_length = text1.length;
      var text2_length = text22.length;
      if (text1_length == 0 || text2_length == 0) {
        return 0;
      }
      if (text1_length > text2_length) {
        text1 = text1.substring(text1_length - text2_length);
      } else if (text1_length < text2_length) {
        text22 = text22.substring(0, text1_length);
      }
      var text_length = Math.min(text1_length, text2_length);
      if (text1 == text22) {
        return text_length;
      }
      var best = 0;
      var length4 = 1;
      while (true) {
        var pattern = text1.substring(text_length - length4);
        var found = text22.indexOf(pattern);
        if (found == -1) {
          return best;
        }
        length4 += found;
        if (found == 0 || text1.substring(text_length - length4) == text22.substring(0, length4)) {
          best = length4;
          length4++;
        }
      }
    };
    diff_match_patch3.prototype.diff_halfMatch_ = function(text1, text22) {
      if (this.Diff_Timeout <= 0) {
        return null;
      }
      var longtext = text1.length > text22.length ? text1 : text22;
      var shorttext = text1.length > text22.length ? text22 : text1;
      if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
        return null;
      }
      var dmp = this;
      function diff_halfMatchI_(longtext2, shorttext2, i2) {
        var seed = longtext2.substring(i2, i2 + Math.floor(longtext2.length / 4));
        var j = -1;
        var best_common = "";
        var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
        while ((j = shorttext2.indexOf(seed, j + 1)) != -1) {
          var prefixLength = dmp.diff_commonPrefix(
            longtext2.substring(i2),
            shorttext2.substring(j)
          );
          var suffixLength = dmp.diff_commonSuffix(
            longtext2.substring(0, i2),
            shorttext2.substring(0, j)
          );
          if (best_common.length < suffixLength + prefixLength) {
            best_common = shorttext2.substring(j - suffixLength, j) + shorttext2.substring(j, j + prefixLength);
            best_longtext_a = longtext2.substring(0, i2 - suffixLength);
            best_longtext_b = longtext2.substring(i2 + prefixLength);
            best_shorttext_a = shorttext2.substring(0, j - suffixLength);
            best_shorttext_b = shorttext2.substring(j + prefixLength);
          }
        }
        if (best_common.length * 2 >= longtext2.length) {
          return [
            best_longtext_a,
            best_longtext_b,
            best_shorttext_a,
            best_shorttext_b,
            best_common
          ];
        } else {
          return null;
        }
      }
      var hm1 = diff_halfMatchI_(
        longtext,
        shorttext,
        Math.ceil(longtext.length / 4)
      );
      var hm2 = diff_halfMatchI_(
        longtext,
        shorttext,
        Math.ceil(longtext.length / 2)
      );
      var hm;
      if (!hm1 && !hm2) {
        return null;
      } else if (!hm2) {
        hm = hm1;
      } else if (!hm1) {
        hm = hm2;
      } else {
        hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
      }
      var text1_a, text1_b, text2_a, text2_b;
      if (text1.length > text22.length) {
        text1_a = hm[0];
        text1_b = hm[1];
        text2_a = hm[2];
        text2_b = hm[3];
      } else {
        text2_a = hm[0];
        text2_b = hm[1];
        text1_a = hm[2];
        text1_b = hm[3];
      }
      var mid_common = hm[4];
      return [text1_a, text1_b, text2_a, text2_b, mid_common];
    };
    diff_match_patch3.prototype.diff_cleanupSemantic = function(diffs) {
      var changes = false;
      var equalities = [];
      var equalitiesLength = 0;
      var lastEquality = null;
      var pointer = 0;
      var length_insertions1 = 0;
      var length_deletions1 = 0;
      var length_insertions2 = 0;
      var length_deletions2 = 0;
      while (pointer < diffs.length) {
        if (diffs[pointer][0] == DIFF_EQUAL) {
          equalities[equalitiesLength++] = pointer;
          length_insertions1 = length_insertions2;
          length_deletions1 = length_deletions2;
          length_insertions2 = 0;
          length_deletions2 = 0;
          lastEquality = diffs[pointer][1];
        } else {
          if (diffs[pointer][0] == DIFF_INSERT) {
            length_insertions2 += diffs[pointer][1].length;
          } else {
            length_deletions2 += diffs[pointer][1].length;
          }
          if (lastEquality && lastEquality.length <= Math.max(length_insertions1, length_deletions1) && lastEquality.length <= Math.max(
            length_insertions2,
            length_deletions2
          )) {
            diffs.splice(
              equalities[equalitiesLength - 1],
              0,
              new diff_match_patch3.Diff(DIFF_DELETE, lastEquality)
            );
            diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
            equalitiesLength--;
            equalitiesLength--;
            pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
            length_insertions1 = 0;
            length_deletions1 = 0;
            length_insertions2 = 0;
            length_deletions2 = 0;
            lastEquality = null;
            changes = true;
          }
        }
        pointer++;
      }
      if (changes) {
        this.diff_cleanupMerge(diffs);
      }
      this.diff_cleanupSemanticLossless(diffs);
      pointer = 1;
      while (pointer < diffs.length) {
        if (diffs[pointer - 1][0] == DIFF_DELETE && diffs[pointer][0] == DIFF_INSERT) {
          var deletion = diffs[pointer - 1][1];
          var insertion = diffs[pointer][1];
          var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);
          var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);
          if (overlap_length1 >= overlap_length2) {
            if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {
              diffs.splice(pointer, 0, new diff_match_patch3.Diff(
                DIFF_EQUAL,
                insertion.substring(0, overlap_length1)
              ));
              diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlap_length1);
              diffs[pointer + 1][1] = insertion.substring(overlap_length1);
              pointer++;
            }
          } else {
            if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {
              diffs.splice(pointer, 0, new diff_match_patch3.Diff(
                DIFF_EQUAL,
                deletion.substring(0, overlap_length2)
              ));
              diffs[pointer - 1][0] = DIFF_INSERT;
              diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlap_length2);
              diffs[pointer + 1][0] = DIFF_DELETE;
              diffs[pointer + 1][1] = deletion.substring(overlap_length2);
              pointer++;
            }
          }
          pointer++;
        }
        pointer++;
      }
    };
    diff_match_patch3.prototype.diff_cleanupSemanticLossless = function(diffs) {
      function diff_cleanupSemanticScore_(one, two) {
        if (!one || !two) {
          return 6;
        }
        var char1 = one.charAt(one.length - 1);
        var char2 = two.charAt(0);
        var nonAlphaNumeric1 = char1.match(diff_match_patch3.nonAlphaNumericRegex_);
        var nonAlphaNumeric2 = char2.match(diff_match_patch3.nonAlphaNumericRegex_);
        var whitespace1 = nonAlphaNumeric1 && char1.match(diff_match_patch3.whitespaceRegex_);
        var whitespace2 = nonAlphaNumeric2 && char2.match(diff_match_patch3.whitespaceRegex_);
        var lineBreak1 = whitespace1 && char1.match(diff_match_patch3.linebreakRegex_);
        var lineBreak2 = whitespace2 && char2.match(diff_match_patch3.linebreakRegex_);
        var blankLine1 = lineBreak1 && one.match(diff_match_patch3.blanklineEndRegex_);
        var blankLine2 = lineBreak2 && two.match(diff_match_patch3.blanklineStartRegex_);
        if (blankLine1 || blankLine2) {
          return 5;
        } else if (lineBreak1 || lineBreak2) {
          return 4;
        } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
          return 3;
        } else if (whitespace1 || whitespace2) {
          return 2;
        } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
          return 1;
        }
        return 0;
      }
      var pointer = 1;
      while (pointer < diffs.length - 1) {
        if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
          var equality1 = diffs[pointer - 1][1];
          var edit = diffs[pointer][1];
          var equality2 = diffs[pointer + 1][1];
          var commonOffset = this.diff_commonSuffix(equality1, edit);
          if (commonOffset) {
            var commonString = edit.substring(edit.length - commonOffset);
            equality1 = equality1.substring(0, equality1.length - commonOffset);
            edit = commonString + edit.substring(0, edit.length - commonOffset);
            equality2 = commonString + equality2;
          }
          var bestEquality1 = equality1;
          var bestEdit = edit;
          var bestEquality2 = equality2;
          var bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
          while (edit.charAt(0) === equality2.charAt(0)) {
            equality1 += edit.charAt(0);
            edit = edit.substring(1) + equality2.charAt(0);
            equality2 = equality2.substring(1);
            var score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
            if (score >= bestScore) {
              bestScore = score;
              bestEquality1 = equality1;
              bestEdit = edit;
              bestEquality2 = equality2;
            }
          }
          if (diffs[pointer - 1][1] != bestEquality1) {
            if (bestEquality1) {
              diffs[pointer - 1][1] = bestEquality1;
            } else {
              diffs.splice(pointer - 1, 1);
              pointer--;
            }
            diffs[pointer][1] = bestEdit;
            if (bestEquality2) {
              diffs[pointer + 1][1] = bestEquality2;
            } else {
              diffs.splice(pointer + 1, 1);
              pointer--;
            }
          }
        }
        pointer++;
      }
    };
    diff_match_patch3.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
    diff_match_patch3.whitespaceRegex_ = /\s/;
    diff_match_patch3.linebreakRegex_ = /[\r\n]/;
    diff_match_patch3.blanklineEndRegex_ = /\n\r?\n$/;
    diff_match_patch3.blanklineStartRegex_ = /^\r?\n\r?\n/;
    diff_match_patch3.prototype.diff_cleanupEfficiency = function(diffs) {
      var changes = false;
      var equalities = [];
      var equalitiesLength = 0;
      var lastEquality = null;
      var pointer = 0;
      var pre_ins = false;
      var pre_del = false;
      var post_ins = false;
      var post_del = false;
      while (pointer < diffs.length) {
        if (diffs[pointer][0] == DIFF_EQUAL) {
          if (diffs[pointer][1].length < this.Diff_EditCost && (post_ins || post_del)) {
            equalities[equalitiesLength++] = pointer;
            pre_ins = post_ins;
            pre_del = post_del;
            lastEquality = diffs[pointer][1];
          } else {
            equalitiesLength = 0;
            lastEquality = null;
          }
          post_ins = post_del = false;
        } else {
          if (diffs[pointer][0] == DIFF_DELETE) {
            post_del = true;
          } else {
            post_ins = true;
          }
          if (lastEquality && (pre_ins && pre_del && post_ins && post_del || lastEquality.length < this.Diff_EditCost / 2 && pre_ins + pre_del + post_ins + post_del == 3)) {
            diffs.splice(
              equalities[equalitiesLength - 1],
              0,
              new diff_match_patch3.Diff(DIFF_DELETE, lastEquality)
            );
            diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
            equalitiesLength--;
            lastEquality = null;
            if (pre_ins && pre_del) {
              post_ins = post_del = true;
              equalitiesLength = 0;
            } else {
              equalitiesLength--;
              pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
              post_ins = post_del = false;
            }
            changes = true;
          }
        }
        pointer++;
      }
      if (changes) {
        this.diff_cleanupMerge(diffs);
      }
    };
    diff_match_patch3.prototype.diff_cleanupMerge = function(diffs) {
      diffs.push(new diff_match_patch3.Diff(DIFF_EQUAL, ""));
      var pointer = 0;
      var count_delete = 0;
      var count_insert = 0;
      var text_delete = "";
      var text_insert = "";
      var commonlength;
      while (pointer < diffs.length) {
        switch (diffs[pointer][0]) {
          case DIFF_INSERT:
            count_insert++;
            text_insert += diffs[pointer][1];
            pointer++;
            break;
          case DIFF_DELETE:
            count_delete++;
            text_delete += diffs[pointer][1];
            pointer++;
            break;
          case DIFF_EQUAL:
            if (count_delete + count_insert > 1) {
              if (count_delete !== 0 && count_insert !== 0) {
                commonlength = this.diff_commonPrefix(text_insert, text_delete);
                if (commonlength !== 0) {
                  if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] == DIFF_EQUAL) {
                    diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);
                  } else {
                    diffs.splice(0, 0, new diff_match_patch3.Diff(
                      DIFF_EQUAL,
                      text_insert.substring(0, commonlength)
                    ));
                    pointer++;
                  }
                  text_insert = text_insert.substring(commonlength);
                  text_delete = text_delete.substring(commonlength);
                }
                commonlength = this.diff_commonSuffix(text_insert, text_delete);
                if (commonlength !== 0) {
                  diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
                  text_insert = text_insert.substring(0, text_insert.length - commonlength);
                  text_delete = text_delete.substring(0, text_delete.length - commonlength);
                }
              }
              pointer -= count_delete + count_insert;
              diffs.splice(pointer, count_delete + count_insert);
              if (text_delete.length) {
                diffs.splice(
                  pointer,
                  0,
                  new diff_match_patch3.Diff(DIFF_DELETE, text_delete)
                );
                pointer++;
              }
              if (text_insert.length) {
                diffs.splice(
                  pointer,
                  0,
                  new diff_match_patch3.Diff(DIFF_INSERT, text_insert)
                );
                pointer++;
              }
              pointer++;
            } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
              diffs[pointer - 1][1] += diffs[pointer][1];
              diffs.splice(pointer, 1);
            } else {
              pointer++;
            }
            count_insert = 0;
            count_delete = 0;
            text_delete = "";
            text_insert = "";
            break;
        }
      }
      if (diffs[diffs.length - 1][1] === "") {
        diffs.pop();
      }
      var changes = false;
      pointer = 1;
      while (pointer < diffs.length - 1) {
        if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
          if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
            diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
            diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
            diffs.splice(pointer - 1, 1);
            changes = true;
          } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
            diffs[pointer - 1][1] += diffs[pointer + 1][1];
            diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
            diffs.splice(pointer + 1, 1);
            changes = true;
          }
        }
        pointer++;
      }
      if (changes) {
        this.diff_cleanupMerge(diffs);
      }
    };
    diff_match_patch3.prototype.diff_xIndex = function(diffs, loc) {
      var chars1 = 0;
      var chars2 = 0;
      var last_chars1 = 0;
      var last_chars2 = 0;
      var x;
      for (x = 0; x < diffs.length; x++) {
        if (diffs[x][0] !== DIFF_INSERT) {
          chars1 += diffs[x][1].length;
        }
        if (diffs[x][0] !== DIFF_DELETE) {
          chars2 += diffs[x][1].length;
        }
        if (chars1 > loc) {
          break;
        }
        last_chars1 = chars1;
        last_chars2 = chars2;
      }
      if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {
        return last_chars2;
      }
      return last_chars2 + (loc - last_chars1);
    };
    diff_match_patch3.prototype.diff_prettyHtml = function(diffs) {
      var html = [];
      var pattern_amp = /&/g;
      var pattern_lt = /</g;
      var pattern_gt = />/g;
      var pattern_para = /\n/g;
      for (var x = 0; x < diffs.length; x++) {
        var op = diffs[x][0];
        var data = diffs[x][1];
        var text3 = data.replace(pattern_amp, "&amp;").replace(pattern_lt, "&lt;").replace(pattern_gt, "&gt;").replace(pattern_para, "&para;<br>");
        switch (op) {
          case DIFF_INSERT:
            html[x] = '<ins style="background:#e6ffe6;">' + text3 + "</ins>";
            break;
          case DIFF_DELETE:
            html[x] = '<del style="background:#ffe6e6;">' + text3 + "</del>";
            break;
          case DIFF_EQUAL:
            html[x] = "<span>" + text3 + "</span>";
            break;
        }
      }
      return html.join("");
    };
    diff_match_patch3.prototype.diff_text1 = function(diffs) {
      var text3 = [];
      for (var x = 0; x < diffs.length; x++) {
        if (diffs[x][0] !== DIFF_INSERT) {
          text3[x] = diffs[x][1];
        }
      }
      return text3.join("");
    };
    diff_match_patch3.prototype.diff_text2 = function(diffs) {
      var text3 = [];
      for (var x = 0; x < diffs.length; x++) {
        if (diffs[x][0] !== DIFF_DELETE) {
          text3[x] = diffs[x][1];
        }
      }
      return text3.join("");
    };
    diff_match_patch3.prototype.diff_levenshtein = function(diffs) {
      var levenshtein = 0;
      var insertions = 0;
      var deletions = 0;
      for (var x = 0; x < diffs.length; x++) {
        var op = diffs[x][0];
        var data = diffs[x][1];
        switch (op) {
          case DIFF_INSERT:
            insertions += data.length;
            break;
          case DIFF_DELETE:
            deletions += data.length;
            break;
          case DIFF_EQUAL:
            levenshtein += Math.max(insertions, deletions);
            insertions = 0;
            deletions = 0;
            break;
        }
      }
      levenshtein += Math.max(insertions, deletions);
      return levenshtein;
    };
    diff_match_patch3.prototype.diff_toDelta = function(diffs) {
      var text3 = [];
      for (var x = 0; x < diffs.length; x++) {
        switch (diffs[x][0]) {
          case DIFF_INSERT:
            text3[x] = "+" + encodeURI(diffs[x][1]);
            break;
          case DIFF_DELETE:
            text3[x] = "-" + diffs[x][1].length;
            break;
          case DIFF_EQUAL:
            text3[x] = "=" + diffs[x][1].length;
            break;
        }
      }
      return text3.join("	").replace(/%20/g, " ");
    };
    diff_match_patch3.prototype.diff_fromDelta = function(text1, delta) {
      var diffs = [];
      var diffsLength = 0;
      var pointer = 0;
      var tokens = delta.split(/\t/g);
      for (var x = 0; x < tokens.length; x++) {
        var param = tokens[x].substring(1);
        switch (tokens[x].charAt(0)) {
          case "+":
            try {
              diffs[diffsLength++] = new diff_match_patch3.Diff(DIFF_INSERT, decodeURI(param));
            } catch (ex) {
              throw new Error("Illegal escape in diff_fromDelta: " + param);
            }
            break;
          case "-":
          case "=":
            var n = parseInt(param, 10);
            if (isNaN(n) || n < 0) {
              throw new Error("Invalid number in diff_fromDelta: " + param);
            }
            var text3 = text1.substring(pointer, pointer += n);
            if (tokens[x].charAt(0) == "=") {
              diffs[diffsLength++] = new diff_match_patch3.Diff(DIFF_EQUAL, text3);
            } else {
              diffs[diffsLength++] = new diff_match_patch3.Diff(DIFF_DELETE, text3);
            }
            break;
          default:
            if (tokens[x]) {
              throw new Error("Invalid diff operation in diff_fromDelta: " + tokens[x]);
            }
        }
      }
      if (pointer != text1.length) {
        throw new Error("Delta length (" + pointer + ") does not equal source text length (" + text1.length + ").");
      }
      return diffs;
    };
    diff_match_patch3.prototype.match_main = function(text3, pattern, loc) {
      if (text3 == null || pattern == null || loc == null) {
        throw new Error("Null input. (match_main)");
      }
      loc = Math.max(0, Math.min(loc, text3.length));
      if (text3 == pattern) {
        return 0;
      } else if (!text3.length) {
        return -1;
      } else if (text3.substring(loc, loc + pattern.length) == pattern) {
        return loc;
      } else {
        return this.match_bitap_(text3, pattern, loc);
      }
    };
    diff_match_patch3.prototype.match_bitap_ = function(text3, pattern, loc) {
      if (pattern.length > this.Match_MaxBits) {
        throw new Error("Pattern too long for this browser.");
      }
      var s2 = this.match_alphabet_(pattern);
      var dmp = this;
      function match_bitapScore_(e2, x) {
        var accuracy = e2 / pattern.length;
        var proximity = Math.abs(loc - x);
        if (!dmp.Match_Distance) {
          return proximity ? 1 : accuracy;
        }
        return accuracy + proximity / dmp.Match_Distance;
      }
      var score_threshold = this.Match_Threshold;
      var best_loc = text3.indexOf(pattern, loc);
      if (best_loc != -1) {
        score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
        best_loc = text3.lastIndexOf(pattern, loc + pattern.length);
        if (best_loc != -1) {
          score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
        }
      }
      var matchmask = 1 << pattern.length - 1;
      best_loc = -1;
      var bin_min, bin_mid;
      var bin_max = pattern.length + text3.length;
      var last_rd;
      for (var d = 0; d < pattern.length; d++) {
        bin_min = 0;
        bin_mid = bin_max;
        while (bin_min < bin_mid) {
          if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {
            bin_min = bin_mid;
          } else {
            bin_max = bin_mid;
          }
          bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);
        }
        bin_max = bin_mid;
        var start = Math.max(1, loc - bin_mid + 1);
        var finish = Math.min(loc + bin_mid, text3.length) + pattern.length;
        var rd = Array(finish + 2);
        rd[finish + 1] = (1 << d) - 1;
        for (var j = finish; j >= start; j--) {
          var charMatch = s2[text3.charAt(j - 1)];
          if (d === 0) {
            rd[j] = (rd[j + 1] << 1 | 1) & charMatch;
          } else {
            rd[j] = (rd[j + 1] << 1 | 1) & charMatch | ((last_rd[j + 1] | last_rd[j]) << 1 | 1) | last_rd[j + 1];
          }
          if (rd[j] & matchmask) {
            var score = match_bitapScore_(d, j - 1);
            if (score <= score_threshold) {
              score_threshold = score;
              best_loc = j - 1;
              if (best_loc > loc) {
                start = Math.max(1, 2 * loc - best_loc);
              } else {
                break;
              }
            }
          }
        }
        if (match_bitapScore_(d + 1, loc) > score_threshold) {
          break;
        }
        last_rd = rd;
      }
      return best_loc;
    };
    diff_match_patch3.prototype.match_alphabet_ = function(pattern) {
      var s2 = {};
      for (var i2 = 0; i2 < pattern.length; i2++) {
        s2[pattern.charAt(i2)] = 0;
      }
      for (var i2 = 0; i2 < pattern.length; i2++) {
        s2[pattern.charAt(i2)] |= 1 << pattern.length - i2 - 1;
      }
      return s2;
    };
    diff_match_patch3.prototype.patch_addContext_ = function(patch, text3) {
      if (text3.length == 0) {
        return;
      }
      if (patch.start2 === null) {
        throw Error("patch not initialized");
      }
      var pattern = text3.substring(patch.start2, patch.start2 + patch.length1);
      var padding = 0;
      while (text3.indexOf(pattern) != text3.lastIndexOf(pattern) && pattern.length < this.Match_MaxBits - this.Patch_Margin - this.Patch_Margin) {
        padding += this.Patch_Margin;
        pattern = text3.substring(
          patch.start2 - padding,
          patch.start2 + patch.length1 + padding
        );
      }
      padding += this.Patch_Margin;
      var prefix = text3.substring(patch.start2 - padding, patch.start2);
      if (prefix) {
        patch.diffs.unshift(new diff_match_patch3.Diff(DIFF_EQUAL, prefix));
      }
      var suffix = text3.substring(
        patch.start2 + patch.length1,
        patch.start2 + patch.length1 + padding
      );
      if (suffix) {
        patch.diffs.push(new diff_match_patch3.Diff(DIFF_EQUAL, suffix));
      }
      patch.start1 -= prefix.length;
      patch.start2 -= prefix.length;
      patch.length1 += prefix.length + suffix.length;
      patch.length2 += prefix.length + suffix.length;
    };
    diff_match_patch3.prototype.patch_make = function(a, opt_b, opt_c) {
      var text1, diffs;
      if (typeof a == "string" && typeof opt_b == "string" && typeof opt_c == "undefined") {
        text1 = /** @type {string} */
        a;
        diffs = this.diff_main(
          text1,
          /** @type {string} */
          opt_b,
          true
        );
        if (diffs.length > 2) {
          this.diff_cleanupSemantic(diffs);
          this.diff_cleanupEfficiency(diffs);
        }
      } else if (a && typeof a == "object" && typeof opt_b == "undefined" && typeof opt_c == "undefined") {
        diffs = /** @type {!Array.<!diff_match_patch.Diff>} */
        a;
        text1 = this.diff_text1(diffs);
      } else if (typeof a == "string" && opt_b && typeof opt_b == "object" && typeof opt_c == "undefined") {
        text1 = /** @type {string} */
        a;
        diffs = /** @type {!Array.<!diff_match_patch.Diff>} */
        opt_b;
      } else if (typeof a == "string" && typeof opt_b == "string" && opt_c && typeof opt_c == "object") {
        text1 = /** @type {string} */
        a;
        diffs = /** @type {!Array.<!diff_match_patch.Diff>} */
        opt_c;
      } else {
        throw new Error("Unknown call format to patch_make.");
      }
      if (diffs.length === 0) {
        return [];
      }
      var patches = [];
      var patch = new diff_match_patch3.patch_obj();
      var patchDiffLength = 0;
      var char_count1 = 0;
      var char_count2 = 0;
      var prepatch_text = text1;
      var postpatch_text = text1;
      for (var x = 0; x < diffs.length; x++) {
        var diff_type = diffs[x][0];
        var diff_text = diffs[x][1];
        if (!patchDiffLength && diff_type !== DIFF_EQUAL) {
          patch.start1 = char_count1;
          patch.start2 = char_count2;
        }
        switch (diff_type) {
          case DIFF_INSERT:
            patch.diffs[patchDiffLength++] = diffs[x];
            patch.length2 += diff_text.length;
            postpatch_text = postpatch_text.substring(0, char_count2) + diff_text + postpatch_text.substring(char_count2);
            break;
          case DIFF_DELETE:
            patch.length1 += diff_text.length;
            patch.diffs[patchDiffLength++] = diffs[x];
            postpatch_text = postpatch_text.substring(0, char_count2) + postpatch_text.substring(char_count2 + diff_text.length);
            break;
          case DIFF_EQUAL:
            if (diff_text.length <= 2 * this.Patch_Margin && patchDiffLength && diffs.length != x + 1) {
              patch.diffs[patchDiffLength++] = diffs[x];
              patch.length1 += diff_text.length;
              patch.length2 += diff_text.length;
            } else if (diff_text.length >= 2 * this.Patch_Margin) {
              if (patchDiffLength) {
                this.patch_addContext_(patch, prepatch_text);
                patches.push(patch);
                patch = new diff_match_patch3.patch_obj();
                patchDiffLength = 0;
                prepatch_text = postpatch_text;
                char_count1 = char_count2;
              }
            }
            break;
        }
        if (diff_type !== DIFF_INSERT) {
          char_count1 += diff_text.length;
        }
        if (diff_type !== DIFF_DELETE) {
          char_count2 += diff_text.length;
        }
      }
      if (patchDiffLength) {
        this.patch_addContext_(patch, prepatch_text);
        patches.push(patch);
      }
      return patches;
    };
    diff_match_patch3.prototype.patch_deepCopy = function(patches) {
      var patchesCopy = [];
      for (var x = 0; x < patches.length; x++) {
        var patch = patches[x];
        var patchCopy = new diff_match_patch3.patch_obj();
        patchCopy.diffs = [];
        for (var y = 0; y < patch.diffs.length; y++) {
          patchCopy.diffs[y] = new diff_match_patch3.Diff(patch.diffs[y][0], patch.diffs[y][1]);
        }
        patchCopy.start1 = patch.start1;
        patchCopy.start2 = patch.start2;
        patchCopy.length1 = patch.length1;
        patchCopy.length2 = patch.length2;
        patchesCopy[x] = patchCopy;
      }
      return patchesCopy;
    };
    diff_match_patch3.prototype.patch_apply = function(patches, text3) {
      if (patches.length == 0) {
        return [text3, []];
      }
      patches = this.patch_deepCopy(patches);
      var nullPadding = this.patch_addPadding(patches);
      text3 = nullPadding + text3 + nullPadding;
      this.patch_splitMax(patches);
      var delta = 0;
      var results = [];
      for (var x = 0; x < patches.length; x++) {
        var expected_loc = patches[x].start2 + delta;
        var text1 = this.diff_text1(patches[x].diffs);
        var start_loc;
        var end_loc = -1;
        if (text1.length > this.Match_MaxBits) {
          start_loc = this.match_main(
            text3,
            text1.substring(0, this.Match_MaxBits),
            expected_loc
          );
          if (start_loc != -1) {
            end_loc = this.match_main(
              text3,
              text1.substring(text1.length - this.Match_MaxBits),
              expected_loc + text1.length - this.Match_MaxBits
            );
            if (end_loc == -1 || start_loc >= end_loc) {
              start_loc = -1;
            }
          }
        } else {
          start_loc = this.match_main(text3, text1, expected_loc);
        }
        if (start_loc == -1) {
          results[x] = false;
          delta -= patches[x].length2 - patches[x].length1;
        } else {
          results[x] = true;
          delta = start_loc - expected_loc;
          var text22;
          if (end_loc == -1) {
            text22 = text3.substring(start_loc, start_loc + text1.length);
          } else {
            text22 = text3.substring(start_loc, end_loc + this.Match_MaxBits);
          }
          if (text1 == text22) {
            text3 = text3.substring(0, start_loc) + this.diff_text2(patches[x].diffs) + text3.substring(start_loc + text1.length);
          } else {
            var diffs = this.diff_main(text1, text22, false);
            if (text1.length > this.Match_MaxBits && this.diff_levenshtein(diffs) / text1.length > this.Patch_DeleteThreshold) {
              results[x] = false;
            } else {
              this.diff_cleanupSemanticLossless(diffs);
              var index1 = 0;
              var index2;
              for (var y = 0; y < patches[x].diffs.length; y++) {
                var mod = patches[x].diffs[y];
                if (mod[0] !== DIFF_EQUAL) {
                  index2 = this.diff_xIndex(diffs, index1);
                }
                if (mod[0] === DIFF_INSERT) {
                  text3 = text3.substring(0, start_loc + index2) + mod[1] + text3.substring(start_loc + index2);
                } else if (mod[0] === DIFF_DELETE) {
                  text3 = text3.substring(0, start_loc + index2) + text3.substring(start_loc + this.diff_xIndex(
                    diffs,
                    index1 + mod[1].length
                  ));
                }
                if (mod[0] !== DIFF_DELETE) {
                  index1 += mod[1].length;
                }
              }
            }
          }
        }
      }
      text3 = text3.substring(nullPadding.length, text3.length - nullPadding.length);
      return [text3, results];
    };
    diff_match_patch3.prototype.patch_addPadding = function(patches) {
      var paddingLength = this.Patch_Margin;
      var nullPadding = "";
      for (var x = 1; x <= paddingLength; x++) {
        nullPadding += String.fromCharCode(x);
      }
      for (var x = 0; x < patches.length; x++) {
        patches[x].start1 += paddingLength;
        patches[x].start2 += paddingLength;
      }
      var patch = patches[0];
      var diffs = patch.diffs;
      if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {
        diffs.unshift(new diff_match_patch3.Diff(DIFF_EQUAL, nullPadding));
        patch.start1 -= paddingLength;
        patch.start2 -= paddingLength;
        patch.length1 += paddingLength;
        patch.length2 += paddingLength;
      } else if (paddingLength > diffs[0][1].length) {
        var extraLength = paddingLength - diffs[0][1].length;
        diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];
        patch.start1 -= extraLength;
        patch.start2 -= extraLength;
        patch.length1 += extraLength;
        patch.length2 += extraLength;
      }
      patch = patches[patches.length - 1];
      diffs = patch.diffs;
      if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {
        diffs.push(new diff_match_patch3.Diff(DIFF_EQUAL, nullPadding));
        patch.length1 += paddingLength;
        patch.length2 += paddingLength;
      } else if (paddingLength > diffs[diffs.length - 1][1].length) {
        var extraLength = paddingLength - diffs[diffs.length - 1][1].length;
        diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);
        patch.length1 += extraLength;
        patch.length2 += extraLength;
      }
      return nullPadding;
    };
    diff_match_patch3.prototype.patch_splitMax = function(patches) {
      var patch_size = this.Match_MaxBits;
      for (var x = 0; x < patches.length; x++) {
        if (patches[x].length1 <= patch_size) {
          continue;
        }
        var bigpatch = patches[x];
        patches.splice(x--, 1);
        var start1 = bigpatch.start1;
        var start2 = bigpatch.start2;
        var precontext = "";
        while (bigpatch.diffs.length !== 0) {
          var patch = new diff_match_patch3.patch_obj();
          var empty2 = true;
          patch.start1 = start1 - precontext.length;
          patch.start2 = start2 - precontext.length;
          if (precontext !== "") {
            patch.length1 = patch.length2 = precontext.length;
            patch.diffs.push(new diff_match_patch3.Diff(DIFF_EQUAL, precontext));
          }
          while (bigpatch.diffs.length !== 0 && patch.length1 < patch_size - this.Patch_Margin) {
            var diff_type = bigpatch.diffs[0][0];
            var diff_text = bigpatch.diffs[0][1];
            if (diff_type === DIFF_INSERT) {
              patch.length2 += diff_text.length;
              start2 += diff_text.length;
              patch.diffs.push(bigpatch.diffs.shift());
              empty2 = false;
            } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 && patch.diffs[0][0] == DIFF_EQUAL && diff_text.length > 2 * patch_size) {
              patch.length1 += diff_text.length;
              start1 += diff_text.length;
              empty2 = false;
              patch.diffs.push(new diff_match_patch3.Diff(diff_type, diff_text));
              bigpatch.diffs.shift();
            } else {
              diff_text = diff_text.substring(
                0,
                patch_size - patch.length1 - this.Patch_Margin
              );
              patch.length1 += diff_text.length;
              start1 += diff_text.length;
              if (diff_type === DIFF_EQUAL) {
                patch.length2 += diff_text.length;
                start2 += diff_text.length;
              } else {
                empty2 = false;
              }
              patch.diffs.push(new diff_match_patch3.Diff(diff_type, diff_text));
              if (diff_text == bigpatch.diffs[0][1]) {
                bigpatch.diffs.shift();
              } else {
                bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(diff_text.length);
              }
            }
          }
          precontext = this.diff_text2(patch.diffs);
          precontext = precontext.substring(precontext.length - this.Patch_Margin);
          var postcontext = this.diff_text1(bigpatch.diffs).substring(0, this.Patch_Margin);
          if (postcontext !== "") {
            patch.length1 += postcontext.length;
            patch.length2 += postcontext.length;
            if (patch.diffs.length !== 0 && patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {
              patch.diffs[patch.diffs.length - 1][1] += postcontext;
            } else {
              patch.diffs.push(new diff_match_patch3.Diff(DIFF_EQUAL, postcontext));
            }
          }
          if (!empty2) {
            patches.splice(++x, 0, patch);
          }
        }
      }
    };
    diff_match_patch3.prototype.patch_toText = function(patches) {
      var text3 = [];
      for (var x = 0; x < patches.length; x++) {
        text3[x] = patches[x];
      }
      return text3.join("");
    };
    diff_match_patch3.prototype.patch_fromText = function(textline) {
      var patches = [];
      if (!textline) {
        return patches;
      }
      var text3 = textline.split("\n");
      var textPointer = 0;
      var patchHeader = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
      while (textPointer < text3.length) {
        var m = text3[textPointer].match(patchHeader);
        if (!m) {
          throw new Error("Invalid patch string: " + text3[textPointer]);
        }
        var patch = new diff_match_patch3.patch_obj();
        patches.push(patch);
        patch.start1 = parseInt(m[1], 10);
        if (m[2] === "") {
          patch.start1--;
          patch.length1 = 1;
        } else if (m[2] == "0") {
          patch.length1 = 0;
        } else {
          patch.start1--;
          patch.length1 = parseInt(m[2], 10);
        }
        patch.start2 = parseInt(m[3], 10);
        if (m[4] === "") {
          patch.start2--;
          patch.length2 = 1;
        } else if (m[4] == "0") {
          patch.length2 = 0;
        } else {
          patch.start2--;
          patch.length2 = parseInt(m[4], 10);
        }
        textPointer++;
        while (textPointer < text3.length) {
          var sign = text3[textPointer].charAt(0);
          try {
            var line = decodeURI(text3[textPointer].substring(1));
          } catch (ex) {
            throw new Error("Illegal escape in patch_fromText: " + line);
          }
          if (sign == "-") {
            patch.diffs.push(new diff_match_patch3.Diff(DIFF_DELETE, line));
          } else if (sign == "+") {
            patch.diffs.push(new diff_match_patch3.Diff(DIFF_INSERT, line));
          } else if (sign == " ") {
            patch.diffs.push(new diff_match_patch3.Diff(DIFF_EQUAL, line));
          } else if (sign == "@") {
            break;
          } else if (sign === "") {
          } else {
            throw new Error('Invalid patch mode "' + sign + '" in: ' + line);
          }
          textPointer++;
        }
      }
      return patches;
    };
    diff_match_patch3.patch_obj = function() {
      this.diffs = [];
      this.start1 = null;
      this.start2 = null;
      this.length1 = 0;
      this.length2 = 0;
    };
    diff_match_patch3.patch_obj.prototype.toString = function() {
      var coords1, coords2;
      if (this.length1 === 0) {
        coords1 = this.start1 + ",0";
      } else if (this.length1 == 1) {
        coords1 = this.start1 + 1;
      } else {
        coords1 = this.start1 + 1 + "," + this.length1;
      }
      if (this.length2 === 0) {
        coords2 = this.start2 + ",0";
      } else if (this.length2 == 1) {
        coords2 = this.start2 + 1;
      } else {
        coords2 = this.start2 + 1 + "," + this.length2;
      }
      var text3 = ["@@ -" + coords1 + " +" + coords2 + " @@\n"];
      var op;
      for (var x = 0; x < this.diffs.length; x++) {
        switch (this.diffs[x][0]) {
          case DIFF_INSERT:
            op = "+";
            break;
          case DIFF_DELETE:
            op = "-";
            break;
          case DIFF_EQUAL:
            op = " ";
            break;
        }
        text3[x + 1] = op + encodeURI(this.diffs[x][1]) + "\n";
      }
      return text3.join("").replace(/%20/g, " ");
    };
    module2.exports = diff_match_patch3;
    module2.exports["diff_match_patch"] = diff_match_patch3;
    module2.exports["DIFF_DELETE"] = DIFF_DELETE;
    module2.exports["DIFF_INSERT"] = DIFF_INSERT;
    module2.exports["DIFF_EQUAL"] = DIFF_EQUAL;
  }
});

// node_modules/eventsource/lib/eventsource.js
var require_eventsource = __commonJS({
  "node_modules/eventsource/lib/eventsource.js"(exports, module2) {
    var parse = require("url").parse;
    var events = require("events");
    var https = require("https");
    var http = require("http");
    var util = require("util");
    var httpsOptions = [
      "pfx",
      "key",
      "passphrase",
      "cert",
      "ca",
      "ciphers",
      "rejectUnauthorized",
      "secureProtocol",
      "servername",
      "checkServerIdentity"
    ];
    var bom = [239, 187, 191];
    var colon = 58;
    var space2 = 32;
    var lineFeed = 10;
    var carriageReturn = 13;
    var maxBufferAheadAllocation = 1024 * 256;
    var reUnsafeHeader = /^(cookie|authorization)$/i;
    function hasBom(buf) {
      return bom.every(function(charCode, index) {
        return buf[index] === charCode;
      });
    }
    function EventSource2(url, eventSourceInitDict) {
      var readyState = EventSource2.CONNECTING;
      var headers = eventSourceInitDict && eventSourceInitDict.headers;
      var hasNewOrigin = false;
      Object.defineProperty(this, "readyState", {
        get: function() {
          return readyState;
        }
      });
      Object.defineProperty(this, "url", {
        get: function() {
          return url;
        }
      });
      var self = this;
      self.reconnectInterval = 1e3;
      self.connectionInProgress = false;
      function onConnectionClosed(message) {
        if (readyState === EventSource2.CLOSED)
          return;
        readyState = EventSource2.CONNECTING;
        _emit("error", new Event("error", { message }));
        if (reconnectUrl) {
          url = reconnectUrl;
          reconnectUrl = null;
          hasNewOrigin = false;
        }
        setTimeout(function() {
          if (readyState !== EventSource2.CONNECTING || self.connectionInProgress) {
            return;
          }
          self.connectionInProgress = true;
          connect();
        }, self.reconnectInterval);
      }
      var req;
      var lastEventId = "";
      if (headers && headers["Last-Event-ID"]) {
        lastEventId = headers["Last-Event-ID"];
        delete headers["Last-Event-ID"];
      }
      var discardTrailingNewline = false;
      var data = "";
      var eventName = "";
      var reconnectUrl = null;
      function connect() {
        var options = parse(url);
        var isSecure = options.protocol === "https:";
        options.headers = { "Cache-Control": "no-cache", "Accept": "text/event-stream" };
        if (lastEventId)
          options.headers["Last-Event-ID"] = lastEventId;
        if (headers) {
          var reqHeaders = hasNewOrigin ? removeUnsafeHeaders(headers) : headers;
          for (var i2 in reqHeaders) {
            var header = reqHeaders[i2];
            if (header) {
              options.headers[i2] = header;
            }
          }
        }
        options.rejectUnauthorized = !(eventSourceInitDict && !eventSourceInitDict.rejectUnauthorized);
        if (eventSourceInitDict && eventSourceInitDict.createConnection !== void 0) {
          options.createConnection = eventSourceInitDict.createConnection;
        }
        var useProxy = eventSourceInitDict && eventSourceInitDict.proxy;
        if (useProxy) {
          var proxy = parse(eventSourceInitDict.proxy);
          isSecure = proxy.protocol === "https:";
          options.protocol = isSecure ? "https:" : "http:";
          options.path = url;
          options.headers.Host = options.host;
          options.hostname = proxy.hostname;
          options.host = proxy.host;
          options.port = proxy.port;
        }
        if (eventSourceInitDict && eventSourceInitDict.https) {
          for (var optName in eventSourceInitDict.https) {
            if (httpsOptions.indexOf(optName) === -1) {
              continue;
            }
            var option = eventSourceInitDict.https[optName];
            if (option !== void 0) {
              options[optName] = option;
            }
          }
        }
        if (eventSourceInitDict && eventSourceInitDict.withCredentials !== void 0) {
          options.withCredentials = eventSourceInitDict.withCredentials;
        }
        req = (isSecure ? https : http).request(options, function(res) {
          self.connectionInProgress = false;
          if (res.statusCode === 500 || res.statusCode === 502 || res.statusCode === 503 || res.statusCode === 504) {
            _emit("error", new Event("error", { status: res.statusCode, message: res.statusMessage }));
            onConnectionClosed();
            return;
          }
          if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {
            var location2 = res.headers.location;
            if (!location2) {
              _emit("error", new Event("error", { status: res.statusCode, message: res.statusMessage }));
              return;
            }
            var prevOrigin = new URL(url).origin;
            var nextOrigin = new URL(location2).origin;
            hasNewOrigin = prevOrigin !== nextOrigin;
            if (res.statusCode === 307)
              reconnectUrl = url;
            url = location2;
            process.nextTick(connect);
            return;
          }
          if (res.statusCode !== 200) {
            _emit("error", new Event("error", { status: res.statusCode, message: res.statusMessage }));
            return self.close();
          }
          readyState = EventSource2.OPEN;
          res.on("close", function() {
            res.removeAllListeners("close");
            res.removeAllListeners("end");
            onConnectionClosed();
          });
          res.on("end", function() {
            res.removeAllListeners("close");
            res.removeAllListeners("end");
            onConnectionClosed();
          });
          _emit("open", new Event("open"));
          var buf;
          var newBuffer;
          var startingPos = 0;
          var startingFieldLength = -1;
          var newBufferSize = 0;
          var bytesUsed = 0;
          res.on("data", function(chunk) {
            if (!buf) {
              buf = chunk;
              if (hasBom(buf)) {
                buf = buf.slice(bom.length);
              }
              bytesUsed = buf.length;
            } else {
              if (chunk.length > buf.length - bytesUsed) {
                newBufferSize = buf.length * 2 + chunk.length;
                if (newBufferSize > maxBufferAheadAllocation) {
                  newBufferSize = buf.length + chunk.length + maxBufferAheadAllocation;
                }
                newBuffer = Buffer.alloc(newBufferSize);
                buf.copy(newBuffer, 0, 0, bytesUsed);
                buf = newBuffer;
              }
              chunk.copy(buf, bytesUsed);
              bytesUsed += chunk.length;
            }
            var pos = 0;
            var length4 = bytesUsed;
            while (pos < length4) {
              if (discardTrailingNewline) {
                if (buf[pos] === lineFeed) {
                  ++pos;
                }
                discardTrailingNewline = false;
              }
              var lineLength = -1;
              var fieldLength = startingFieldLength;
              var c;
              for (var i3 = startingPos; lineLength < 0 && i3 < length4; ++i3) {
                c = buf[i3];
                if (c === colon) {
                  if (fieldLength < 0) {
                    fieldLength = i3 - pos;
                  }
                } else if (c === carriageReturn) {
                  discardTrailingNewline = true;
                  lineLength = i3 - pos;
                } else if (c === lineFeed) {
                  lineLength = i3 - pos;
                }
              }
              if (lineLength < 0) {
                startingPos = length4 - pos;
                startingFieldLength = fieldLength;
                break;
              } else {
                startingPos = 0;
                startingFieldLength = -1;
              }
              parseEventStreamLine(buf, pos, fieldLength, lineLength);
              pos += lineLength + 1;
            }
            if (pos === length4) {
              buf = void 0;
              bytesUsed = 0;
            } else if (pos > 0) {
              buf = buf.slice(pos, bytesUsed);
              bytesUsed = buf.length;
            }
          });
        });
        req.on("error", function(err) {
          self.connectionInProgress = false;
          onConnectionClosed(err.message);
        });
        if (req.setNoDelay)
          req.setNoDelay(true);
        req.end();
      }
      connect();
      function _emit() {
        if (self.listeners(arguments[0]).length > 0) {
          self.emit.apply(self, arguments);
        }
      }
      this._close = function() {
        if (readyState === EventSource2.CLOSED)
          return;
        readyState = EventSource2.CLOSED;
        if (req.abort)
          req.abort();
        if (req.xhr && req.xhr.abort)
          req.xhr.abort();
      };
      function parseEventStreamLine(buf, pos, fieldLength, lineLength) {
        if (lineLength === 0) {
          if (data.length > 0) {
            var type = eventName || "message";
            _emit(type, new MessageEvent(type, {
              data: data.slice(0, -1),
              // remove trailing newline
              lastEventId,
              origin: new URL(url).origin
            }));
            data = "";
          }
          eventName = void 0;
        } else if (fieldLength > 0) {
          var noValue = fieldLength < 0;
          var step = 0;
          var field = buf.slice(pos, pos + (noValue ? lineLength : fieldLength)).toString();
          if (noValue) {
            step = lineLength;
          } else if (buf[pos + fieldLength + 1] !== space2) {
            step = fieldLength + 1;
          } else {
            step = fieldLength + 2;
          }
          pos += step;
          var valueLength = lineLength - step;
          var value = buf.slice(pos, pos + valueLength).toString();
          if (field === "data") {
            data += value + "\n";
          } else if (field === "event") {
            eventName = value;
          } else if (field === "id") {
            lastEventId = value;
          } else if (field === "retry") {
            var retry = parseInt(value, 10);
            if (!Number.isNaN(retry)) {
              self.reconnectInterval = retry;
            }
          }
        }
      }
    }
    module2.exports = EventSource2;
    util.inherits(EventSource2, events.EventEmitter);
    EventSource2.prototype.constructor = EventSource2;
    ["open", "error", "message"].forEach(function(method) {
      Object.defineProperty(EventSource2.prototype, "on" + method, {
        /**
         * Returns the current listener
         *
         * @return {Mixed} the set function or undefined
         * @api private
         */
        get: function get2() {
          var listener = this.listeners(method)[0];
          return listener ? listener._listener ? listener._listener : listener : void 0;
        },
        /**
         * Start listening for events
         *
         * @param {Function} listener the listener
         * @return {Mixed} the set function or undefined
         * @api private
         */
        set: function set(listener) {
          this.removeAllListeners(method);
          this.addEventListener(method, listener);
        }
      });
    });
    Object.defineProperty(EventSource2, "CONNECTING", { enumerable: true, value: 0 });
    Object.defineProperty(EventSource2, "OPEN", { enumerable: true, value: 1 });
    Object.defineProperty(EventSource2, "CLOSED", { enumerable: true, value: 2 });
    EventSource2.prototype.CONNECTING = 0;
    EventSource2.prototype.OPEN = 1;
    EventSource2.prototype.CLOSED = 2;
    EventSource2.prototype.close = function() {
      this._close();
    };
    EventSource2.prototype.addEventListener = function addEventListener3(type, listener) {
      if (typeof listener === "function") {
        listener._listener = listener;
        this.on(type, listener);
      }
    };
    EventSource2.prototype.dispatchEvent = function dispatchEvent(event) {
      if (!event.type) {
        throw new Error("UNSPECIFIED_EVENT_TYPE_ERR");
      }
      this.emit(event.type, event.detail);
    };
    EventSource2.prototype.removeEventListener = function removeEventListener2(type, listener) {
      if (typeof listener === "function") {
        listener._listener = void 0;
        this.removeListener(type, listener);
      }
    };
    function Event(type, optionalProperties) {
      Object.defineProperty(this, "type", { writable: false, value: type, enumerable: true });
      if (optionalProperties) {
        for (var f in optionalProperties) {
          if (optionalProperties.hasOwnProperty(f)) {
            Object.defineProperty(this, f, { writable: false, value: optionalProperties[f], enumerable: true });
          }
        }
      }
    }
    function MessageEvent(type, eventInitDict) {
      Object.defineProperty(this, "type", { writable: false, value: type, enumerable: true });
      for (var f in eventInitDict) {
        if (eventInitDict.hasOwnProperty(f)) {
          Object.defineProperty(this, f, { writable: false, value: eventInitDict[f], enumerable: true });
        }
      }
    }
    function removeUnsafeHeaders(headers) {
      var safe = {};
      for (var key in headers) {
        if (reUnsafeHeader.test(key)) {
          continue;
        }
        safe[key] = headers[key];
      }
      return safe;
    }
  }
});

// node_modules/moment/moment.js
var require_moment = __commonJS({
  "node_modules/moment/moment.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.moment = factory();
    })(exports, function() {
      "use strict";
      var hookCallback;
      function hooks() {
        return hookCallback.apply(null, arguments);
      }
      function setHookCallback(callback) {
        hookCallback = callback;
      }
      function isArray3(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
      }
      function isObject2(input) {
        return input != null && Object.prototype.toString.call(input) === "[object Object]";
      }
      function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
      }
      function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
          return Object.getOwnPropertyNames(obj).length === 0;
        } else {
          var k;
          for (k in obj) {
            if (hasOwnProp(obj, k)) {
              return false;
            }
          }
          return true;
        }
      }
      function isUndefined(input) {
        return input === void 0;
      }
      function isNumber(input) {
        return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
      }
      function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
      }
      function map3(arr, fn) {
        var res = [], i2, arrLen = arr.length;
        for (i2 = 0; i2 < arrLen; ++i2) {
          res.push(fn(arr[i2], i2));
        }
        return res;
      }
      function extend(a, b) {
        for (var i2 in b) {
          if (hasOwnProp(b, i2)) {
            a[i2] = b[i2];
          }
        }
        if (hasOwnProp(b, "toString")) {
          a.toString = b.toString;
        }
        if (hasOwnProp(b, "valueOf")) {
          a.valueOf = b.valueOf;
        }
        return a;
      }
      function createUTC(input, format2, locale2, strict) {
        return createLocalOrUTC(input, format2, locale2, strict, true).utc();
      }
      function defaultParsingFlags() {
        return {
          empty: false,
          unusedTokens: [],
          unusedInput: [],
          overflow: -2,
          charsLeftOver: 0,
          nullInput: false,
          invalidEra: null,
          invalidMonth: null,
          invalidFormat: false,
          userInvalidated: false,
          iso: false,
          parsedDateParts: [],
          era: null,
          meridiem: null,
          rfc2822: false,
          weekdayMismatch: false
        };
      }
      function getParsingFlags(m) {
        if (m._pf == null) {
          m._pf = defaultParsingFlags();
        }
        return m._pf;
      }
      var some2;
      if (Array.prototype.some) {
        some2 = Array.prototype.some;
      } else {
        some2 = function(fun) {
          var t2 = Object(this), len = t2.length >>> 0, i2;
          for (i2 = 0; i2 < len; i2++) {
            if (i2 in t2 && fun.call(this, t2[i2], i2, t2)) {
              return true;
            }
          }
          return false;
        };
      }
      function isValid(m) {
        if (m._isValid == null) {
          var flags2 = getParsingFlags(m), parsedParts = some2.call(flags2.parsedDateParts, function(i2) {
            return i2 != null;
          }), isNowValid = !isNaN(m._d.getTime()) && flags2.overflow < 0 && !flags2.empty && !flags2.invalidEra && !flags2.invalidMonth && !flags2.invalidWeekday && !flags2.weekdayMismatch && !flags2.nullInput && !flags2.invalidFormat && !flags2.userInvalidated && (!flags2.meridiem || flags2.meridiem && parsedParts);
          if (m._strict) {
            isNowValid = isNowValid && flags2.charsLeftOver === 0 && flags2.unusedTokens.length === 0 && flags2.bigHour === void 0;
          }
          if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
          } else {
            return isNowValid;
          }
        }
        return m._isValid;
      }
      function createInvalid(flags2) {
        var m = createUTC(NaN);
        if (flags2 != null) {
          extend(getParsingFlags(m), flags2);
        } else {
          getParsingFlags(m).userInvalidated = true;
        }
        return m;
      }
      var momentProperties = hooks.momentProperties = [], updateInProgress = false;
      function copyConfig(to2, from4) {
        var i2, prop, val, momentPropertiesLen = momentProperties.length;
        if (!isUndefined(from4._isAMomentObject)) {
          to2._isAMomentObject = from4._isAMomentObject;
        }
        if (!isUndefined(from4._i)) {
          to2._i = from4._i;
        }
        if (!isUndefined(from4._f)) {
          to2._f = from4._f;
        }
        if (!isUndefined(from4._l)) {
          to2._l = from4._l;
        }
        if (!isUndefined(from4._strict)) {
          to2._strict = from4._strict;
        }
        if (!isUndefined(from4._tzm)) {
          to2._tzm = from4._tzm;
        }
        if (!isUndefined(from4._isUTC)) {
          to2._isUTC = from4._isUTC;
        }
        if (!isUndefined(from4._offset)) {
          to2._offset = from4._offset;
        }
        if (!isUndefined(from4._pf)) {
          to2._pf = getParsingFlags(from4);
        }
        if (!isUndefined(from4._locale)) {
          to2._locale = from4._locale;
        }
        if (momentPropertiesLen > 0) {
          for (i2 = 0; i2 < momentPropertiesLen; i2++) {
            prop = momentProperties[i2];
            val = from4[prop];
            if (!isUndefined(val)) {
              to2[prop] = val;
            }
          }
        }
        return to2;
      }
      function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
          this._d = new Date(NaN);
        }
        if (updateInProgress === false) {
          updateInProgress = true;
          hooks.updateOffset(this);
          updateInProgress = false;
        }
      }
      function isMoment(obj) {
        return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
      }
      function warn2(msg) {
        if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
          console.warn("Deprecation warning: " + msg);
        }
      }
      function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function() {
          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
          }
          if (firstTime) {
            var args3 = [], arg, i2, key, argLen = arguments.length;
            for (i2 = 0; i2 < argLen; i2++) {
              arg = "";
              if (typeof arguments[i2] === "object") {
                arg += "\n[" + i2 + "] ";
                for (key in arguments[0]) {
                  if (hasOwnProp(arguments[0], key)) {
                    arg += key + ": " + arguments[0][key] + ", ";
                  }
                }
                arg = arg.slice(0, -2);
              } else {
                arg = arguments[i2];
              }
              args3.push(arg);
            }
            warn2(
              msg + "\nArguments: " + Array.prototype.slice.call(args3).join("") + "\n" + new Error().stack
            );
            firstTime = false;
          }
          return fn.apply(this, arguments);
        }, fn);
      }
      var deprecations = {};
      function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
          warn2(msg);
          deprecations[name] = true;
        }
      }
      hooks.suppressDeprecationWarnings = false;
      hooks.deprecationHandler = null;
      function isFunction(input) {
        return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
      }
      function set(config) {
        var prop, i2;
        for (i2 in config) {
          if (hasOwnProp(config, i2)) {
            prop = config[i2];
            if (isFunction(prop)) {
              this[i2] = prop;
            } else {
              this["_" + i2] = prop;
            }
          }
        }
        this._config = config;
        this._dayOfMonthOrdinalParseLenient = new RegExp(
          (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
        );
      }
      function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
          if (hasOwnProp(childConfig, prop)) {
            if (isObject2(parentConfig[prop]) && isObject2(childConfig[prop])) {
              res[prop] = {};
              extend(res[prop], parentConfig[prop]);
              extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
              res[prop] = childConfig[prop];
            } else {
              delete res[prop];
            }
          }
        }
        for (prop in parentConfig) {
          if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject2(parentConfig[prop])) {
            res[prop] = extend({}, res[prop]);
          }
        }
        return res;
      }
      function Locale(config) {
        if (config != null) {
          this.set(config);
        }
      }
      var keys2;
      if (Object.keys) {
        keys2 = Object.keys;
      } else {
        keys2 = function(obj) {
          var i2, res = [];
          for (i2 in obj) {
            if (hasOwnProp(obj, i2)) {
              res.push(i2);
            }
          }
          return res;
        };
      }
      var defaultCalendar = {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
      };
      function calendar(key, mom, now3) {
        var output = this._calendar[key] || this._calendar["sameElse"];
        return isFunction(output) ? output.call(mom, now3) : output;
      }
      function zeroFill(number, targetLength, forceSign) {
        var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
        return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
      }
      var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
      function addFormatToken(token2, padded, ordinal2, callback) {
        var func = callback;
        if (typeof callback === "string") {
          func = function() {
            return this[callback]();
          };
        }
        if (token2) {
          formatTokenFunctions[token2] = func;
        }
        if (padded) {
          formatTokenFunctions[padded[0]] = function() {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
          };
        }
        if (ordinal2) {
          formatTokenFunctions[ordinal2] = function() {
            return this.localeData().ordinal(
              func.apply(this, arguments),
              token2
            );
          };
        }
      }
      function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
          return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
      }
      function makeFormatFunction(format2) {
        var array = format2.match(formattingTokens), i2, length4;
        for (i2 = 0, length4 = array.length; i2 < length4; i2++) {
          if (formatTokenFunctions[array[i2]]) {
            array[i2] = formatTokenFunctions[array[i2]];
          } else {
            array[i2] = removeFormattingTokens(array[i2]);
          }
        }
        return function(mom) {
          var output = "", i3;
          for (i3 = 0; i3 < length4; i3++) {
            output += isFunction(array[i3]) ? array[i3].call(mom, format2) : array[i3];
          }
          return output;
        };
      }
      function formatMoment(m, format2) {
        if (!m.isValid()) {
          return m.localeData().invalidDate();
        }
        format2 = expandFormat(format2, m.localeData());
        formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
        return formatFunctions[format2](m);
      }
      function expandFormat(format2, locale2) {
        var i2 = 5;
        function replaceLongDateFormatTokens(input) {
          return locale2.longDateFormat(input) || input;
        }
        localFormattingTokens.lastIndex = 0;
        while (i2 >= 0 && localFormattingTokens.test(format2)) {
          format2 = format2.replace(
            localFormattingTokens,
            replaceLongDateFormatTokens
          );
          localFormattingTokens.lastIndex = 0;
          i2 -= 1;
        }
        return format2;
      }
      var defaultLongDateFormat = {
        LTS: "h:mm:ss A",
        LT: "h:mm A",
        L: "MM/DD/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY h:mm A",
        LLLL: "dddd, MMMM D, YYYY h:mm A"
      };
      function longDateFormat(key) {
        var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
        if (format2 || !formatUpper) {
          return format2;
        }
        this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
          if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
            return tok.slice(1);
          }
          return tok;
        }).join("");
        return this._longDateFormat[key];
      }
      var defaultInvalidDate = "Invalid date";
      function invalidDate() {
        return this._invalidDate;
      }
      var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
      function ordinal(number) {
        return this._ordinal.replace("%d", number);
      }
      var defaultRelativeTime = {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        ss: "%d seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        w: "a week",
        ww: "%d weeks",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
      };
      function relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
      }
      function pastFuture(diff3, output) {
        var format2 = this._relativeTime[diff3 > 0 ? "future" : "past"];
        return isFunction(format2) ? format2(output) : format2.replace(/%s/i, output);
      }
      var aliases = {};
      function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
      }
      function normalizeUnits(units) {
        return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
      }
      function normalizeObjectUnits(inputObject) {
        var normalizedInput = {}, normalizedProp, prop;
        for (prop in inputObject) {
          if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
              normalizedInput[normalizedProp] = inputObject[prop];
            }
          }
        }
        return normalizedInput;
      }
      var priorities = {};
      function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
      }
      function getPrioritizedUnits(unitsObj) {
        var units = [], u;
        for (u in unitsObj) {
          if (hasOwnProp(unitsObj, u)) {
            units.push({ unit: u, priority: priorities[u] });
          }
        }
        units.sort(function(a, b) {
          return a.priority - b.priority;
        });
        return units;
      }
      function isLeapYear(year2) {
        return year2 % 4 === 0 && year2 % 100 !== 0 || year2 % 400 === 0;
      }
      function absFloor(number) {
        if (number < 0) {
          return Math.ceil(number) || 0;
        } else {
          return Math.floor(number);
        }
      }
      function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
          value = absFloor(coercedNumber);
        }
        return value;
      }
      function makeGetSet(unit, keepTime) {
        return function(value) {
          if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
          } else {
            return get2(this, unit);
          }
        };
      }
      function get2(mom, unit) {
        return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
      }
      function set$1(mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
          if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
            value = toInt(value);
            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](
              value,
              mom.month(),
              daysInMonth(value, mom.month())
            );
          } else {
            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
          }
        }
      }
      function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
          return this[units]();
        }
        return this;
      }
      function stringSet(units, value) {
        if (typeof units === "object") {
          units = normalizeObjectUnits(units);
          var prioritized = getPrioritizedUnits(units), i2, prioritizedLen = prioritized.length;
          for (i2 = 0; i2 < prioritizedLen; i2++) {
            this[prioritized[i2].unit](units[prioritized[i2].unit]);
          }
        } else {
          units = normalizeUnits(units);
          if (isFunction(this[units])) {
            return this[units](value);
          }
        }
        return this;
      }
      var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
      regexes = {};
      function addRegexToken(token2, regex, strictRegex) {
        regexes[token2] = isFunction(regex) ? regex : function(isStrict, localeData2) {
          return isStrict && strictRegex ? strictRegex : regex;
        };
      }
      function getParseRegexForToken(token2, config) {
        if (!hasOwnProp(regexes, token2)) {
          return new RegExp(unescapeFormat(token2));
        }
        return regexes[token2](config._strict, config._locale);
      }
      function unescapeFormat(s2) {
        return regexEscape(
          s2.replace("\\", "").replace(
            /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
            function(matched, p1, p2, p3, p4) {
              return p1 || p2 || p3 || p4;
            }
          )
        );
      }
      function regexEscape(s2) {
        return s2.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
      }
      var tokens = {};
      function addParseToken(token2, callback) {
        var i2, func = callback, tokenLen;
        if (typeof token2 === "string") {
          token2 = [token2];
        }
        if (isNumber(callback)) {
          func = function(input, array) {
            array[callback] = toInt(input);
          };
        }
        tokenLen = token2.length;
        for (i2 = 0; i2 < tokenLen; i2++) {
          tokens[token2[i2]] = func;
        }
      }
      function addWeekParseToken(token2, callback) {
        addParseToken(token2, function(input, array, config, token3) {
          config._w = config._w || {};
          callback(input, config._w, config, token3);
        });
      }
      function addTimeToArrayFromToken(token2, input, config) {
        if (input != null && hasOwnProp(tokens, token2)) {
          tokens[token2](input, config._a, config, token2);
        }
      }
      var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
      function mod(n, x) {
        return (n % x + x) % x;
      }
      var indexOf;
      if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
      } else {
        indexOf = function(o) {
          var i2;
          for (i2 = 0; i2 < this.length; ++i2) {
            if (this[i2] === o) {
              return i2;
            }
          }
          return -1;
        };
      }
      function daysInMonth(year2, month) {
        if (isNaN(year2) || isNaN(month)) {
          return NaN;
        }
        var modMonth = mod(month, 12);
        year2 += (month - modMonth) / 12;
        return modMonth === 1 ? isLeapYear(year2) ? 29 : 28 : 31 - modMonth % 7 % 2;
      }
      addFormatToken("M", ["MM", 2], "Mo", function() {
        return this.month() + 1;
      });
      addFormatToken("MMM", 0, 0, function(format2) {
        return this.localeData().monthsShort(this, format2);
      });
      addFormatToken("MMMM", 0, 0, function(format2) {
        return this.localeData().months(this, format2);
      });
      addUnitAlias("month", "M");
      addUnitPriority("month", 8);
      addRegexToken("M", match1to2);
      addRegexToken("MM", match1to2, match2);
      addRegexToken("MMM", function(isStrict, locale2) {
        return locale2.monthsShortRegex(isStrict);
      });
      addRegexToken("MMMM", function(isStrict, locale2) {
        return locale2.monthsRegex(isStrict);
      });
      addParseToken(["M", "MM"], function(input, array) {
        array[MONTH] = toInt(input) - 1;
      });
      addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
        var month = config._locale.monthsParse(input, token2, config._strict);
        if (month != null) {
          array[MONTH] = month;
        } else {
          getParsingFlags(config).invalidMonth = input;
        }
      });
      var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
        "_"
      ), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
      function localeMonths(m, format2) {
        if (!m) {
          return isArray3(this._months) ? this._months : this._months["standalone"];
        }
        return isArray3(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m.month()];
      }
      function localeMonthsShort(m, format2) {
        if (!m) {
          return isArray3(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
        }
        return isArray3(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m.month()];
      }
      function handleStrictParse(monthName, format2, strict) {
        var i2, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
          for (i2 = 0; i2 < 12; ++i2) {
            mom = createUTC([2e3, i2]);
            this._shortMonthsParse[i2] = this.monthsShort(
              mom,
              ""
            ).toLocaleLowerCase();
            this._longMonthsParse[i2] = this.months(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format2 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format2 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeMonthsParse(monthName, format2, strict) {
        var i2, mom, regex;
        if (this._monthsParseExact) {
          return handleStrictParse.call(this, monthName, format2, strict);
        }
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
        }
        for (i2 = 0; i2 < 12; i2++) {
          mom = createUTC([2e3, i2]);
          if (strict && !this._longMonthsParse[i2]) {
            this._longMonthsParse[i2] = new RegExp(
              "^" + this.months(mom, "").replace(".", "") + "$",
              "i"
            );
            this._shortMonthsParse[i2] = new RegExp(
              "^" + this.monthsShort(mom, "").replace(".", "") + "$",
              "i"
            );
          }
          if (!strict && !this._monthsParse[i2]) {
            regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
            this._monthsParse[i2] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format2 === "MMMM" && this._longMonthsParse[i2].test(monthName)) {
            return i2;
          } else if (strict && format2 === "MMM" && this._shortMonthsParse[i2].test(monthName)) {
            return i2;
          } else if (!strict && this._monthsParse[i2].test(monthName)) {
            return i2;
          }
        }
      }
      function setMonth(mom, value) {
        var dayOfMonth;
        if (!mom.isValid()) {
          return mom;
        }
        if (typeof value === "string") {
          if (/^\d+$/.test(value)) {
            value = toInt(value);
          } else {
            value = mom.localeData().monthsParse(value);
            if (!isNumber(value)) {
              return mom;
            }
          }
        }
        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
        return mom;
      }
      function getSetMonth(value) {
        if (value != null) {
          setMonth(this, value);
          hooks.updateOffset(this, true);
          return this;
        } else {
          return get2(this, "Month");
        }
      }
      function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
      }
      function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsShortStrictRegex;
          } else {
            return this._monthsShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsShortRegex")) {
            this._monthsShortRegex = defaultMonthsShortRegex;
          }
          return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
        }
      }
      function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsStrictRegex;
          } else {
            return this._monthsRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsRegex")) {
            this._monthsRegex = defaultMonthsRegex;
          }
          return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
        }
      }
      function computeMonthsParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        var shortPieces = [], longPieces = [], mixedPieces = [], i2, mom;
        for (i2 = 0; i2 < 12; i2++) {
          mom = createUTC([2e3, i2]);
          shortPieces.push(this.monthsShort(mom, ""));
          longPieces.push(this.months(mom, ""));
          mixedPieces.push(this.months(mom, ""));
          mixedPieces.push(this.monthsShort(mom, ""));
        }
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i2 = 0; i2 < 12; i2++) {
          shortPieces[i2] = regexEscape(shortPieces[i2]);
          longPieces[i2] = regexEscape(longPieces[i2]);
        }
        for (i2 = 0; i2 < 24; i2++) {
          mixedPieces[i2] = regexEscape(mixedPieces[i2]);
        }
        this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp(
          "^(" + longPieces.join("|") + ")",
          "i"
        );
        this._monthsShortStrictRegex = new RegExp(
          "^(" + shortPieces.join("|") + ")",
          "i"
        );
      }
      addFormatToken("Y", 0, 0, function() {
        var y = this.year();
        return y <= 9999 ? zeroFill(y, 4) : "+" + y;
      });
      addFormatToken(0, ["YY", 2], 0, function() {
        return this.year() % 100;
      });
      addFormatToken(0, ["YYYY", 4], 0, "year");
      addFormatToken(0, ["YYYYY", 5], 0, "year");
      addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
      addUnitAlias("year", "y");
      addUnitPriority("year", 1);
      addRegexToken("Y", matchSigned);
      addRegexToken("YY", match1to2, match2);
      addRegexToken("YYYY", match1to4, match4);
      addRegexToken("YYYYY", match1to6, match6);
      addRegexToken("YYYYYY", match1to6, match6);
      addParseToken(["YYYYY", "YYYYYY"], YEAR);
      addParseToken("YYYY", function(input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
      });
      addParseToken("YY", function(input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
      });
      addParseToken("Y", function(input, array) {
        array[YEAR] = parseInt(input, 10);
      });
      function daysInYear(year2) {
        return isLeapYear(year2) ? 366 : 365;
      }
      hooks.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
      };
      var getSetYear = makeGetSet("FullYear", true);
      function getIsLeapYear() {
        return isLeapYear(this.year());
      }
      function createDate(y, m, d, h, M, s2, ms) {
        var date;
        if (y < 100 && y >= 0) {
          date = new Date(y + 400, m, d, h, M, s2, ms);
          if (isFinite(date.getFullYear())) {
            date.setFullYear(y);
          }
        } else {
          date = new Date(y, m, d, h, M, s2, ms);
        }
        return date;
      }
      function createUTCDate(y) {
        var date, args3;
        if (y < 100 && y >= 0) {
          args3 = Array.prototype.slice.call(arguments);
          args3[0] = y + 400;
          date = new Date(Date.UTC.apply(null, args3));
          if (isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
          }
        } else {
          date = new Date(Date.UTC.apply(null, arguments));
        }
        return date;
      }
      function firstWeekOffset(year2, dow, doy) {
        var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year2, 0, fwd).getUTCDay() - dow) % 7;
        return -fwdlw + fwd - 1;
      }
      function dayOfYearFromWeeks(year2, week2, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year2, dow, doy), dayOfYear = 1 + 7 * (week2 - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
        if (dayOfYear <= 0) {
          resYear = year2 - 1;
          resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year2)) {
          resYear = year2 + 1;
          resDayOfYear = dayOfYear - daysInYear(year2);
        } else {
          resYear = year2;
          resDayOfYear = dayOfYear;
        }
        return {
          year: resYear,
          dayOfYear: resDayOfYear
        };
      }
      function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy), week2 = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
        if (week2 < 1) {
          resYear = mom.year() - 1;
          resWeek = week2 + weeksInYear(resYear, dow, doy);
        } else if (week2 > weeksInYear(mom.year(), dow, doy)) {
          resWeek = week2 - weeksInYear(mom.year(), dow, doy);
          resYear = mom.year() + 1;
        } else {
          resYear = mom.year();
          resWeek = week2;
        }
        return {
          week: resWeek,
          year: resYear
        };
      }
      function weeksInYear(year2, dow, doy) {
        var weekOffset = firstWeekOffset(year2, dow, doy), weekOffsetNext = firstWeekOffset(year2 + 1, dow, doy);
        return (daysInYear(year2) - weekOffset + weekOffsetNext) / 7;
      }
      addFormatToken("w", ["ww", 2], "wo", "week");
      addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
      addUnitAlias("week", "w");
      addUnitAlias("isoWeek", "W");
      addUnitPriority("week", 5);
      addUnitPriority("isoWeek", 5);
      addRegexToken("w", match1to2);
      addRegexToken("ww", match1to2, match2);
      addRegexToken("W", match1to2);
      addRegexToken("WW", match1to2, match2);
      addWeekParseToken(
        ["w", "ww", "W", "WW"],
        function(input, week2, config, token2) {
          week2[token2.substr(0, 1)] = toInt(input);
        }
      );
      function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
      }
      var defaultLocaleWeek = {
        dow: 0,
        // Sunday is the first day of the week.
        doy: 6
        // The week that contains Jan 6th is the first week of the year.
      };
      function localeFirstDayOfWeek() {
        return this._week.dow;
      }
      function localeFirstDayOfYear() {
        return this._week.doy;
      }
      function getSetWeek(input) {
        var week2 = this.localeData().week(this);
        return input == null ? week2 : this.add((input - week2) * 7, "d");
      }
      function getSetISOWeek(input) {
        var week2 = weekOfYear(this, 1, 4).week;
        return input == null ? week2 : this.add((input - week2) * 7, "d");
      }
      addFormatToken("d", 0, "do", "day");
      addFormatToken("dd", 0, 0, function(format2) {
        return this.localeData().weekdaysMin(this, format2);
      });
      addFormatToken("ddd", 0, 0, function(format2) {
        return this.localeData().weekdaysShort(this, format2);
      });
      addFormatToken("dddd", 0, 0, function(format2) {
        return this.localeData().weekdays(this, format2);
      });
      addFormatToken("e", 0, 0, "weekday");
      addFormatToken("E", 0, 0, "isoWeekday");
      addUnitAlias("day", "d");
      addUnitAlias("weekday", "e");
      addUnitAlias("isoWeekday", "E");
      addUnitPriority("day", 11);
      addUnitPriority("weekday", 11);
      addUnitPriority("isoWeekday", 11);
      addRegexToken("d", match1to2);
      addRegexToken("e", match1to2);
      addRegexToken("E", match1to2);
      addRegexToken("dd", function(isStrict, locale2) {
        return locale2.weekdaysMinRegex(isStrict);
      });
      addRegexToken("ddd", function(isStrict, locale2) {
        return locale2.weekdaysShortRegex(isStrict);
      });
      addRegexToken("dddd", function(isStrict, locale2) {
        return locale2.weekdaysRegex(isStrict);
      });
      addWeekParseToken(["dd", "ddd", "dddd"], function(input, week2, config, token2) {
        var weekday = config._locale.weekdaysParse(input, token2, config._strict);
        if (weekday != null) {
          week2.d = weekday;
        } else {
          getParsingFlags(config).invalidWeekday = input;
        }
      });
      addWeekParseToken(["d", "e", "E"], function(input, week2, config, token2) {
        week2[token2] = toInt(input);
      });
      function parseWeekday(input, locale2) {
        if (typeof input !== "string") {
          return input;
        }
        if (!isNaN(input)) {
          return parseInt(input, 10);
        }
        input = locale2.weekdaysParse(input);
        if (typeof input === "number") {
          return input;
        }
        return null;
      }
      function parseIsoWeekday(input, locale2) {
        if (typeof input === "string") {
          return locale2.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
      }
      function shiftWeekdays(ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
      }
      var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
      function localeWeekdays(m, format2) {
        var weekdays = isArray3(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
        return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
      }
      function localeWeekdaysShort(m) {
        return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
      }
      function localeWeekdaysMin(m) {
        return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
      }
      function handleStrictParse$1(weekdayName, format2, strict) {
        var i2, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._minWeekdaysParse = [];
          for (i2 = 0; i2 < 7; ++i2) {
            mom = createUTC([2e3, 1]).day(i2);
            this._minWeekdaysParse[i2] = this.weekdaysMin(
              mom,
              ""
            ).toLocaleLowerCase();
            this._shortWeekdaysParse[i2] = this.weekdaysShort(
              mom,
              ""
            ).toLocaleLowerCase();
            this._weekdaysParse[i2] = this.weekdays(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format2 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format2 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format2 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format2 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeWeekdaysParse(weekdayName, format2, strict) {
        var i2, mom, regex;
        if (this._weekdaysParseExact) {
          return handleStrictParse$1.call(this, weekdayName, format2, strict);
        }
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._minWeekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._fullWeekdaysParse = [];
        }
        for (i2 = 0; i2 < 7; i2++) {
          mom = createUTC([2e3, 1]).day(i2);
          if (strict && !this._fullWeekdaysParse[i2]) {
            this._fullWeekdaysParse[i2] = new RegExp(
              "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
            this._shortWeekdaysParse[i2] = new RegExp(
              "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
            this._minWeekdaysParse[i2] = new RegExp(
              "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
          }
          if (!this._weekdaysParse[i2]) {
            regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
            this._weekdaysParse[i2] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format2 === "dddd" && this._fullWeekdaysParse[i2].test(weekdayName)) {
            return i2;
          } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i2].test(weekdayName)) {
            return i2;
          } else if (strict && format2 === "dd" && this._minWeekdaysParse[i2].test(weekdayName)) {
            return i2;
          } else if (!strict && this._weekdaysParse[i2].test(weekdayName)) {
            return i2;
          }
        }
      }
      function getSetDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var day2 = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
          input = parseWeekday(input, this.localeData());
          return this.add(input - day2, "d");
        } else {
          return day2;
        }
      }
      function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, "d");
      }
      function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          var weekday = parseIsoWeekday(input, this.localeData());
          return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
          return this.day() || 7;
        }
      }
      function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysStrictRegex;
          } else {
            return this._weekdaysRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            this._weekdaysRegex = defaultWeekdaysRegex;
          }
          return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
        }
      }
      function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysShortStrictRegex;
          } else {
            return this._weekdaysShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysShortRegex")) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
          }
          return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
      }
      function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysMinStrictRegex;
          } else {
            return this._weekdaysMinRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysMinRegex")) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
          }
          return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
      }
      function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i2, mom, minp, shortp, longp;
        for (i2 = 0; i2 < 7; i2++) {
          mom = createUTC([2e3, 1]).day(i2);
          minp = regexEscape(this.weekdaysMin(mom, ""));
          shortp = regexEscape(this.weekdaysShort(mom, ""));
          longp = regexEscape(this.weekdays(mom, ""));
          minPieces.push(minp);
          shortPieces.push(shortp);
          longPieces.push(longp);
          mixedPieces.push(minp);
          mixedPieces.push(shortp);
          mixedPieces.push(longp);
        }
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;
        this._weekdaysStrictRegex = new RegExp(
          "^(" + longPieces.join("|") + ")",
          "i"
        );
        this._weekdaysShortStrictRegex = new RegExp(
          "^(" + shortPieces.join("|") + ")",
          "i"
        );
        this._weekdaysMinStrictRegex = new RegExp(
          "^(" + minPieces.join("|") + ")",
          "i"
        );
      }
      function hFormat() {
        return this.hours() % 12 || 12;
      }
      function kFormat() {
        return this.hours() || 24;
      }
      addFormatToken("H", ["HH", 2], 0, "hour");
      addFormatToken("h", ["hh", 2], 0, hFormat);
      addFormatToken("k", ["kk", 2], 0, kFormat);
      addFormatToken("hmm", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
      });
      addFormatToken("hmmss", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      addFormatToken("Hmm", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2);
      });
      addFormatToken("Hmmss", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      function meridiem(token2, lowercase) {
        addFormatToken(token2, 0, 0, function() {
          return this.localeData().meridiem(
            this.hours(),
            this.minutes(),
            lowercase
          );
        });
      }
      meridiem("a", true);
      meridiem("A", false);
      addUnitAlias("hour", "h");
      addUnitPriority("hour", 13);
      function matchMeridiem(isStrict, locale2) {
        return locale2._meridiemParse;
      }
      addRegexToken("a", matchMeridiem);
      addRegexToken("A", matchMeridiem);
      addRegexToken("H", match1to2);
      addRegexToken("h", match1to2);
      addRegexToken("k", match1to2);
      addRegexToken("HH", match1to2, match2);
      addRegexToken("hh", match1to2, match2);
      addRegexToken("kk", match1to2, match2);
      addRegexToken("hmm", match3to4);
      addRegexToken("hmmss", match5to6);
      addRegexToken("Hmm", match3to4);
      addRegexToken("Hmmss", match5to6);
      addParseToken(["H", "HH"], HOUR);
      addParseToken(["k", "kk"], function(input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
      });
      addParseToken(["a", "A"], function(input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
      });
      addParseToken(["h", "hh"], function(input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("Hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
      });
      addParseToken("Hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
      });
      function localeIsPM(input) {
        return (input + "").toLowerCase().charAt(0) === "p";
      }
      var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
      function localeMeridiem(hours2, minutes2, isLower) {
        if (hours2 > 11) {
          return isLower ? "pm" : "PM";
        } else {
          return isLower ? "am" : "AM";
        }
      }
      var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,
        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,
        week: defaultLocaleWeek,
        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,
        meridiemParse: defaultLocaleMeridiemParse
      };
      var locales = {}, localeFamilies = {}, globalLocale;
      function commonPrefix(arr1, arr2) {
        var i2, minl = Math.min(arr1.length, arr2.length);
        for (i2 = 0; i2 < minl; i2 += 1) {
          if (arr1[i2] !== arr2[i2]) {
            return i2;
          }
        }
        return minl;
      }
      function normalizeLocale(key) {
        return key ? key.toLowerCase().replace("_", "-") : key;
      }
      function chooseLocale(names) {
        var i2 = 0, j, next, locale2, split;
        while (i2 < names.length) {
          split = normalizeLocale(names[i2]).split("-");
          j = split.length;
          next = normalizeLocale(names[i2 + 1]);
          next = next ? next.split("-") : null;
          while (j > 0) {
            locale2 = loadLocale(split.slice(0, j).join("-"));
            if (locale2) {
              return locale2;
            }
            if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
              break;
            }
            j--;
          }
          i2++;
        }
        return globalLocale;
      }
      function isLocaleNameSane(name) {
        return name.match("^[^/\\\\]*$") != null;
      }
      function loadLocale(name) {
        var oldLocale = null, aliasedRequire;
        if (locales[name] === void 0 && typeof module2 !== "undefined" && module2 && module2.exports && isLocaleNameSane(name)) {
          try {
            oldLocale = globalLocale._abbr;
            aliasedRequire = require;
            aliasedRequire("./locale/" + name);
            getSetGlobalLocale(oldLocale);
          } catch (e2) {
            locales[name] = null;
          }
        }
        return locales[name];
      }
      function getSetGlobalLocale(key, values) {
        var data;
        if (key) {
          if (isUndefined(values)) {
            data = getLocale(key);
          } else {
            data = defineLocale(key, values);
          }
          if (data) {
            globalLocale = data;
          } else {
            if (typeof console !== "undefined" && console.warn) {
              console.warn(
                "Locale " + key + " not found. Did you forget to load it?"
              );
            }
          }
        }
        return globalLocale._abbr;
      }
      function defineLocale(name, config) {
        if (config !== null) {
          var locale2, parentConfig = baseConfig;
          config.abbr = name;
          if (locales[name] != null) {
            deprecateSimple(
              "defineLocaleOverride",
              "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
            );
            parentConfig = locales[name]._config;
          } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
              parentConfig = locales[config.parentLocale]._config;
            } else {
              locale2 = loadLocale(config.parentLocale);
              if (locale2 != null) {
                parentConfig = locale2._config;
              } else {
                if (!localeFamilies[config.parentLocale]) {
                  localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                  name,
                  config
                });
                return null;
              }
            }
          }
          locales[name] = new Locale(mergeConfigs(parentConfig, config));
          if (localeFamilies[name]) {
            localeFamilies[name].forEach(function(x) {
              defineLocale(x.name, x.config);
            });
          }
          getSetGlobalLocale(name);
          return locales[name];
        } else {
          delete locales[name];
          return null;
        }
      }
      function updateLocale(name, config) {
        if (config != null) {
          var locale2, tmpLocale, parentConfig = baseConfig;
          if (locales[name] != null && locales[name].parentLocale != null) {
            locales[name].set(mergeConfigs(locales[name]._config, config));
          } else {
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
              parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            if (tmpLocale == null) {
              config.abbr = name;
            }
            locale2 = new Locale(config);
            locale2.parentLocale = locales[name];
            locales[name] = locale2;
          }
          getSetGlobalLocale(name);
        } else {
          if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
              locales[name] = locales[name].parentLocale;
              if (name === getSetGlobalLocale()) {
                getSetGlobalLocale(name);
              }
            } else if (locales[name] != null) {
              delete locales[name];
            }
          }
        }
        return locales[name];
      }
      function getLocale(key) {
        var locale2;
        if (key && key._locale && key._locale._abbr) {
          key = key._locale._abbr;
        }
        if (!key) {
          return globalLocale;
        }
        if (!isArray3(key)) {
          locale2 = loadLocale(key);
          if (locale2) {
            return locale2;
          }
          key = [key];
        }
        return chooseLocale(key);
      }
      function listLocales() {
        return keys2(locales);
      }
      function checkOverflow(m) {
        var overflow, a = m._a;
        if (a && getParsingFlags(m).overflow === -2) {
          overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
          if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
          }
          if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
          }
          if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
          }
          getParsingFlags(m).overflow = overflow;
        }
        return m;
      }
      var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
        ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
        ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
        ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
        ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
        ["YYYY-DDD", /\d{4}-\d{3}/],
        ["YYYY-MM", /\d{4}-\d\d/, false],
        ["YYYYYYMMDD", /[+-]\d{10}/],
        ["YYYYMMDD", /\d{8}/],
        ["GGGG[W]WWE", /\d{4}W\d{3}/],
        ["GGGG[W]WW", /\d{4}W\d{2}/, false],
        ["YYYYDDD", /\d{7}/],
        ["YYYYMM", /\d{6}/, false],
        ["YYYY", /\d{4}/, false]
      ], isoTimes = [
        ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
        ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
        ["HH:mm:ss", /\d\d:\d\d:\d\d/],
        ["HH:mm", /\d\d:\d\d/],
        ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
        ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
        ["HHmmss", /\d\d\d\d\d\d/],
        ["HHmm", /\d\d\d\d/],
        ["HH", /\d\d/]
      ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
      };
      function configFromISO(config) {
        var i2, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
        if (match) {
          getParsingFlags(config).iso = true;
          for (i2 = 0, l = isoDatesLen; i2 < l; i2++) {
            if (isoDates[i2][1].exec(match[1])) {
              dateFormat = isoDates[i2][0];
              allowTime = isoDates[i2][2] !== false;
              break;
            }
          }
          if (dateFormat == null) {
            config._isValid = false;
            return;
          }
          if (match[3]) {
            for (i2 = 0, l = isoTimesLen; i2 < l; i2++) {
              if (isoTimes[i2][1].exec(match[3])) {
                timeFormat = (match[2] || " ") + isoTimes[i2][0];
                break;
              }
            }
            if (timeFormat == null) {
              config._isValid = false;
              return;
            }
          }
          if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
          }
          if (match[4]) {
            if (tzRegex.exec(match[4])) {
              tzFormat = "Z";
            } else {
              config._isValid = false;
              return;
            }
          }
          config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
          configFromStringAndFormat(config);
        } else {
          config._isValid = false;
        }
      }
      function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
          untruncateYear(yearStr),
          defaultLocaleMonthsShort.indexOf(monthStr),
          parseInt(dayStr, 10),
          parseInt(hourStr, 10),
          parseInt(minuteStr, 10)
        ];
        if (secondStr) {
          result.push(parseInt(secondStr, 10));
        }
        return result;
      }
      function untruncateYear(yearStr) {
        var year2 = parseInt(yearStr, 10);
        if (year2 <= 49) {
          return 2e3 + year2;
        } else if (year2 <= 999) {
          return 1900 + year2;
        }
        return year2;
      }
      function preprocessRFC2822(s2) {
        return s2.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
      }
      function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
          var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
            parsedInput[0],
            parsedInput[1],
            parsedInput[2]
          ).getDay();
          if (weekdayProvided !== weekdayActual) {
            getParsingFlags(config).weekdayMismatch = true;
            config._isValid = false;
            return false;
          }
        }
        return true;
      }
      function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
          return obsOffsets[obsOffset];
        } else if (militaryOffset) {
          return 0;
        } else {
          var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;
          return h * 60 + m;
        }
      }
      function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
        if (match) {
          parsedArray = extractFromRFC2822Strings(
            match[4],
            match[3],
            match[2],
            match[5],
            match[6],
            match[7]
          );
          if (!checkWeekday(match[1], parsedArray, config)) {
            return;
          }
          config._a = parsedArray;
          config._tzm = calculateOffset(match[8], match[9], match[10]);
          config._d = createUTCDate.apply(null, config._a);
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          getParsingFlags(config).rfc2822 = true;
        } else {
          config._isValid = false;
        }
      }
      function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
          config._d = new Date(+matched[1]);
          return;
        }
        configFromISO(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        configFromRFC2822(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        if (config._strict) {
          config._isValid = false;
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      hooks.createFromInputFallback = deprecate(
        "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
        function(config) {
          config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
        }
      );
      function defaults(a, b, c) {
        if (a != null) {
          return a;
        }
        if (b != null) {
          return b;
        }
        return c;
      }
      function currentDateArray(config) {
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
          return [
            nowValue.getUTCFullYear(),
            nowValue.getUTCMonth(),
            nowValue.getUTCDate()
          ];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
      }
      function configFromArray(config) {
        var i2, date, input = [], currentDate, expectedWeekday, yearToUse;
        if (config._d) {
          return;
        }
        currentDate = currentDateArray(config);
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
          dayOfYearFromWeekInfo(config);
        }
        if (config._dayOfYear != null) {
          yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
          if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
          }
          date = createUTCDate(yearToUse, 0, config._dayOfYear);
          config._a[MONTH] = date.getUTCMonth();
          config._a[DATE] = date.getUTCDate();
        }
        for (i2 = 0; i2 < 3 && config._a[i2] == null; ++i2) {
          config._a[i2] = input[i2] = currentDate[i2];
        }
        for (; i2 < 7; i2++) {
          config._a[i2] = input[i2] = config._a[i2] == null ? i2 === 2 ? 1 : 0 : config._a[i2];
        }
        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
          config._nextDay = true;
          config._a[HOUR] = 0;
        }
        config._d = (config._useUTC ? createUTCDate : createDate).apply(
          null,
          input
        );
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
        if (config._tzm != null) {
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }
        if (config._nextDay) {
          config._a[HOUR] = 24;
        }
        if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
          getParsingFlags(config).weekdayMismatch = true;
        }
      }
      function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week2, weekday, dow, doy, temp, weekdayOverflow, curWeek;
        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
          dow = 1;
          doy = 4;
          weekYear = defaults(
            w.GG,
            config._a[YEAR],
            weekOfYear(createLocal(), 1, 4).year
          );
          week2 = defaults(w.W, 1);
          weekday = defaults(w.E, 1);
          if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
          }
        } else {
          dow = config._locale._week.dow;
          doy = config._locale._week.doy;
          curWeek = weekOfYear(createLocal(), dow, doy);
          weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
          week2 = defaults(w.w, curWeek.week);
          if (w.d != null) {
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
              weekdayOverflow = true;
            }
          } else if (w.e != null) {
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
              weekdayOverflow = true;
            }
          } else {
            weekday = dow;
          }
        }
        if (week2 < 1 || week2 > weeksInYear(weekYear, dow, doy)) {
          getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
          getParsingFlags(config)._overflowWeekday = true;
        } else {
          temp = dayOfYearFromWeeks(weekYear, week2, weekday, dow, doy);
          config._a[YEAR] = temp.year;
          config._dayOfYear = temp.dayOfYear;
        }
      }
      hooks.ISO_8601 = function() {
      };
      hooks.RFC_2822 = function() {
      };
      function configFromStringAndFormat(config) {
        if (config._f === hooks.ISO_8601) {
          configFromISO(config);
          return;
        }
        if (config._f === hooks.RFC_2822) {
          configFromRFC2822(config);
          return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;
        var string = "" + config._i, i2, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
        tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
        tokenLen = tokens2.length;
        for (i2 = 0; i2 < tokenLen; i2++) {
          token2 = tokens2[i2];
          parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
          if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
              getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(
              string.indexOf(parsedInput) + parsedInput.length
            );
            totalParsedInputLength += parsedInput.length;
          }
          if (formatTokenFunctions[token2]) {
            if (parsedInput) {
              getParsingFlags(config).empty = false;
            } else {
              getParsingFlags(config).unusedTokens.push(token2);
            }
            addTimeToArrayFromToken(token2, parsedInput, config);
          } else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token2);
          }
        }
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
          getParsingFlags(config).unusedInput.push(string);
        }
        if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
          getParsingFlags(config).bigHour = void 0;
        }
        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        config._a[HOUR] = meridiemFixWrap(
          config._locale,
          config._a[HOUR],
          config._meridiem
        );
        era = getParsingFlags(config).era;
        if (era !== null) {
          config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
        }
        configFromArray(config);
        checkOverflow(config);
      }
      function meridiemFixWrap(locale2, hour2, meridiem2) {
        var isPm;
        if (meridiem2 == null) {
          return hour2;
        }
        if (locale2.meridiemHour != null) {
          return locale2.meridiemHour(hour2, meridiem2);
        } else if (locale2.isPM != null) {
          isPm = locale2.isPM(meridiem2);
          if (isPm && hour2 < 12) {
            hour2 += 12;
          }
          if (!isPm && hour2 === 12) {
            hour2 = 0;
          }
          return hour2;
        } else {
          return hour2;
        }
      }
      function configFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i2, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
        if (configfLen === 0) {
          getParsingFlags(config).invalidFormat = true;
          config._d = new Date(NaN);
          return;
        }
        for (i2 = 0; i2 < configfLen; i2++) {
          currentScore = 0;
          validFormatFound = false;
          tempConfig = copyConfig({}, config);
          if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
          }
          tempConfig._f = config._f[i2];
          configFromStringAndFormat(tempConfig);
          if (isValid(tempConfig)) {
            validFormatFound = true;
          }
          currentScore += getParsingFlags(tempConfig).charsLeftOver;
          currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
          getParsingFlags(tempConfig).score = currentScore;
          if (!bestFormatIsValid) {
            if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
              if (validFormatFound) {
                bestFormatIsValid = true;
              }
            }
          } else {
            if (currentScore < scoreToBeat) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
            }
          }
        }
        extend(config, bestMoment || tempConfig);
      }
      function configFromObject(config) {
        if (config._d) {
          return;
        }
        var i2 = normalizeObjectUnits(config._i), dayOrDate = i2.day === void 0 ? i2.date : i2.day;
        config._a = map3(
          [i2.year, i2.month, dayOrDate, i2.hour, i2.minute, i2.second, i2.millisecond],
          function(obj) {
            return obj && parseInt(obj, 10);
          }
        );
        configFromArray(config);
      }
      function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
          res.add(1, "d");
          res._nextDay = void 0;
        }
        return res;
      }
      function prepareConfig(config) {
        var input = config._i, format2 = config._f;
        config._locale = config._locale || getLocale(config._l);
        if (input === null || format2 === void 0 && input === "") {
          return createInvalid({ nullInput: true });
        }
        if (typeof input === "string") {
          config._i = input = config._locale.preparse(input);
        }
        if (isMoment(input)) {
          return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
          config._d = input;
        } else if (isArray3(format2)) {
          configFromStringAndArray(config);
        } else if (format2) {
          configFromStringAndFormat(config);
        } else {
          configFromInput(config);
        }
        if (!isValid(config)) {
          config._d = null;
        }
        return config;
      }
      function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
          config._d = new Date(hooks.now());
        } else if (isDate(input)) {
          config._d = new Date(input.valueOf());
        } else if (typeof input === "string") {
          configFromString(config);
        } else if (isArray3(input)) {
          config._a = map3(input.slice(0), function(obj) {
            return parseInt(obj, 10);
          });
          configFromArray(config);
        } else if (isObject2(input)) {
          configFromObject(config);
        } else if (isNumber(input)) {
          config._d = new Date(input);
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
        var c = {};
        if (format2 === true || format2 === false) {
          strict = format2;
          format2 = void 0;
        }
        if (locale2 === true || locale2 === false) {
          strict = locale2;
          locale2 = void 0;
        }
        if (isObject2(input) && isObjectEmpty(input) || isArray3(input) && input.length === 0) {
          input = void 0;
        }
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale2;
        c._i = input;
        c._f = format2;
        c._strict = strict;
        return createFromConfig(c);
      }
      function createLocal(input, format2, locale2, strict) {
        return createLocalOrUTC(input, format2, locale2, strict, false);
      }
      var prototypeMin = deprecate(
        "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
        function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
          } else {
            return createInvalid();
          }
        }
      ), prototypeMax = deprecate(
        "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
        function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
          } else {
            return createInvalid();
          }
        }
      );
      function pickBy(fn, moments) {
        var res, i2;
        if (moments.length === 1 && isArray3(moments[0])) {
          moments = moments[0];
        }
        if (!moments.length) {
          return createLocal();
        }
        res = moments[0];
        for (i2 = 1; i2 < moments.length; ++i2) {
          if (!moments[i2].isValid() || moments[i2][fn](res)) {
            res = moments[i2];
          }
        }
        return res;
      }
      function min3() {
        var args3 = [].slice.call(arguments, 0);
        return pickBy("isBefore", args3);
      }
      function max3() {
        var args3 = [].slice.call(arguments, 0);
        return pickBy("isAfter", args3);
      }
      var now2 = function() {
        return Date.now ? Date.now() : +new Date();
      };
      var ordering = [
        "year",
        "quarter",
        "month",
        "week",
        "day",
        "hour",
        "minute",
        "second",
        "millisecond"
      ];
      function isDurationValid(m) {
        var key, unitHasDecimal = false, i2, orderLen = ordering.length;
        for (key in m) {
          if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
          }
        }
        for (i2 = 0; i2 < orderLen; ++i2) {
          if (m[ordering[i2]]) {
            if (unitHasDecimal) {
              return false;
            }
            if (parseFloat(m[ordering[i2]]) !== toInt(m[ordering[i2]])) {
              unitHasDecimal = true;
            }
          }
        }
        return true;
      }
      function isValid$1() {
        return this._isValid;
      }
      function createInvalid$1() {
        return createDuration(NaN);
      }
      function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
        this._isValid = isDurationValid(normalizedInput);
        this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
        minutes2 * 6e4 + // 1000 * 60
        hours2 * 1e3 * 60 * 60;
        this._days = +days2 + weeks2 * 7;
        this._months = +months2 + quarters * 3 + years2 * 12;
        this._data = {};
        this._locale = getLocale();
        this._bubble();
      }
      function isDuration(obj) {
        return obj instanceof Duration;
      }
      function absRound(number) {
        if (number < 0) {
          return Math.round(-1 * number) * -1;
        } else {
          return Math.round(number);
        }
      }
      function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i2;
        for (i2 = 0; i2 < len; i2++) {
          if (dontConvert && array1[i2] !== array2[i2] || !dontConvert && toInt(array1[i2]) !== toInt(array2[i2])) {
            diffs++;
          }
        }
        return diffs + lengthDiff;
      }
      function offset(token2, separator) {
        addFormatToken(token2, 0, 0, function() {
          var offset2 = this.utcOffset(), sign2 = "+";
          if (offset2 < 0) {
            offset2 = -offset2;
            sign2 = "-";
          }
          return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
        });
      }
      offset("Z", ":");
      offset("ZZ", "");
      addRegexToken("Z", matchShortOffset);
      addRegexToken("ZZ", matchShortOffset);
      addParseToken(["Z", "ZZ"], function(input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
      });
      var chunkOffset = /([\+\-]|\d\d)/gi;
      function offsetFromString(matcher, string) {
        var matches = (string || "").match(matcher), chunk, parts, minutes2;
        if (matches === null) {
          return null;
        }
        chunk = matches[matches.length - 1] || [];
        parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
        minutes2 = +(parts[1] * 60) + toInt(parts[2]);
        return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
      }
      function cloneWithOffset(input, model) {
        var res, diff3;
        if (model._isUTC) {
          res = model.clone();
          diff3 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
          res._d.setTime(res._d.valueOf() + diff3);
          hooks.updateOffset(res, false);
          return res;
        } else {
          return createLocal(input).local();
        }
      }
      function getDateOffset(m) {
        return -Math.round(m._d.getTimezoneOffset());
      }
      hooks.updateOffset = function() {
      };
      function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset2 = this._offset || 0, localAdjust;
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          if (typeof input === "string") {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
              return this;
            }
          } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
          }
          if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
          }
          this._offset = input;
          this._isUTC = true;
          if (localAdjust != null) {
            this.add(localAdjust, "m");
          }
          if (offset2 !== input) {
            if (!keepLocalTime || this._changeInProgress) {
              addSubtract(
                this,
                createDuration(input - offset2, "m"),
                1,
                false
              );
            } else if (!this._changeInProgress) {
              this._changeInProgress = true;
              hooks.updateOffset(this, true);
              this._changeInProgress = null;
            }
          }
          return this;
        } else {
          return this._isUTC ? offset2 : getDateOffset(this);
        }
      }
      function getSetZone(input, keepLocalTime) {
        if (input != null) {
          if (typeof input !== "string") {
            input = -input;
          }
          this.utcOffset(input, keepLocalTime);
          return this;
        } else {
          return -this.utcOffset();
        }
      }
      function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
      }
      function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
          this.utcOffset(0, keepLocalTime);
          this._isUTC = false;
          if (keepLocalTime) {
            this.subtract(getDateOffset(this), "m");
          }
        }
        return this;
      }
      function setOffsetToParsedOffset() {
        if (this._tzm != null) {
          this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === "string") {
          var tZone = offsetFromString(matchOffset, this._i);
          if (tZone != null) {
            this.utcOffset(tZone);
          } else {
            this.utcOffset(0, true);
          }
        }
        return this;
      }
      function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
          return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;
        return (this.utcOffset() - input) % 60 === 0;
      }
      function isDaylightSavingTime() {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
      }
      function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
          return this._isDSTShifted;
        }
        var c = {}, other;
        copyConfig(c, this);
        c = prepareConfig(c);
        if (c._a) {
          other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
          this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
          this._isDSTShifted = false;
        }
        return this._isDSTShifted;
      }
      function isLocal() {
        return this.isValid() ? !this._isUTC : false;
      }
      function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
      }
      function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
      }
      var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
      function createDuration(input, key) {
        var duration = input, match = null, sign2, ret, diffRes;
        if (isDuration(input)) {
          duration = {
            ms: input._milliseconds,
            d: input._days,
            M: input._months
          };
        } else if (isNumber(input) || !isNaN(+input)) {
          duration = {};
          if (key) {
            duration[key] = +input;
          } else {
            duration.milliseconds = +input;
          }
        } else if (match = aspNetRegex.exec(input)) {
          sign2 = match[1] === "-" ? -1 : 1;
          duration = {
            y: 0,
            d: toInt(match[DATE]) * sign2,
            h: toInt(match[HOUR]) * sign2,
            m: toInt(match[MINUTE]) * sign2,
            s: toInt(match[SECOND]) * sign2,
            ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
            // the millisecond decimal point is included in the match
          };
        } else if (match = isoRegex.exec(input)) {
          sign2 = match[1] === "-" ? -1 : 1;
          duration = {
            y: parseIso(match[2], sign2),
            M: parseIso(match[3], sign2),
            w: parseIso(match[4], sign2),
            d: parseIso(match[5], sign2),
            h: parseIso(match[6], sign2),
            m: parseIso(match[7], sign2),
            s: parseIso(match[8], sign2)
          };
        } else if (duration == null) {
          duration = {};
        } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
          diffRes = momentsDifference(
            createLocal(duration.from),
            createLocal(duration.to)
          );
          duration = {};
          duration.ms = diffRes.milliseconds;
          duration.M = diffRes.months;
        }
        ret = new Duration(duration);
        if (isDuration(input) && hasOwnProp(input, "_locale")) {
          ret._locale = input._locale;
        }
        if (isDuration(input) && hasOwnProp(input, "_isValid")) {
          ret._isValid = input._isValid;
        }
        return ret;
      }
      createDuration.fn = Duration.prototype;
      createDuration.invalid = createInvalid$1;
      function parseIso(inp, sign2) {
        var res = inp && parseFloat(inp.replace(",", "."));
        return (isNaN(res) ? 0 : res) * sign2;
      }
      function positiveMomentsDifference(base, other) {
        var res = {};
        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, "M").isAfter(other)) {
          --res.months;
        }
        res.milliseconds = +other - +base.clone().add(res.months, "M");
        return res;
      }
      function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
          return { milliseconds: 0, months: 0 };
        }
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
          res = positiveMomentsDifference(base, other);
        } else {
          res = positiveMomentsDifference(other, base);
          res.milliseconds = -res.milliseconds;
          res.months = -res.months;
        }
        return res;
      }
      function createAdder(direction, name) {
        return function(val, period) {
          var dur, tmp;
          if (period !== null && !isNaN(+period)) {
            deprecateSimple(
              name,
              "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
            );
            tmp = val;
            val = period;
            period = tmp;
          }
          dur = createDuration(val, period);
          addSubtract(this, dur, direction);
          return this;
        };
      }
      function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
        if (!mom.isValid()) {
          return;
        }
        updateOffset = updateOffset == null ? true : updateOffset;
        if (months2) {
          setMonth(mom, get2(mom, "Month") + months2 * isAdding);
        }
        if (days2) {
          set$1(mom, "Date", get2(mom, "Date") + days2 * isAdding);
        }
        if (milliseconds2) {
          mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
        }
        if (updateOffset) {
          hooks.updateOffset(mom, days2 || months2);
        }
      }
      var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
      function isString(input) {
        return typeof input === "string" || input instanceof String;
      }
      function isMomentInput(input) {
        return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
      }
      function isMomentInputObject(input) {
        var objectTest = isObject2(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "years",
          "year",
          "y",
          "months",
          "month",
          "M",
          "days",
          "day",
          "d",
          "dates",
          "date",
          "D",
          "hours",
          "hour",
          "h",
          "minutes",
          "minute",
          "m",
          "seconds",
          "second",
          "s",
          "milliseconds",
          "millisecond",
          "ms"
        ], i2, property, propertyLen = properties.length;
        for (i2 = 0; i2 < propertyLen; i2 += 1) {
          property = properties[i2];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function isNumberOrStringArray(input) {
        var arrayTest = isArray3(input), dataTypeTest = false;
        if (arrayTest) {
          dataTypeTest = input.filter(function(item) {
            return !isNumber(item) && isString(input);
          }).length === 0;
        }
        return arrayTest && dataTypeTest;
      }
      function isCalendarSpec(input) {
        var objectTest = isObject2(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "sameDay",
          "nextDay",
          "lastDay",
          "nextWeek",
          "lastWeek",
          "sameElse"
        ], i2, property;
        for (i2 = 0; i2 < properties.length; i2 += 1) {
          property = properties[i2];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function getCalendarFormat(myMoment, now3) {
        var diff3 = myMoment.diff(now3, "days", true);
        return diff3 < -6 ? "sameElse" : diff3 < -1 ? "lastWeek" : diff3 < 0 ? "lastDay" : diff3 < 1 ? "sameDay" : diff3 < 2 ? "nextDay" : diff3 < 7 ? "nextWeek" : "sameElse";
      }
      function calendar$1(time, formats) {
        if (arguments.length === 1) {
          if (!arguments[0]) {
            time = void 0;
            formats = void 0;
          } else if (isMomentInput(arguments[0])) {
            time = arguments[0];
            formats = void 0;
          } else if (isCalendarSpec(arguments[0])) {
            formats = arguments[0];
            time = void 0;
          }
        }
        var now3 = time || createLocal(), sod = cloneWithOffset(now3, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format2]) ? formats[format2].call(this, now3) : formats[format2]);
        return this.format(
          output || this.localeData().calendar(format2, this, createLocal(now3))
        );
      }
      function clone() {
        return new Moment(this);
      }
      function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() > localInput.valueOf();
        } else {
          return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
      }
      function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() < localInput.valueOf();
        } else {
          return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
      }
      function isBetween(from4, to2, units, inclusivity) {
        var localFrom = isMoment(from4) ? from4 : createLocal(from4), localTo = isMoment(to2) ? to2 : createLocal(to2);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
          return false;
        }
        inclusivity = inclusivity || "()";
        return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
      }
      function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input), inputMs;
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() === localInput.valueOf();
        } else {
          inputMs = localInput.valueOf();
          return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
      }
      function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
      }
      function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
      }
      function diff2(input, units, asFloat) {
        var that, zoneDelta, output;
        if (!this.isValid()) {
          return NaN;
        }
        that = cloneWithOffset(input, this);
        if (!that.isValid()) {
          return NaN;
        }
        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
        units = normalizeUnits(units);
        switch (units) {
          case "year":
            output = monthDiff(this, that) / 12;
            break;
          case "month":
            output = monthDiff(this, that);
            break;
          case "quarter":
            output = monthDiff(this, that) / 3;
            break;
          case "second":
            output = (this - that) / 1e3;
            break;
          case "minute":
            output = (this - that) / 6e4;
            break;
          case "hour":
            output = (this - that) / 36e5;
            break;
          case "day":
            output = (this - that - zoneDelta) / 864e5;
            break;
          case "week":
            output = (this - that - zoneDelta) / 6048e5;
            break;
          default:
            output = this - that;
        }
        return asFloat ? output : absFloor(output);
      }
      function monthDiff(a, b) {
        if (a.date() < b.date()) {
          return -monthDiff(b, a);
        }
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
        if (b - anchor < 0) {
          anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
          adjust = (b - anchor) / (anchor - anchor2);
        } else {
          anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
          adjust = (b - anchor) / (anchor2 - anchor);
        }
        return -(wholeMonthDiff + adjust) || 0;
      }
      hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
      hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
      function toString() {
        return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
      }
      function toISOString(keepOffset) {
        if (!this.isValid()) {
          return null;
        }
        var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
          return formatMoment(
            m,
            utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
          );
        }
        if (isFunction(Date.prototype.toISOString)) {
          if (utc) {
            return this.toDate().toISOString();
          } else {
            return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
          }
        }
        return formatMoment(
          m,
          utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
        );
      }
      function inspect() {
        if (!this.isValid()) {
          return "moment.invalid(/* " + this._i + " */)";
        }
        var func = "moment", zone = "", prefix, year2, datetime, suffix;
        if (!this.isLocal()) {
          func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
          zone = "Z";
        }
        prefix = "[" + func + '("]';
        year2 = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
        datetime = "-MM-DD[T]HH:mm:ss.SSS";
        suffix = zone + '[")]';
        return this.format(prefix + year2 + datetime + suffix);
      }
      function format(inputString) {
        if (!inputString) {
          inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
      }
      function from3(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
      }
      function to(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
      }
      function locale(key) {
        var newLocaleData;
        if (key === void 0) {
          return this._locale._abbr;
        } else {
          newLocaleData = getLocale(key);
          if (newLocaleData != null) {
            this._locale = newLocaleData;
          }
          return this;
        }
      }
      var lang = deprecate(
        "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
        function(key) {
          if (key === void 0) {
            return this.localeData();
          } else {
            return this.locale(key);
          }
        }
      );
      function localeData() {
        return this._locale;
      }
      var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
      function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
      }
      function localStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
          return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return new Date(y, m, d).valueOf();
        }
      }
      function utcStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
          return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return Date.UTC(y, m, d);
        }
      }
      function startOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year(), 0, 1);
            break;
          case "quarter":
            time = startOfDate(
              this.year(),
              this.month() - this.month() % 3,
              1
            );
            break;
          case "month":
            time = startOfDate(this.year(), this.month(), 1);
            break;
          case "week":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - this.weekday()
            );
            break;
          case "isoWeek":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - (this.isoWeekday() - 1)
            );
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date());
            break;
          case "hour":
            time = this._d.valueOf();
            time -= mod$1(
              time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
              MS_PER_HOUR
            );
            break;
          case "minute":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_MINUTE);
            break;
          case "second":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_SECOND);
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function endOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year() + 1, 0, 1) - 1;
            break;
          case "quarter":
            time = startOfDate(
              this.year(),
              this.month() - this.month() % 3 + 3,
              1
            ) - 1;
            break;
          case "month":
            time = startOfDate(this.year(), this.month() + 1, 1) - 1;
            break;
          case "week":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - this.weekday() + 7
            ) - 1;
            break;
          case "isoWeek":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - (this.isoWeekday() - 1) + 7
            ) - 1;
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
            break;
          case "hour":
            time = this._d.valueOf();
            time += MS_PER_HOUR - mod$1(
              time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
              MS_PER_HOUR
            ) - 1;
            break;
          case "minute":
            time = this._d.valueOf();
            time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
            break;
          case "second":
            time = this._d.valueOf();
            time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 6e4;
      }
      function unix() {
        return Math.floor(this.valueOf() / 1e3);
      }
      function toDate() {
        return new Date(this.valueOf());
      }
      function toArray() {
        var m = this;
        return [
          m.year(),
          m.month(),
          m.date(),
          m.hour(),
          m.minute(),
          m.second(),
          m.millisecond()
        ];
      }
      function toObject() {
        var m = this;
        return {
          years: m.year(),
          months: m.month(),
          date: m.date(),
          hours: m.hours(),
          minutes: m.minutes(),
          seconds: m.seconds(),
          milliseconds: m.milliseconds()
        };
      }
      function toJSON() {
        return this.isValid() ? this.toISOString() : null;
      }
      function isValid$2() {
        return isValid(this);
      }
      function parsingFlags() {
        return extend({}, getParsingFlags(this));
      }
      function invalidAt() {
        return getParsingFlags(this).overflow;
      }
      function creationData() {
        return {
          input: this._i,
          format: this._f,
          locale: this._locale,
          isUTC: this._isUTC,
          strict: this._strict
        };
      }
      addFormatToken("N", 0, 0, "eraAbbr");
      addFormatToken("NN", 0, 0, "eraAbbr");
      addFormatToken("NNN", 0, 0, "eraAbbr");
      addFormatToken("NNNN", 0, 0, "eraName");
      addFormatToken("NNNNN", 0, 0, "eraNarrow");
      addFormatToken("y", ["y", 1], "yo", "eraYear");
      addFormatToken("y", ["yy", 2], 0, "eraYear");
      addFormatToken("y", ["yyy", 3], 0, "eraYear");
      addFormatToken("y", ["yyyy", 4], 0, "eraYear");
      addRegexToken("N", matchEraAbbr);
      addRegexToken("NN", matchEraAbbr);
      addRegexToken("NNN", matchEraAbbr);
      addRegexToken("NNNN", matchEraName);
      addRegexToken("NNNNN", matchEraNarrow);
      addParseToken(
        ["N", "NN", "NNN", "NNNN", "NNNNN"],
        function(input, array, config, token2) {
          var era = config._locale.erasParse(input, token2, config._strict);
          if (era) {
            getParsingFlags(config).era = era;
          } else {
            getParsingFlags(config).invalidEra = input;
          }
        }
      );
      addRegexToken("y", matchUnsigned);
      addRegexToken("yy", matchUnsigned);
      addRegexToken("yyy", matchUnsigned);
      addRegexToken("yyyy", matchUnsigned);
      addRegexToken("yo", matchEraYearOrdinal);
      addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
      addParseToken(["yo"], function(input, array, config, token2) {
        var match;
        if (config._locale._eraYearOrdinalRegex) {
          match = input.match(config._locale._eraYearOrdinalRegex);
        }
        if (config._locale.eraYearOrdinalParse) {
          array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
        } else {
          array[YEAR] = parseInt(input, 10);
        }
      });
      function localeEras(m, format2) {
        var i2, l, date, eras = this._eras || getLocale("en")._eras;
        for (i2 = 0, l = eras.length; i2 < l; ++i2) {
          switch (typeof eras[i2].since) {
            case "string":
              date = hooks(eras[i2].since).startOf("day");
              eras[i2].since = date.valueOf();
              break;
          }
          switch (typeof eras[i2].until) {
            case "undefined":
              eras[i2].until = Infinity;
              break;
            case "string":
              date = hooks(eras[i2].until).startOf("day").valueOf();
              eras[i2].until = date.valueOf();
              break;
          }
        }
        return eras;
      }
      function localeErasParse(eraName, format2, strict) {
        var i2, l, eras = this.eras(), name, abbr, narrow;
        eraName = eraName.toUpperCase();
        for (i2 = 0, l = eras.length; i2 < l; ++i2) {
          name = eras[i2].name.toUpperCase();
          abbr = eras[i2].abbr.toUpperCase();
          narrow = eras[i2].narrow.toUpperCase();
          if (strict) {
            switch (format2) {
              case "N":
              case "NN":
              case "NNN":
                if (abbr === eraName) {
                  return eras[i2];
                }
                break;
              case "NNNN":
                if (name === eraName) {
                  return eras[i2];
                }
                break;
              case "NNNNN":
                if (narrow === eraName) {
                  return eras[i2];
                }
                break;
            }
          } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
            return eras[i2];
          }
        }
      }
      function localeErasConvertYear(era, year2) {
        var dir = era.since <= era.until ? 1 : -1;
        if (year2 === void 0) {
          return hooks(era.since).year();
        } else {
          return hooks(era.since).year() + (year2 - era.offset) * dir;
        }
      }
      function getEraName() {
        var i2, l, val, eras = this.localeData().eras();
        for (i2 = 0, l = eras.length; i2 < l; ++i2) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i2].since <= val && val <= eras[i2].until) {
            return eras[i2].name;
          }
          if (eras[i2].until <= val && val <= eras[i2].since) {
            return eras[i2].name;
          }
        }
        return "";
      }
      function getEraNarrow() {
        var i2, l, val, eras = this.localeData().eras();
        for (i2 = 0, l = eras.length; i2 < l; ++i2) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i2].since <= val && val <= eras[i2].until) {
            return eras[i2].narrow;
          }
          if (eras[i2].until <= val && val <= eras[i2].since) {
            return eras[i2].narrow;
          }
        }
        return "";
      }
      function getEraAbbr() {
        var i2, l, val, eras = this.localeData().eras();
        for (i2 = 0, l = eras.length; i2 < l; ++i2) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i2].since <= val && val <= eras[i2].until) {
            return eras[i2].abbr;
          }
          if (eras[i2].until <= val && val <= eras[i2].since) {
            return eras[i2].abbr;
          }
        }
        return "";
      }
      function getEraYear() {
        var i2, l, dir, val, eras = this.localeData().eras();
        for (i2 = 0, l = eras.length; i2 < l; ++i2) {
          dir = eras[i2].since <= eras[i2].until ? 1 : -1;
          val = this.clone().startOf("day").valueOf();
          if (eras[i2].since <= val && val <= eras[i2].until || eras[i2].until <= val && val <= eras[i2].since) {
            return (this.year() - hooks(eras[i2].since).year()) * dir + eras[i2].offset;
          }
        }
        return this.year();
      }
      function erasNameRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNameRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNameRegex : this._erasRegex;
      }
      function erasAbbrRegex(isStrict) {
        if (!hasOwnProp(this, "_erasAbbrRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasAbbrRegex : this._erasRegex;
      }
      function erasNarrowRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNarrowRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNarrowRegex : this._erasRegex;
      }
      function matchEraAbbr(isStrict, locale2) {
        return locale2.erasAbbrRegex(isStrict);
      }
      function matchEraName(isStrict, locale2) {
        return locale2.erasNameRegex(isStrict);
      }
      function matchEraNarrow(isStrict, locale2) {
        return locale2.erasNarrowRegex(isStrict);
      }
      function matchEraYearOrdinal(isStrict, locale2) {
        return locale2._eraYearOrdinalRegex || matchUnsigned;
      }
      function computeErasParse() {
        var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i2, l, eras = this.eras();
        for (i2 = 0, l = eras.length; i2 < l; ++i2) {
          namePieces.push(regexEscape(eras[i2].name));
          abbrPieces.push(regexEscape(eras[i2].abbr));
          narrowPieces.push(regexEscape(eras[i2].narrow));
          mixedPieces.push(regexEscape(eras[i2].name));
          mixedPieces.push(regexEscape(eras[i2].abbr));
          mixedPieces.push(regexEscape(eras[i2].narrow));
        }
        this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
        this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
        this._erasNarrowRegex = new RegExp(
          "^(" + narrowPieces.join("|") + ")",
          "i"
        );
      }
      addFormatToken(0, ["gg", 2], 0, function() {
        return this.weekYear() % 100;
      });
      addFormatToken(0, ["GG", 2], 0, function() {
        return this.isoWeekYear() % 100;
      });
      function addWeekYearFormatToken(token2, getter) {
        addFormatToken(0, [token2, token2.length], 0, getter);
      }
      addWeekYearFormatToken("gggg", "weekYear");
      addWeekYearFormatToken("ggggg", "weekYear");
      addWeekYearFormatToken("GGGG", "isoWeekYear");
      addWeekYearFormatToken("GGGGG", "isoWeekYear");
      addUnitAlias("weekYear", "gg");
      addUnitAlias("isoWeekYear", "GG");
      addUnitPriority("weekYear", 1);
      addUnitPriority("isoWeekYear", 1);
      addRegexToken("G", matchSigned);
      addRegexToken("g", matchSigned);
      addRegexToken("GG", match1to2, match2);
      addRegexToken("gg", match1to2, match2);
      addRegexToken("GGGG", match1to4, match4);
      addRegexToken("gggg", match1to4, match4);
      addRegexToken("GGGGG", match1to6, match6);
      addRegexToken("ggggg", match1to6, match6);
      addWeekParseToken(
        ["gggg", "ggggg", "GGGG", "GGGGG"],
        function(input, week2, config, token2) {
          week2[token2.substr(0, 2)] = toInt(input);
        }
      );
      addWeekParseToken(["gg", "GG"], function(input, week2, config, token2) {
        week2[token2] = hooks.parseTwoDigitYear(input);
      });
      function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(
          this,
          input,
          this.week(),
          this.weekday(),
          this.localeData()._week.dow,
          this.localeData()._week.doy
        );
      }
      function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(
          this,
          input,
          this.isoWeek(),
          this.isoWeekday(),
          1,
          4
        );
      }
      function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
      }
      function getISOWeeksInISOWeekYear() {
        return weeksInYear(this.isoWeekYear(), 1, 4);
      }
      function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
      }
      function getWeeksInWeekYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
      }
      function getSetWeekYearHelper(input, week2, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
          return weekOfYear(this, dow, doy).year;
        } else {
          weeksTarget = weeksInYear(input, dow, doy);
          if (week2 > weeksTarget) {
            week2 = weeksTarget;
          }
          return setWeekAll.call(this, input, week2, weekday, dow, doy);
        }
      }
      function setWeekAll(weekYear, week2, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week2, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
      }
      addFormatToken("Q", 0, "Qo", "quarter");
      addUnitAlias("quarter", "Q");
      addUnitPriority("quarter", 7);
      addRegexToken("Q", match1);
      addParseToken("Q", function(input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
      });
      function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
      }
      addFormatToken("D", ["DD", 2], "Do", "date");
      addUnitAlias("date", "D");
      addUnitPriority("date", 9);
      addRegexToken("D", match1to2);
      addRegexToken("DD", match1to2, match2);
      addRegexToken("Do", function(isStrict, locale2) {
        return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
      });
      addParseToken(["D", "DD"], DATE);
      addParseToken("Do", function(input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
      });
      var getSetDayOfMonth = makeGetSet("Date", true);
      addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
      addUnitAlias("dayOfYear", "DDD");
      addUnitPriority("dayOfYear", 4);
      addRegexToken("DDD", match1to3);
      addRegexToken("DDDD", match3);
      addParseToken(["DDD", "DDDD"], function(input, array, config) {
        config._dayOfYear = toInt(input);
      });
      function getSetDayOfYear(input) {
        var dayOfYear = Math.round(
          (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
        ) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
      }
      addFormatToken("m", ["mm", 2], 0, "minute");
      addUnitAlias("minute", "m");
      addUnitPriority("minute", 14);
      addRegexToken("m", match1to2);
      addRegexToken("mm", match1to2, match2);
      addParseToken(["m", "mm"], MINUTE);
      var getSetMinute = makeGetSet("Minutes", false);
      addFormatToken("s", ["ss", 2], 0, "second");
      addUnitAlias("second", "s");
      addUnitPriority("second", 15);
      addRegexToken("s", match1to2);
      addRegexToken("ss", match1to2, match2);
      addParseToken(["s", "ss"], SECOND);
      var getSetSecond = makeGetSet("Seconds", false);
      addFormatToken("S", 0, 0, function() {
        return ~~(this.millisecond() / 100);
      });
      addFormatToken(0, ["SS", 2], 0, function() {
        return ~~(this.millisecond() / 10);
      });
      addFormatToken(0, ["SSS", 3], 0, "millisecond");
      addFormatToken(0, ["SSSS", 4], 0, function() {
        return this.millisecond() * 10;
      });
      addFormatToken(0, ["SSSSS", 5], 0, function() {
        return this.millisecond() * 100;
      });
      addFormatToken(0, ["SSSSSS", 6], 0, function() {
        return this.millisecond() * 1e3;
      });
      addFormatToken(0, ["SSSSSSS", 7], 0, function() {
        return this.millisecond() * 1e4;
      });
      addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
        return this.millisecond() * 1e5;
      });
      addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
        return this.millisecond() * 1e6;
      });
      addUnitAlias("millisecond", "ms");
      addUnitPriority("millisecond", 16);
      addRegexToken("S", match1to3, match1);
      addRegexToken("SS", match1to3, match2);
      addRegexToken("SSS", match1to3, match3);
      var token, getSetMillisecond;
      for (token = "SSSS"; token.length <= 9; token += "S") {
        addRegexToken(token, matchUnsigned);
      }
      function parseMs(input, array) {
        array[MILLISECOND] = toInt(("0." + input) * 1e3);
      }
      for (token = "S"; token.length <= 9; token += "S") {
        addParseToken(token, parseMs);
      }
      getSetMillisecond = makeGetSet("Milliseconds", false);
      addFormatToken("z", 0, 0, "zoneAbbr");
      addFormatToken("zz", 0, 0, "zoneName");
      function getZoneAbbr() {
        return this._isUTC ? "UTC" : "";
      }
      function getZoneName() {
        return this._isUTC ? "Coordinated Universal Time" : "";
      }
      var proto = Moment.prototype;
      proto.add = add;
      proto.calendar = calendar$1;
      proto.clone = clone;
      proto.diff = diff2;
      proto.endOf = endOf;
      proto.format = format;
      proto.from = from3;
      proto.fromNow = fromNow;
      proto.to = to;
      proto.toNow = toNow;
      proto.get = stringGet;
      proto.invalidAt = invalidAt;
      proto.isAfter = isAfter;
      proto.isBefore = isBefore;
      proto.isBetween = isBetween;
      proto.isSame = isSame;
      proto.isSameOrAfter = isSameOrAfter;
      proto.isSameOrBefore = isSameOrBefore;
      proto.isValid = isValid$2;
      proto.lang = lang;
      proto.locale = locale;
      proto.localeData = localeData;
      proto.max = prototypeMax;
      proto.min = prototypeMin;
      proto.parsingFlags = parsingFlags;
      proto.set = stringSet;
      proto.startOf = startOf;
      proto.subtract = subtract;
      proto.toArray = toArray;
      proto.toObject = toObject;
      proto.toDate = toDate;
      proto.toISOString = toISOString;
      proto.inspect = inspect;
      if (typeof Symbol !== "undefined" && Symbol.for != null) {
        proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
          return "Moment<" + this.format() + ">";
        };
      }
      proto.toJSON = toJSON;
      proto.toString = toString;
      proto.unix = unix;
      proto.valueOf = valueOf;
      proto.creationData = creationData;
      proto.eraName = getEraName;
      proto.eraNarrow = getEraNarrow;
      proto.eraAbbr = getEraAbbr;
      proto.eraYear = getEraYear;
      proto.year = getSetYear;
      proto.isLeapYear = getIsLeapYear;
      proto.weekYear = getSetWeekYear;
      proto.isoWeekYear = getSetISOWeekYear;
      proto.quarter = proto.quarters = getSetQuarter;
      proto.month = getSetMonth;
      proto.daysInMonth = getDaysInMonth;
      proto.week = proto.weeks = getSetWeek;
      proto.isoWeek = proto.isoWeeks = getSetISOWeek;
      proto.weeksInYear = getWeeksInYear;
      proto.weeksInWeekYear = getWeeksInWeekYear;
      proto.isoWeeksInYear = getISOWeeksInYear;
      proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
      proto.date = getSetDayOfMonth;
      proto.day = proto.days = getSetDayOfWeek;
      proto.weekday = getSetLocaleDayOfWeek;
      proto.isoWeekday = getSetISODayOfWeek;
      proto.dayOfYear = getSetDayOfYear;
      proto.hour = proto.hours = getSetHour;
      proto.minute = proto.minutes = getSetMinute;
      proto.second = proto.seconds = getSetSecond;
      proto.millisecond = proto.milliseconds = getSetMillisecond;
      proto.utcOffset = getSetOffset;
      proto.utc = setOffsetToUTC;
      proto.local = setOffsetToLocal;
      proto.parseZone = setOffsetToParsedOffset;
      proto.hasAlignedHourOffset = hasAlignedHourOffset;
      proto.isDST = isDaylightSavingTime;
      proto.isLocal = isLocal;
      proto.isUtcOffset = isUtcOffset;
      proto.isUtc = isUtc;
      proto.isUTC = isUtc;
      proto.zoneAbbr = getZoneAbbr;
      proto.zoneName = getZoneName;
      proto.dates = deprecate(
        "dates accessor is deprecated. Use date instead.",
        getSetDayOfMonth
      );
      proto.months = deprecate(
        "months accessor is deprecated. Use month instead",
        getSetMonth
      );
      proto.years = deprecate(
        "years accessor is deprecated. Use year instead",
        getSetYear
      );
      proto.zone = deprecate(
        "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
        getSetZone
      );
      proto.isDSTShifted = deprecate(
        "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
        isDaylightSavingTimeShifted
      );
      function createUnix(input) {
        return createLocal(input * 1e3);
      }
      function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
      }
      function preParsePostFormat(string) {
        return string;
      }
      var proto$1 = Locale.prototype;
      proto$1.calendar = calendar;
      proto$1.longDateFormat = longDateFormat;
      proto$1.invalidDate = invalidDate;
      proto$1.ordinal = ordinal;
      proto$1.preparse = preParsePostFormat;
      proto$1.postformat = preParsePostFormat;
      proto$1.relativeTime = relativeTime;
      proto$1.pastFuture = pastFuture;
      proto$1.set = set;
      proto$1.eras = localeEras;
      proto$1.erasParse = localeErasParse;
      proto$1.erasConvertYear = localeErasConvertYear;
      proto$1.erasAbbrRegex = erasAbbrRegex;
      proto$1.erasNameRegex = erasNameRegex;
      proto$1.erasNarrowRegex = erasNarrowRegex;
      proto$1.months = localeMonths;
      proto$1.monthsShort = localeMonthsShort;
      proto$1.monthsParse = localeMonthsParse;
      proto$1.monthsRegex = monthsRegex;
      proto$1.monthsShortRegex = monthsShortRegex;
      proto$1.week = localeWeek;
      proto$1.firstDayOfYear = localeFirstDayOfYear;
      proto$1.firstDayOfWeek = localeFirstDayOfWeek;
      proto$1.weekdays = localeWeekdays;
      proto$1.weekdaysMin = localeWeekdaysMin;
      proto$1.weekdaysShort = localeWeekdaysShort;
      proto$1.weekdaysParse = localeWeekdaysParse;
      proto$1.weekdaysRegex = weekdaysRegex;
      proto$1.weekdaysShortRegex = weekdaysShortRegex;
      proto$1.weekdaysMinRegex = weekdaysMinRegex;
      proto$1.isPM = localeIsPM;
      proto$1.meridiem = localeMeridiem;
      function get$1(format2, index, field, setter) {
        var locale2 = getLocale(), utc = createUTC().set(setter, index);
        return locale2[field](utc, format2);
      }
      function listMonthsImpl(format2, index, field) {
        if (isNumber(format2)) {
          index = format2;
          format2 = void 0;
        }
        format2 = format2 || "";
        if (index != null) {
          return get$1(format2, index, field, "month");
        }
        var i2, out = [];
        for (i2 = 0; i2 < 12; i2++) {
          out[i2] = get$1(format2, i2, field, "month");
        }
        return out;
      }
      function listWeekdaysImpl(localeSorted, format2, index, field) {
        if (typeof localeSorted === "boolean") {
          if (isNumber(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
        } else {
          format2 = localeSorted;
          index = format2;
          localeSorted = false;
          if (isNumber(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
        }
        var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i2, out = [];
        if (index != null) {
          return get$1(format2, (index + shift) % 7, field, "day");
        }
        for (i2 = 0; i2 < 7; i2++) {
          out[i2] = get$1(format2, (i2 + shift) % 7, field, "day");
        }
        return out;
      }
      function listMonths(format2, index) {
        return listMonthsImpl(format2, index, "months");
      }
      function listMonthsShort(format2, index) {
        return listMonthsImpl(format2, index, "monthsShort");
      }
      function listWeekdays(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdays");
      }
      function listWeekdaysShort(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdaysShort");
      }
      function listWeekdaysMin(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdaysMin");
      }
      getSetGlobalLocale("en", {
        eras: [
          {
            since: "0001-01-01",
            until: Infinity,
            offset: 1,
            name: "Anno Domini",
            narrow: "AD",
            abbr: "AD"
          },
          {
            since: "0000-12-31",
            until: -Infinity,
            offset: 1,
            name: "Before Christ",
            narrow: "BC",
            abbr: "BC"
          }
        ],
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
          var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
          return number + output;
        }
      });
      hooks.lang = deprecate(
        "moment.lang is deprecated. Use moment.locale instead.",
        getSetGlobalLocale
      );
      hooks.langData = deprecate(
        "moment.langData is deprecated. Use moment.localeData instead.",
        getLocale
      );
      var mathAbs = Math.abs;
      function abs2() {
        var data = this._data;
        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);
        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);
        return this;
      }
      function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);
        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;
        return duration._bubble();
      }
      function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
      }
      function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
      }
      function absCeil(number) {
        if (number < 0) {
          return Math.floor(number);
        } else {
          return Math.ceil(number);
        }
      }
      function bubble2() {
        var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
        if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
          milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
          days2 = 0;
          months2 = 0;
        }
        data.milliseconds = milliseconds2 % 1e3;
        seconds2 = absFloor(milliseconds2 / 1e3);
        data.seconds = seconds2 % 60;
        minutes2 = absFloor(seconds2 / 60);
        data.minutes = minutes2 % 60;
        hours2 = absFloor(minutes2 / 60);
        data.hours = hours2 % 24;
        days2 += absFloor(hours2 / 24);
        monthsFromDays = absFloor(daysToMonths(days2));
        months2 += monthsFromDays;
        days2 -= absCeil(monthsToDays(monthsFromDays));
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        data.days = days2;
        data.months = months2;
        data.years = years2;
        return this;
      }
      function daysToMonths(days2) {
        return days2 * 4800 / 146097;
      }
      function monthsToDays(months2) {
        return months2 * 146097 / 4800;
      }
      function as(units) {
        if (!this.isValid()) {
          return NaN;
        }
        var days2, months2, milliseconds2 = this._milliseconds;
        units = normalizeUnits(units);
        if (units === "month" || units === "quarter" || units === "year") {
          days2 = this._days + milliseconds2 / 864e5;
          months2 = this._months + daysToMonths(days2);
          switch (units) {
            case "month":
              return months2;
            case "quarter":
              return months2 / 3;
            case "year":
              return months2 / 12;
          }
        } else {
          days2 = this._days + Math.round(monthsToDays(this._months));
          switch (units) {
            case "week":
              return days2 / 7 + milliseconds2 / 6048e5;
            case "day":
              return days2 + milliseconds2 / 864e5;
            case "hour":
              return days2 * 24 + milliseconds2 / 36e5;
            case "minute":
              return days2 * 1440 + milliseconds2 / 6e4;
            case "second":
              return days2 * 86400 + milliseconds2 / 1e3;
            case "millisecond":
              return Math.floor(days2 * 864e5) + milliseconds2;
            default:
              throw new Error("Unknown unit " + units);
          }
        }
      }
      function valueOf$1() {
        if (!this.isValid()) {
          return NaN;
        }
        return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
      }
      function makeAs(alias) {
        return function() {
          return this.as(alias);
        };
      }
      var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
      function clone$1() {
        return createDuration(this);
      }
      function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + "s"]() : NaN;
      }
      function makeGetter(name) {
        return function() {
          return this.isValid() ? this._data[name] : NaN;
        };
      }
      var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
      function weeks() {
        return absFloor(this.days() / 7);
      }
      var round = Math.round, thresholds = {
        ss: 44,
        // a few seconds to seconds
        s: 45,
        // seconds to minute
        m: 45,
        // minutes to hour
        h: 22,
        // hours to day
        d: 26,
        // days to month/week
        w: null,
        // weeks to month
        M: 11
        // months to year
      };
      function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
        return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
      }
      function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
        var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
        if (thresholds2.w != null) {
          a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
        }
        a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale2;
        return substituteTimeAgo.apply(null, a);
      }
      function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === void 0) {
          return round;
        }
        if (typeof roundingFunction === "function") {
          round = roundingFunction;
          return true;
        }
        return false;
      }
      function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === void 0) {
          return false;
        }
        if (limit === void 0) {
          return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === "s") {
          thresholds.ss = limit - 1;
        }
        return true;
      }
      function humanize(argWithSuffix, argThresholds) {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var withSuffix = false, th = thresholds, locale2, output;
        if (typeof argWithSuffix === "object") {
          argThresholds = argWithSuffix;
          argWithSuffix = false;
        }
        if (typeof argWithSuffix === "boolean") {
          withSuffix = argWithSuffix;
        }
        if (typeof argThresholds === "object") {
          th = Object.assign({}, thresholds, argThresholds);
          if (argThresholds.s != null && argThresholds.ss == null) {
            th.ss = argThresholds.s - 1;
          }
        }
        locale2 = this.localeData();
        output = relativeTime$1(this, !withSuffix, th, locale2);
        if (withSuffix) {
          output = locale2.pastFuture(+this, output);
        }
        return locale2.postformat(output);
      }
      var abs$1 = Math.abs;
      function sign(x) {
        return (x > 0) - (x < 0) || +x;
      }
      function toISOString$1() {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s2, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
        if (!total) {
          return "P0D";
        }
        minutes2 = absFloor(seconds2 / 60);
        hours2 = absFloor(minutes2 / 60);
        seconds2 %= 60;
        minutes2 %= 60;
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        s2 = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
        totalSign = total < 0 ? "-" : "";
        ymSign = sign(this._months) !== sign(total) ? "-" : "";
        daysSign = sign(this._days) !== sign(total) ? "-" : "";
        hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
        return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s2 + "S" : "");
      }
      var proto$2 = Duration.prototype;
      proto$2.isValid = isValid$1;
      proto$2.abs = abs2;
      proto$2.add = add$1;
      proto$2.subtract = subtract$1;
      proto$2.as = as;
      proto$2.asMilliseconds = asMilliseconds;
      proto$2.asSeconds = asSeconds;
      proto$2.asMinutes = asMinutes;
      proto$2.asHours = asHours;
      proto$2.asDays = asDays;
      proto$2.asWeeks = asWeeks;
      proto$2.asMonths = asMonths;
      proto$2.asQuarters = asQuarters;
      proto$2.asYears = asYears;
      proto$2.valueOf = valueOf$1;
      proto$2._bubble = bubble2;
      proto$2.clone = clone$1;
      proto$2.get = get$2;
      proto$2.milliseconds = milliseconds;
      proto$2.seconds = seconds;
      proto$2.minutes = minutes;
      proto$2.hours = hours;
      proto$2.days = days;
      proto$2.weeks = weeks;
      proto$2.months = months;
      proto$2.years = years;
      proto$2.humanize = humanize;
      proto$2.toISOString = toISOString$1;
      proto$2.toString = toISOString$1;
      proto$2.toJSON = toISOString$1;
      proto$2.locale = locale;
      proto$2.localeData = localeData;
      proto$2.toIsoString = deprecate(
        "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
        toISOString$1
      );
      proto$2.lang = lang;
      addFormatToken("X", 0, 0, "unix");
      addFormatToken("x", 0, 0, "valueOf");
      addRegexToken("x", matchSigned);
      addRegexToken("X", matchTimestamp);
      addParseToken("X", function(input, array, config) {
        config._d = new Date(parseFloat(input) * 1e3);
      });
      addParseToken("x", function(input, array, config) {
        config._d = new Date(toInt(input));
      });
      hooks.version = "2.29.4";
      setHookCallback(createLocal);
      hooks.fn = proto;
      hooks.min = min3;
      hooks.max = max3;
      hooks.now = now2;
      hooks.utc = createUTC;
      hooks.unix = createUnix;
      hooks.months = listMonths;
      hooks.isDate = isDate;
      hooks.locale = getSetGlobalLocale;
      hooks.invalid = createInvalid;
      hooks.duration = createDuration;
      hooks.isMoment = isMoment;
      hooks.weekdays = listWeekdays;
      hooks.parseZone = createInZone;
      hooks.localeData = getLocale;
      hooks.isDuration = isDuration;
      hooks.monthsShort = listMonthsShort;
      hooks.weekdaysMin = listWeekdaysMin;
      hooks.defineLocale = defineLocale;
      hooks.updateLocale = updateLocale;
      hooks.locales = listLocales;
      hooks.weekdaysShort = listWeekdaysShort;
      hooks.normalizeUnits = normalizeUnits;
      hooks.relativeTimeRounding = getSetRelativeTimeRounding;
      hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
      hooks.calendarFormat = getCalendarFormat;
      hooks.prototype = proto;
      hooks.HTML5_FMT = {
        DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
        // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
        // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
        // <input type="datetime-local" step="0.001" />
        DATE: "YYYY-MM-DD",
        // <input type="date" />
        TIME: "HH:mm",
        // <input type="time" />
        TIME_SECONDS: "HH:mm:ss",
        // <input type="time" step="1" />
        TIME_MS: "HH:mm:ss.SSS",
        // <input type="time" step="0.001" />
        WEEK: "GGGG-[W]WW",
        // <input type="week" />
        MONTH: "YYYY-MM"
        // <input type="month" />
      };
      return hooks;
    });
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => Live
});
module.exports = __toCommonJS(main_exports);
var import_obsidian32 = require("obsidian");
var import_obsidian33 = require("obsidian");
var import_path_browserify3 = __toESM(require_path_browserify());

// node_modules/lib0/map.js
var create = () => /* @__PURE__ */ new Map();
var copy = (m) => {
  const r = create();
  m.forEach((v, k) => {
    r.set(k, v);
  });
  return r;
};
var setIfUndefined = (map3, key, createT) => {
  let set = map3.get(key);
  if (set === void 0) {
    map3.set(key, set = createT());
  }
  return set;
};
var map = (m, f) => {
  const res = [];
  for (const [key, value] of m) {
    res.push(f(value, key));
  }
  return res;
};
var any = (m, f) => {
  for (const [key, value] of m) {
    if (f(value, key)) {
      return true;
    }
  }
  return false;
};

// node_modules/lib0/set.js
var create2 = () => /* @__PURE__ */ new Set();

// node_modules/lib0/array.js
var last = (arr) => arr[arr.length - 1];
var appendTo = (dest, src) => {
  for (let i2 = 0; i2 < src.length; i2++) {
    dest.push(src[i2]);
  }
};
var from = Array.from;
var isArray = Array.isArray;

// node_modules/lib0/observable.js
var ObservableV2 = class {
  constructor() {
    this._observers = create();
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  on(name, f) {
    setIfUndefined(
      this._observers,
      /** @type {string} */
      name,
      create2
    ).add(f);
    return f;
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  once(name, f) {
    const _f = (...args3) => {
      this.off(
        name,
        /** @type {any} */
        _f
      );
      f(...args3);
    };
    this.on(
      name,
      /** @type {any} */
      _f
    );
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  off(name, f) {
    const observers = this._observers.get(name);
    if (observers !== void 0) {
      observers.delete(f);
      if (observers.size === 0) {
        this._observers.delete(name);
      }
    }
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name The event name.
   * @param {Parameters<EVENTS[NAME]>} args The arguments that are applied to the event listener.
   */
  emit(name, args3) {
    return from((this._observers.get(name) || create()).values()).forEach((f) => f(...args3));
  }
  destroy() {
    this._observers = create();
  }
};
var Observable = class {
  constructor() {
    this._observers = create();
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  on(name, f) {
    setIfUndefined(this._observers, name, create2).add(f);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  once(name, f) {
    const _f = (...args3) => {
      this.off(name, _f);
      f(...args3);
    };
    this.on(name, _f);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  off(name, f) {
    const observers = this._observers.get(name);
    if (observers !== void 0) {
      observers.delete(f);
      if (observers.size === 0) {
        this._observers.delete(name);
      }
    }
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @param {N} name The event name.
   * @param {Array<any>} args The arguments that are applied to the event listener.
   */
  emit(name, args3) {
    return from((this._observers.get(name) || create()).values()).forEach((f) => f(...args3));
  }
  destroy() {
    this._observers = create();
  }
};

// node_modules/lib0/math.js
var floor = Math.floor;
var abs = Math.abs;
var min = (a, b) => a < b ? a : b;
var max = (a, b) => a > b ? a : b;
var isNaN2 = Number.isNaN;
var isNegativeZero = (n) => n !== 0 ? n < 0 : 1 / n < 0;

// node_modules/lib0/binary.js
var BIT1 = 1;
var BIT2 = 2;
var BIT3 = 4;
var BIT4 = 8;
var BIT6 = 32;
var BIT7 = 64;
var BIT8 = 128;
var BIT18 = 1 << 17;
var BIT19 = 1 << 18;
var BIT20 = 1 << 19;
var BIT21 = 1 << 20;
var BIT22 = 1 << 21;
var BIT23 = 1 << 22;
var BIT24 = 1 << 23;
var BIT25 = 1 << 24;
var BIT26 = 1 << 25;
var BIT27 = 1 << 26;
var BIT28 = 1 << 27;
var BIT29 = 1 << 28;
var BIT30 = 1 << 29;
var BIT31 = 1 << 30;
var BIT32 = 1 << 31;
var BITS5 = 31;
var BITS6 = 63;
var BITS7 = 127;
var BITS17 = BIT18 - 1;
var BITS18 = BIT19 - 1;
var BITS19 = BIT20 - 1;
var BITS20 = BIT21 - 1;
var BITS21 = BIT22 - 1;
var BITS22 = BIT23 - 1;
var BITS23 = BIT24 - 1;
var BITS24 = BIT25 - 1;
var BITS25 = BIT26 - 1;
var BITS26 = BIT27 - 1;
var BITS27 = BIT28 - 1;
var BITS28 = BIT29 - 1;
var BITS29 = BIT30 - 1;
var BITS30 = BIT31 - 1;
var BITS31 = 2147483647;

// node_modules/lib0/number.js
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;
var MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER;
var LOWEST_INT32 = 1 << 31;
var isInteger = Number.isInteger || ((num) => typeof num === "number" && isFinite(num) && floor(num) === num);
var isNaN3 = Number.isNaN;
var parseInt2 = Number.parseInt;

// node_modules/lib0/string.js
var fromCharCode = String.fromCharCode;
var fromCodePoint = String.fromCodePoint;
var MAX_UTF16_CHARACTER = fromCharCode(65535);
var toLowerCase = (s2) => s2.toLowerCase();
var trimLeftRegex = /^\s*/g;
var trimLeft = (s2) => s2.replace(trimLeftRegex, "");
var fromCamelCaseRegex = /([A-Z])/g;
var fromCamelCase = (s2, separator) => trimLeft(s2.replace(fromCamelCaseRegex, (match) => `${separator}${toLowerCase(match)}`));
var _encodeUtf8Polyfill = (str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  const buf = new Uint8Array(len);
  for (let i2 = 0; i2 < len; i2++) {
    buf[i2] = /** @type {number} */
    encodedString.codePointAt(i2);
  }
  return buf;
};
var utf8TextEncoder = (
  /** @type {TextEncoder} */
  typeof TextEncoder !== "undefined" ? new TextEncoder() : null
);
var _encodeUtf8Native = (str) => utf8TextEncoder.encode(str);
var encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill;
var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8", { fatal: true, ignoreBOM: true });
if (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {
  utf8TextDecoder = null;
}

// node_modules/lib0/encoding.js
var Encoder = class {
  constructor() {
    this.cpos = 0;
    this.cbuf = new Uint8Array(100);
    this.bufs = [];
  }
};
var createEncoder = () => new Encoder();
var length = (encoder2) => {
  let len = encoder2.cpos;
  for (let i2 = 0; i2 < encoder2.bufs.length; i2++) {
    len += encoder2.bufs[i2].length;
  }
  return len;
};
var toUint8Array = (encoder2) => {
  const uint8arr = new Uint8Array(length(encoder2));
  let curPos = 0;
  for (let i2 = 0; i2 < encoder2.bufs.length; i2++) {
    const d = encoder2.bufs[i2];
    uint8arr.set(d, curPos);
    curPos += d.length;
  }
  uint8arr.set(new Uint8Array(encoder2.cbuf.buffer, 0, encoder2.cpos), curPos);
  return uint8arr;
};
var verifyLen = (encoder2, len) => {
  const bufferLen = encoder2.cbuf.length;
  if (bufferLen - encoder2.cpos < len) {
    encoder2.bufs.push(new Uint8Array(encoder2.cbuf.buffer, 0, encoder2.cpos));
    encoder2.cbuf = new Uint8Array(max(bufferLen, len) * 2);
    encoder2.cpos = 0;
  }
};
var write = (encoder2, num) => {
  const bufferLen = encoder2.cbuf.length;
  if (encoder2.cpos === bufferLen) {
    encoder2.bufs.push(encoder2.cbuf);
    encoder2.cbuf = new Uint8Array(bufferLen * 2);
    encoder2.cpos = 0;
  }
  encoder2.cbuf[encoder2.cpos++] = num;
};
var writeUint8 = write;
var writeVarUint = (encoder2, num) => {
  while (num > BITS7) {
    write(encoder2, BIT8 | BITS7 & num);
    num = floor(num / 128);
  }
  write(encoder2, BITS7 & num);
};
var writeVarInt = (encoder2, num) => {
  const isNegative = isNegativeZero(num);
  if (isNegative) {
    num = -num;
  }
  write(encoder2, (num > BITS6 ? BIT8 : 0) | (isNegative ? BIT7 : 0) | BITS6 & num);
  num = floor(num / 64);
  while (num > 0) {
    write(encoder2, (num > BITS7 ? BIT8 : 0) | BITS7 & num);
    num = floor(num / 128);
  }
};
var _strBuffer = new Uint8Array(3e4);
var _maxStrBSize = _strBuffer.length / 3;
var _writeVarStringNative = (encoder2, str) => {
  if (str.length < _maxStrBSize) {
    const written = utf8TextEncoder.encodeInto(str, _strBuffer).written || 0;
    writeVarUint(encoder2, written);
    for (let i2 = 0; i2 < written; i2++) {
      write(encoder2, _strBuffer[i2]);
    }
  } else {
    writeVarUint8Array(encoder2, encodeUtf8(str));
  }
};
var _writeVarStringPolyfill = (encoder2, str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  writeVarUint(encoder2, len);
  for (let i2 = 0; i2 < len; i2++) {
    write(
      encoder2,
      /** @type {number} */
      encodedString.codePointAt(i2)
    );
  }
};
var writeVarString = utf8TextEncoder && /** @type {any} */
utf8TextEncoder.encodeInto ? _writeVarStringNative : _writeVarStringPolyfill;
var writeUint8Array = (encoder2, uint8Array) => {
  const bufferLen = encoder2.cbuf.length;
  const cpos = encoder2.cpos;
  const leftCopyLen = min(bufferLen - cpos, uint8Array.length);
  const rightCopyLen = uint8Array.length - leftCopyLen;
  encoder2.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);
  encoder2.cpos += leftCopyLen;
  if (rightCopyLen > 0) {
    encoder2.bufs.push(encoder2.cbuf);
    encoder2.cbuf = new Uint8Array(max(bufferLen * 2, rightCopyLen));
    encoder2.cbuf.set(uint8Array.subarray(leftCopyLen));
    encoder2.cpos = rightCopyLen;
  }
};
var writeVarUint8Array = (encoder2, uint8Array) => {
  writeVarUint(encoder2, uint8Array.byteLength);
  writeUint8Array(encoder2, uint8Array);
};
var writeOnDataView = (encoder2, len) => {
  verifyLen(encoder2, len);
  const dview = new DataView(encoder2.cbuf.buffer, encoder2.cpos, len);
  encoder2.cpos += len;
  return dview;
};
var writeFloat32 = (encoder2, num) => writeOnDataView(encoder2, 4).setFloat32(0, num, false);
var writeFloat64 = (encoder2, num) => writeOnDataView(encoder2, 8).setFloat64(0, num, false);
var writeBigInt64 = (encoder2, num) => (
  /** @type {any} */
  writeOnDataView(encoder2, 8).setBigInt64(0, num, false)
);
var floatTestBed = new DataView(new ArrayBuffer(4));
var isFloat32 = (num) => {
  floatTestBed.setFloat32(0, num);
  return floatTestBed.getFloat32(0) === num;
};
var writeAny = (encoder2, data) => {
  switch (typeof data) {
    case "string":
      write(encoder2, 119);
      writeVarString(encoder2, data);
      break;
    case "number":
      if (isInteger(data) && abs(data) <= BITS31) {
        write(encoder2, 125);
        writeVarInt(encoder2, data);
      } else if (isFloat32(data)) {
        write(encoder2, 124);
        writeFloat32(encoder2, data);
      } else {
        write(encoder2, 123);
        writeFloat64(encoder2, data);
      }
      break;
    case "bigint":
      write(encoder2, 122);
      writeBigInt64(encoder2, data);
      break;
    case "object":
      if (data === null) {
        write(encoder2, 126);
      } else if (isArray(data)) {
        write(encoder2, 117);
        writeVarUint(encoder2, data.length);
        for (let i2 = 0; i2 < data.length; i2++) {
          writeAny(encoder2, data[i2]);
        }
      } else if (data instanceof Uint8Array) {
        write(encoder2, 116);
        writeVarUint8Array(encoder2, data);
      } else {
        write(encoder2, 118);
        const keys2 = Object.keys(data);
        writeVarUint(encoder2, keys2.length);
        for (let i2 = 0; i2 < keys2.length; i2++) {
          const key = keys2[i2];
          writeVarString(encoder2, key);
          writeAny(encoder2, data[key]);
        }
      }
      break;
    case "boolean":
      write(encoder2, data ? 120 : 121);
      break;
    default:
      write(encoder2, 127);
  }
};
var RleEncoder = class extends Encoder {
  /**
   * @param {function(Encoder, T):void} writer
   */
  constructor(writer) {
    super();
    this.w = writer;
    this.s = null;
    this.count = 0;
  }
  /**
   * @param {T} v
   */
  write(v) {
    if (this.s === v) {
      this.count++;
    } else {
      if (this.count > 0) {
        writeVarUint(this, this.count - 1);
      }
      this.count = 1;
      this.w(this, v);
      this.s = v;
    }
  }
};
var flushUintOptRleEncoder = (encoder2) => {
  if (encoder2.count > 0) {
    writeVarInt(encoder2.encoder, encoder2.count === 1 ? encoder2.s : -encoder2.s);
    if (encoder2.count > 1) {
      writeVarUint(encoder2.encoder, encoder2.count - 2);
    }
  }
};
var UintOptRleEncoder = class {
  constructor() {
    this.encoder = new Encoder();
    this.s = 0;
    this.count = 0;
  }
  /**
   * @param {number} v
   */
  write(v) {
    if (this.s === v) {
      this.count++;
    } else {
      flushUintOptRleEncoder(this);
      this.count = 1;
      this.s = v;
    }
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    flushUintOptRleEncoder(this);
    return toUint8Array(this.encoder);
  }
};
var flushIntDiffOptRleEncoder = (encoder2) => {
  if (encoder2.count > 0) {
    const encodedDiff = encoder2.diff * 2 + (encoder2.count === 1 ? 0 : 1);
    writeVarInt(encoder2.encoder, encodedDiff);
    if (encoder2.count > 1) {
      writeVarUint(encoder2.encoder, encoder2.count - 2);
    }
  }
};
var IntDiffOptRleEncoder = class {
  constructor() {
    this.encoder = new Encoder();
    this.s = 0;
    this.count = 0;
    this.diff = 0;
  }
  /**
   * @param {number} v
   */
  write(v) {
    if (this.diff === v - this.s) {
      this.s = v;
      this.count++;
    } else {
      flushIntDiffOptRleEncoder(this);
      this.count = 1;
      this.diff = v - this.s;
      this.s = v;
    }
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    flushIntDiffOptRleEncoder(this);
    return toUint8Array(this.encoder);
  }
};
var StringEncoder = class {
  constructor() {
    this.sarr = [];
    this.s = "";
    this.lensE = new UintOptRleEncoder();
  }
  /**
   * @param {string} string
   */
  write(string) {
    this.s += string;
    if (this.s.length > 19) {
      this.sarr.push(this.s);
      this.s = "";
    }
    this.lensE.write(string.length);
  }
  toUint8Array() {
    const encoder2 = new Encoder();
    this.sarr.push(this.s);
    this.s = "";
    writeVarString(encoder2, this.sarr.join(""));
    writeUint8Array(encoder2, this.lensE.toUint8Array());
    return toUint8Array(encoder2);
  }
};

// node_modules/lib0/error.js
var create3 = (s2) => new Error(s2);
var methodUnimplemented = () => {
  throw create3("Method unimplemented");
};
var unexpectedCase = () => {
  throw create3("Unexpected case");
};

// node_modules/lib0/decoding.js
var errorUnexpectedEndOfArray = create3("Unexpected end of array");
var errorIntegerOutOfRange = create3("Integer out of Range");
var Decoder = class {
  /**
   * @param {Uint8Array} uint8Array Binary data to decode
   */
  constructor(uint8Array) {
    this.arr = uint8Array;
    this.pos = 0;
  }
};
var createDecoder = (uint8Array) => new Decoder(uint8Array);
var hasContent = (decoder2) => decoder2.pos !== decoder2.arr.length;
var readUint8Array = (decoder2, len) => {
  const view = new Uint8Array(decoder2.arr.buffer, decoder2.pos + decoder2.arr.byteOffset, len);
  decoder2.pos += len;
  return view;
};
var readVarUint8Array = (decoder2) => readUint8Array(decoder2, readVarUint(decoder2));
var readUint8 = (decoder2) => decoder2.arr[decoder2.pos++];
var readVarUint = (decoder2) => {
  let num = 0;
  let mult = 1;
  const len = decoder2.arr.length;
  while (decoder2.pos < len) {
    const r = decoder2.arr[decoder2.pos++];
    num = num + (r & BITS7) * mult;
    mult *= 128;
    if (r < BIT8) {
      return num;
    }
    if (num > MAX_SAFE_INTEGER) {
      throw errorIntegerOutOfRange;
    }
  }
  throw errorUnexpectedEndOfArray;
};
var readVarInt = (decoder2) => {
  let r = decoder2.arr[decoder2.pos++];
  let num = r & BITS6;
  let mult = 64;
  const sign = (r & BIT7) > 0 ? -1 : 1;
  if ((r & BIT8) === 0) {
    return sign * num;
  }
  const len = decoder2.arr.length;
  while (decoder2.pos < len) {
    r = decoder2.arr[decoder2.pos++];
    num = num + (r & BITS7) * mult;
    mult *= 128;
    if (r < BIT8) {
      return sign * num;
    }
    if (num > MAX_SAFE_INTEGER) {
      throw errorIntegerOutOfRange;
    }
  }
  throw errorUnexpectedEndOfArray;
};
var _readVarStringPolyfill = (decoder2) => {
  let remainingLen = readVarUint(decoder2);
  if (remainingLen === 0) {
    return "";
  } else {
    let encodedString = String.fromCodePoint(readUint8(decoder2));
    if (--remainingLen < 100) {
      while (remainingLen--) {
        encodedString += String.fromCodePoint(readUint8(decoder2));
      }
    } else {
      while (remainingLen > 0) {
        const nextLen = remainingLen < 1e4 ? remainingLen : 1e4;
        const bytes = decoder2.arr.subarray(decoder2.pos, decoder2.pos + nextLen);
        decoder2.pos += nextLen;
        encodedString += String.fromCodePoint.apply(
          null,
          /** @type {any} */
          bytes
        );
        remainingLen -= nextLen;
      }
    }
    return decodeURIComponent(escape(encodedString));
  }
};
var _readVarStringNative = (decoder2) => (
  /** @type any */
  utf8TextDecoder.decode(readVarUint8Array(decoder2))
);
var readVarString = utf8TextDecoder ? _readVarStringNative : _readVarStringPolyfill;
var readFromDataView = (decoder2, len) => {
  const dv = new DataView(decoder2.arr.buffer, decoder2.arr.byteOffset + decoder2.pos, len);
  decoder2.pos += len;
  return dv;
};
var readFloat32 = (decoder2) => readFromDataView(decoder2, 4).getFloat32(0, false);
var readFloat64 = (decoder2) => readFromDataView(decoder2, 8).getFloat64(0, false);
var readBigInt64 = (decoder2) => (
  /** @type {any} */
  readFromDataView(decoder2, 8).getBigInt64(0, false)
);
var readAnyLookupTable = [
  (decoder2) => void 0,
  // CASE 127: undefined
  (decoder2) => null,
  // CASE 126: null
  readVarInt,
  // CASE 125: integer
  readFloat32,
  // CASE 124: float32
  readFloat64,
  // CASE 123: float64
  readBigInt64,
  // CASE 122: bigint
  (decoder2) => false,
  // CASE 121: boolean (false)
  (decoder2) => true,
  // CASE 120: boolean (true)
  readVarString,
  // CASE 119: string
  (decoder2) => {
    const len = readVarUint(decoder2);
    const obj = {};
    for (let i2 = 0; i2 < len; i2++) {
      const key = readVarString(decoder2);
      obj[key] = readAny(decoder2);
    }
    return obj;
  },
  (decoder2) => {
    const len = readVarUint(decoder2);
    const arr = [];
    for (let i2 = 0; i2 < len; i2++) {
      arr.push(readAny(decoder2));
    }
    return arr;
  },
  readVarUint8Array
  // CASE 116: Uint8Array
];
var readAny = (decoder2) => readAnyLookupTable[127 - readUint8(decoder2)](decoder2);
var RleDecoder = class extends Decoder {
  /**
   * @param {Uint8Array} uint8Array
   * @param {function(Decoder):T} reader
   */
  constructor(uint8Array, reader) {
    super(uint8Array);
    this.reader = reader;
    this.s = null;
    this.count = 0;
  }
  read() {
    if (this.count === 0) {
      this.s = this.reader(this);
      if (hasContent(this)) {
        this.count = readVarUint(this) + 1;
      } else {
        this.count = -1;
      }
    }
    this.count--;
    return (
      /** @type {T} */
      this.s
    );
  }
};
var UintOptRleDecoder = class extends Decoder {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(uint8Array) {
    super(uint8Array);
    this.s = 0;
    this.count = 0;
  }
  read() {
    if (this.count === 0) {
      this.s = readVarInt(this);
      const isNegative = isNegativeZero(this.s);
      this.count = 1;
      if (isNegative) {
        this.s = -this.s;
        this.count = readVarUint(this) + 2;
      }
    }
    this.count--;
    return (
      /** @type {number} */
      this.s
    );
  }
};
var IntDiffOptRleDecoder = class extends Decoder {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(uint8Array) {
    super(uint8Array);
    this.s = 0;
    this.count = 0;
    this.diff = 0;
  }
  /**
   * @return {number}
   */
  read() {
    if (this.count === 0) {
      const diff2 = readVarInt(this);
      const hasCount = diff2 & 1;
      this.diff = floor(diff2 / 2);
      this.count = 1;
      if (hasCount) {
        this.count = readVarUint(this) + 2;
      }
    }
    this.s += this.diff;
    this.count--;
    return this.s;
  }
};
var StringDecoder = class {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(uint8Array) {
    this.decoder = new UintOptRleDecoder(uint8Array);
    this.str = readVarString(this.decoder);
    this.spos = 0;
  }
  /**
   * @return {string}
   */
  read() {
    const end = this.spos + this.decoder.read();
    const res = this.str.slice(this.spos, end);
    this.spos = end;
    return res;
  }
};

// node_modules/lib0/webcrypto.js
var subtle = crypto.subtle;
var getRandomValues = crypto.getRandomValues.bind(crypto);

// node_modules/lib0/random.js
var uint32 = () => getRandomValues(new Uint32Array(1))[0];
var uuidv4Template = [1e7] + -1e3 + -4e3 + -8e3 + -1e11;
var uuidv4 = () => uuidv4Template.replace(
  /[018]/g,
  /** @param {number} c */
  (c) => (c ^ uint32() & 15 >> c / 4).toString(16)
);

// node_modules/lib0/time.js
var getUnixTime = Date.now;

// node_modules/lib0/promise.js
var create4 = (f) => (
  /** @type {Promise<T>} */
  new Promise(f)
);
var all = Promise.all.bind(Promise);

// node_modules/lib0/conditions.js
var undefinedToNull = (v) => v === void 0 ? null : v;

// node_modules/lib0/storage.js
var VarStoragePolyfill = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {string} key
   * @param {any} newValue
   */
  setItem(key, newValue) {
    this.map.set(key, newValue);
  }
  /**
   * @param {string} key
   */
  getItem(key) {
    return this.map.get(key);
  }
};
var _localStorage = new VarStoragePolyfill();
var usePolyfill = true;
try {
  if (typeof localStorage !== "undefined" && localStorage) {
    _localStorage = localStorage;
    usePolyfill = false;
  }
} catch (e2) {
}
var varStorage = _localStorage;

// node_modules/lib0/object.js
var assign = Object.assign;
var keys = Object.keys;
var forEach = (obj, f) => {
  for (const key in obj) {
    f(obj[key], key);
  }
};
var length2 = (obj) => keys(obj).length;
var isEmpty = (obj) => {
  for (const _k in obj) {
    return false;
  }
  return true;
};
var every = (obj, f) => {
  for (const key in obj) {
    if (!f(obj[key], key)) {
      return false;
    }
  }
  return true;
};
var hasProperty = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);
var equalFlat = (a, b) => a === b || length2(a) === length2(b) && every(a, (val, key) => (val !== void 0 || hasProperty(b, key)) && b[key] === val);

// node_modules/lib0/function.js
var callAll = (fs, args3, i2 = 0) => {
  try {
    for (; i2 < fs.length; i2++) {
      fs[i2](...args3);
    }
  } finally {
    if (i2 < fs.length) {
      callAll(fs, args3, i2 + 1);
    }
  }
};
var id = (a) => a;
var equalityStrict = (a, b) => a === b;
var equalityDeep = (a, b) => {
  if (a == null || b == null) {
    return equalityStrict(a, b);
  }
  if (a.constructor !== b.constructor) {
    return false;
  }
  if (a === b) {
    return true;
  }
  switch (a.constructor) {
    case ArrayBuffer:
      a = new Uint8Array(a);
      b = new Uint8Array(b);
    case Uint8Array: {
      if (a.byteLength !== b.byteLength) {
        return false;
      }
      for (let i2 = 0; i2 < a.length; i2++) {
        if (a[i2] !== b[i2]) {
          return false;
        }
      }
      break;
    }
    case Set: {
      if (a.size !== b.size) {
        return false;
      }
      for (const value of a) {
        if (!b.has(value)) {
          return false;
        }
      }
      break;
    }
    case Map: {
      if (a.size !== b.size) {
        return false;
      }
      for (const key of a.keys()) {
        if (!b.has(key) || !equalityDeep(a.get(key), b.get(key))) {
          return false;
        }
      }
      break;
    }
    case Object:
      if (length2(a) !== length2(b)) {
        return false;
      }
      for (const key in a) {
        if (!hasProperty(a, key) || !equalityDeep(a[key], b[key])) {
          return false;
        }
      }
      break;
    case Array:
      if (a.length !== b.length) {
        return false;
      }
      for (let i2 = 0; i2 < a.length; i2++) {
        if (!equalityDeep(a[i2], b[i2])) {
          return false;
        }
      }
      break;
    default:
      return false;
  }
  return true;
};
var isOneOf = (value, options) => options.includes(value);

// node_modules/lib0/environment.js
var isNode = typeof process !== "undefined" && process.release && /node|io\.js/.test(process.release.name) && Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]";
var isMac = typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
var params;
var args = [];
var computeParams = () => {
  if (params === void 0) {
    if (isNode) {
      params = create();
      const pargs = process.argv;
      let currParamName = null;
      for (let i2 = 0; i2 < pargs.length; i2++) {
        const parg = pargs[i2];
        if (parg[0] === "-") {
          if (currParamName !== null) {
            params.set(currParamName, "");
          }
          currParamName = parg;
        } else {
          if (currParamName !== null) {
            params.set(currParamName, parg);
            currParamName = null;
          } else {
            args.push(parg);
          }
        }
      }
      if (currParamName !== null) {
        params.set(currParamName, "");
      }
    } else if (typeof location === "object") {
      params = create();
      (location.search || "?").slice(1).split("&").forEach((kv) => {
        if (kv.length !== 0) {
          const [key, value] = kv.split("=");
          params.set(`--${fromCamelCase(key, "-")}`, value);
          params.set(`-${fromCamelCase(key, "-")}`, value);
        }
      });
    } else {
      params = create();
    }
  }
  return params;
};
var hasParam = (name) => computeParams().has(name);
var getVariable = (name) => isNode ? undefinedToNull(process.env[name.toUpperCase().replaceAll("-", "_")]) : undefinedToNull(varStorage.getItem(name));
var hasConf = (name) => hasParam("--" + name) || getVariable(name) !== null;
var production = hasConf("production");
var forceColor = isNode && isOneOf(process.env.FORCE_COLOR, ["true", "1", "2"]);
var supportsColor = !hasParam("no-colors") && (!isNode || process.stdout.isTTY || forceColor) && (!isNode || hasParam("color") || forceColor || getVariable("COLORTERM") !== null || (getVariable("TERM") || "").includes("color"));

// node_modules/lib0/buffer.js
var createUint8ArrayFromLen = (len) => new Uint8Array(len);
var copyUint8Array = (uint8Array) => {
  const newBuf = createUint8ArrayFromLen(uint8Array.byteLength);
  newBuf.set(uint8Array);
  return newBuf;
};

// node_modules/lib0/pair.js
var Pair = class {
  /**
   * @param {L} left
   * @param {R} right
   */
  constructor(left, right) {
    this.left = left;
    this.right = right;
  }
};
var create5 = (left, right) => new Pair(left, right);
var forEach2 = (arr, f) => arr.forEach((p) => f(p.left, p.right));

// node_modules/lib0/dom.js
var doc = (
  /** @type {Document} */
  typeof document !== "undefined" ? document : {}
);
var createElement = (name) => doc.createElement(name);
var createDocumentFragment = () => doc.createDocumentFragment();
var createTextNode = (text3) => doc.createTextNode(text3);
var domParser = (
  /** @type {DOMParser} */
  typeof DOMParser !== "undefined" ? new DOMParser() : null
);
var setAttributes = (el, attrs) => {
  forEach2(attrs, (key, value) => {
    if (value === false) {
      el.removeAttribute(key);
    } else if (value === true) {
      el.setAttribute(key, "");
    } else {
      el.setAttribute(key, value);
    }
  });
  return el;
};
var fragment = (children2) => {
  const fragment2 = createDocumentFragment();
  for (let i2 = 0; i2 < children2.length; i2++) {
    appendChild(fragment2, children2[i2]);
  }
  return fragment2;
};
var append = (parent, nodes) => {
  appendChild(parent, fragment(nodes));
  return parent;
};
var element = (name, attrs = [], children2 = []) => append(setAttributes(createElement(name), attrs), children2);
var text = createTextNode;
var mapToStyleString = (m) => map(m, (value, key) => `${key}:${value};`).join("");
var appendChild = (parent, child) => parent.appendChild(child);
var ELEMENT_NODE = doc.ELEMENT_NODE;
var TEXT_NODE = doc.TEXT_NODE;
var CDATA_SECTION_NODE = doc.CDATA_SECTION_NODE;
var COMMENT_NODE = doc.COMMENT_NODE;
var DOCUMENT_NODE = doc.DOCUMENT_NODE;
var DOCUMENT_TYPE_NODE = doc.DOCUMENT_TYPE_NODE;
var DOCUMENT_FRAGMENT_NODE = doc.DOCUMENT_FRAGMENT_NODE;

// node_modules/lib0/symbol.js
var create6 = Symbol;

// node_modules/lib0/logging.common.js
var BOLD = create6();
var UNBOLD = create6();
var BLUE = create6();
var GREY = create6();
var GREEN = create6();
var RED = create6();
var PURPLE = create6();
var ORANGE = create6();
var UNCOLOR = create6();
var computeNoColorLoggingArgs = (args3) => {
  var _a2;
  if (args3.length === 1 && ((_a2 = args3[0]) == null ? void 0 : _a2.constructor) === Function) {
    args3 = /** @type {Array<string|Symbol|Object|number>} */
    /** @type {[function]} */
    args3[0]();
  }
  const strBuilder = [];
  const logArgs = [];
  let i2 = 0;
  for (; i2 < args3.length; i2++) {
    const arg = args3[i2];
    if (arg === void 0) {
      strBuilder.push("undefined");
    } else if (arg.constructor === String || arg.constructor === Number) {
      strBuilder.push(arg);
    } else if (arg.constructor === Object) {
      logArgs.push(JSON.stringify(arg));
    }
  }
  return logArgs;
};
var lastLoggingTime = getUnixTime();

// node_modules/lib0/logging.js
var _browserStyleMap = {
  [BOLD]: create5("font-weight", "bold"),
  [UNBOLD]: create5("font-weight", "normal"),
  [BLUE]: create5("color", "blue"),
  [GREEN]: create5("color", "green"),
  [GREY]: create5("color", "grey"),
  [RED]: create5("color", "red"),
  [PURPLE]: create5("color", "purple"),
  [ORANGE]: create5("color", "orange"),
  // not well supported in chrome when debugging node with inspector - TODO: deprecate
  [UNCOLOR]: create5("color", "black")
};
var computeBrowserLoggingArgs = (args3) => {
  var _a2;
  if (args3.length === 1 && ((_a2 = args3[0]) == null ? void 0 : _a2.constructor) === Function) {
    args3 = /** @type {Array<string|Symbol|Object|number>} */
    /** @type {[function]} */
    args3[0]();
  }
  const strBuilder = [];
  const styles = [];
  const currentStyle = create();
  let logArgs = [];
  let i2 = 0;
  for (; i2 < args3.length; i2++) {
    const arg = args3[i2];
    const style = _browserStyleMap[arg];
    if (style !== void 0) {
      currentStyle.set(style.left, style.right);
    } else {
      if (arg === void 0) {
        break;
      }
      if (arg.constructor === String || arg.constructor === Number) {
        const style2 = mapToStyleString(currentStyle);
        if (i2 > 0 || style2.length > 0) {
          strBuilder.push("%c" + arg);
          styles.push(style2);
        } else {
          strBuilder.push(arg);
        }
      } else {
        break;
      }
    }
  }
  if (i2 > 0) {
    logArgs = styles;
    logArgs.unshift(strBuilder.join(""));
  }
  for (; i2 < args3.length; i2++) {
    const arg = args3[i2];
    if (!(arg instanceof Symbol)) {
      logArgs.push(arg);
    }
  }
  return logArgs;
};
var computeLoggingArgs = supportsColor ? computeBrowserLoggingArgs : computeNoColorLoggingArgs;
var print = (...args3) => {
  console.log(...computeLoggingArgs(args3));
  vconsoles.forEach((vc) => vc.print(args3));
};
var vconsoles = create2();

// node_modules/lib0/iterator.js
var createIterator = (next) => ({
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return this;
  },
  // @ts-ignore
  next
});
var iteratorFilter = (iterator, filter) => createIterator(() => {
  let res;
  do {
    res = iterator.next();
  } while (!res.done && !filter(res.value));
  return res;
});
var iteratorMap = (iterator, fmap) => createIterator(() => {
  const { done, value } = iterator.next();
  return { done, value: done ? void 0 : fmap(value) };
});

// node_modules/yjs/dist/yjs.mjs
var DeleteItem = class {
  /**
   * @param {number} clock
   * @param {number} len
   */
  constructor(clock, len) {
    this.clock = clock;
    this.len = len;
  }
};
var DeleteSet = class {
  constructor() {
    this.clients = /* @__PURE__ */ new Map();
  }
};
var iterateDeletedStructs = (transaction, ds, f) => ds.clients.forEach((deletes, clientid) => {
  const structs = (
    /** @type {Array<GC|Item>} */
    transaction.doc.store.clients.get(clientid)
  );
  for (let i2 = 0; i2 < deletes.length; i2++) {
    const del2 = deletes[i2];
    iterateStructs(transaction, structs, del2.clock, del2.len, f);
  }
});
var findIndexDS = (dis, clock) => {
  let left = 0;
  let right = dis.length - 1;
  while (left <= right) {
    const midindex = floor((left + right) / 2);
    const mid = dis[midindex];
    const midclock = mid.clock;
    if (midclock <= clock) {
      if (clock < midclock + mid.len) {
        return midindex;
      }
      left = midindex + 1;
    } else {
      right = midindex - 1;
    }
  }
  return null;
};
var isDeleted = (ds, id2) => {
  const dis = ds.clients.get(id2.client);
  return dis !== void 0 && findIndexDS(dis, id2.clock) !== null;
};
var sortAndMergeDeleteSet = (ds) => {
  ds.clients.forEach((dels) => {
    dels.sort((a, b) => a.clock - b.clock);
    let i2, j;
    for (i2 = 1, j = 1; i2 < dels.length; i2++) {
      const left = dels[j - 1];
      const right = dels[i2];
      if (left.clock + left.len >= right.clock) {
        left.len = max(left.len, right.clock + right.len - left.clock);
      } else {
        if (j < i2) {
          dels[j] = right;
        }
        j++;
      }
    }
    dels.length = j;
  });
};
var mergeDeleteSets = (dss) => {
  const merged = new DeleteSet();
  for (let dssI = 0; dssI < dss.length; dssI++) {
    dss[dssI].clients.forEach((delsLeft, client) => {
      if (!merged.clients.has(client)) {
        const dels = delsLeft.slice();
        for (let i2 = dssI + 1; i2 < dss.length; i2++) {
          appendTo(dels, dss[i2].clients.get(client) || []);
        }
        merged.clients.set(client, dels);
      }
    });
  }
  sortAndMergeDeleteSet(merged);
  return merged;
};
var addToDeleteSet = (ds, client, clock, length4) => {
  setIfUndefined(ds.clients, client, () => (
    /** @type {Array<DeleteItem>} */
    []
  )).push(new DeleteItem(clock, length4));
};
var createDeleteSet = () => new DeleteSet();
var createDeleteSetFromStructStore = (ss) => {
  const ds = createDeleteSet();
  ss.clients.forEach((structs, client) => {
    const dsitems = [];
    for (let i2 = 0; i2 < structs.length; i2++) {
      const struct = structs[i2];
      if (struct.deleted) {
        const clock = struct.id.clock;
        let len = struct.length;
        if (i2 + 1 < structs.length) {
          for (let next = structs[i2 + 1]; i2 + 1 < structs.length && next.deleted; next = structs[++i2 + 1]) {
            len += next.length;
          }
        }
        dsitems.push(new DeleteItem(clock, len));
      }
    }
    if (dsitems.length > 0) {
      ds.clients.set(client, dsitems);
    }
  });
  return ds;
};
var writeDeleteSet = (encoder2, ds) => {
  writeVarUint(encoder2.restEncoder, ds.clients.size);
  from(ds.clients.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, dsitems]) => {
    encoder2.resetDsCurVal();
    writeVarUint(encoder2.restEncoder, client);
    const len = dsitems.length;
    writeVarUint(encoder2.restEncoder, len);
    for (let i2 = 0; i2 < len; i2++) {
      const item = dsitems[i2];
      encoder2.writeDsClock(item.clock);
      encoder2.writeDsLen(item.len);
    }
  });
};
var readDeleteSet = (decoder2) => {
  const ds = new DeleteSet();
  const numClients = readVarUint(decoder2.restDecoder);
  for (let i2 = 0; i2 < numClients; i2++) {
    decoder2.resetDsCurVal();
    const client = readVarUint(decoder2.restDecoder);
    const numberOfDeletes = readVarUint(decoder2.restDecoder);
    if (numberOfDeletes > 0) {
      const dsField = setIfUndefined(ds.clients, client, () => (
        /** @type {Array<DeleteItem>} */
        []
      ));
      for (let i3 = 0; i3 < numberOfDeletes; i3++) {
        dsField.push(new DeleteItem(decoder2.readDsClock(), decoder2.readDsLen()));
      }
    }
  }
  return ds;
};
var readAndApplyDeleteSet = (decoder2, transaction, store) => {
  const unappliedDS = new DeleteSet();
  const numClients = readVarUint(decoder2.restDecoder);
  for (let i2 = 0; i2 < numClients; i2++) {
    decoder2.resetDsCurVal();
    const client = readVarUint(decoder2.restDecoder);
    const numberOfDeletes = readVarUint(decoder2.restDecoder);
    const structs = store.clients.get(client) || [];
    const state = getState(store, client);
    for (let i3 = 0; i3 < numberOfDeletes; i3++) {
      const clock = decoder2.readDsClock();
      const clockEnd = clock + decoder2.readDsLen();
      if (clock < state) {
        if (state < clockEnd) {
          addToDeleteSet(unappliedDS, client, state, clockEnd - state);
        }
        let index = findIndexSS(structs, clock);
        let struct = structs[index];
        if (!struct.deleted && struct.id.clock < clock) {
          structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));
          index++;
        }
        while (index < structs.length) {
          struct = structs[index++];
          if (struct.id.clock < clockEnd) {
            if (!struct.deleted) {
              if (clockEnd < struct.id.clock + struct.length) {
                structs.splice(index, 0, splitItem(transaction, struct, clockEnd - struct.id.clock));
              }
              struct.delete(transaction);
            }
          } else {
            break;
          }
        }
      } else {
        addToDeleteSet(unappliedDS, client, clock, clockEnd - clock);
      }
    }
  }
  if (unappliedDS.clients.size > 0) {
    const ds = new UpdateEncoderV2();
    writeVarUint(ds.restEncoder, 0);
    writeDeleteSet(ds, unappliedDS);
    return ds.toUint8Array();
  }
  return null;
};
var generateNewClientId = uint32;
var Doc = class extends ObservableV2 {
  /**
   * @param {DocOpts} opts configuration
   */
  constructor({ guid = uuidv4(), collectionid = null, gc = true, gcFilter = () => true, meta = null, autoLoad = false, shouldLoad = true } = {}) {
    super();
    this.gc = gc;
    this.gcFilter = gcFilter;
    this.clientID = generateNewClientId();
    this.guid = guid;
    this.collectionid = collectionid;
    this.share = /* @__PURE__ */ new Map();
    this.store = new StructStore();
    this._transaction = null;
    this._transactionCleanups = [];
    this.subdocs = /* @__PURE__ */ new Set();
    this._item = null;
    this.shouldLoad = shouldLoad;
    this.autoLoad = autoLoad;
    this.meta = meta;
    this.isLoaded = false;
    this.isSynced = false;
    this.whenLoaded = create4((resolve) => {
      this.on("load", () => {
        this.isLoaded = true;
        resolve(this);
      });
    });
    const provideSyncedPromise = () => create4((resolve) => {
      const eventHandler = (isSynced) => {
        if (isSynced === void 0 || isSynced === true) {
          this.off("sync", eventHandler);
          resolve();
        }
      };
      this.on("sync", eventHandler);
    });
    this.on("sync", (isSynced) => {
      if (isSynced === false && this.isSynced) {
        this.whenSynced = provideSyncedPromise();
      }
      this.isSynced = isSynced === void 0 || isSynced === true;
      if (this.isSynced && !this.isLoaded) {
        this.emit("load", [this]);
      }
    });
    this.whenSynced = provideSyncedPromise();
  }
  /**
   * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).
   *
   * `load()` might be used in the future to request any provider to load the most current data.
   *
   * It is safe to call `load()` multiple times.
   */
  load() {
    const item = this._item;
    if (item !== null && !this.shouldLoad) {
      transact(
        /** @type {any} */
        item.parent.doc,
        (transaction) => {
          transaction.subdocsLoaded.add(this);
        },
        null,
        true
      );
    }
    this.shouldLoad = true;
  }
  getSubdocs() {
    return this.subdocs;
  }
  getSubdocGuids() {
    return new Set(from(this.subdocs).map((doc2) => doc2.guid));
  }
  /**
   * Changes that happen inside of a transaction are bundled. This means that
   * the observer fires _after_ the transaction is finished and that all changes
   * that happened inside of the transaction are sent as one message to the
   * other peers.
   *
   * @template T
   * @param {function(Transaction):T} f The function that should be executed as a transaction
   * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin
   * @return T
   *
   * @public
   */
  transact(f, origin = null) {
    return transact(this, f, origin);
  }
  /**
   * Define a shared data type.
   *
   * Multiple calls of `y.get(name, TypeConstructor)` yield the same result
   * and do not overwrite each other. I.e.
   * `y.define(name, Y.Array) === y.define(name, Y.Array)`
   *
   * After this method is called, the type is also available on `y.share.get(name)`.
   *
   * *Best Practices:*
   * Define all types right after the Yjs instance is created and store them in a separate object.
   * Also use the typed methods `getText(name)`, `getArray(name)`, ..
   *
   * @template {typeof AbstractType<any>} Type
   * @example
   *   const y = new Y(..)
   *   const appState = {
   *     document: y.getText('document')
   *     comments: y.getArray('comments')
   *   }
   *
   * @param {string} name
   * @param {Type} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...
   * @return {InstanceType<Type>} The created type. Constructed with TypeConstructor
   *
   * @public
   */
  get(name, TypeConstructor = (
    /** @type {any} */
    AbstractType
  )) {
    const type = setIfUndefined(this.share, name, () => {
      const t2 = new TypeConstructor();
      t2._integrate(this, null);
      return t2;
    });
    const Constr = type.constructor;
    if (TypeConstructor !== AbstractType && Constr !== TypeConstructor) {
      if (Constr === AbstractType) {
        const t2 = new TypeConstructor();
        t2._map = type._map;
        type._map.forEach(
          /** @param {Item?} n */
          (n) => {
            for (; n !== null; n = n.left) {
              n.parent = t2;
            }
          }
        );
        t2._start = type._start;
        for (let n = t2._start; n !== null; n = n.right) {
          n.parent = t2;
        }
        t2._length = type._length;
        this.share.set(name, t2);
        t2._integrate(this, null);
        return (
          /** @type {InstanceType<Type>} */
          t2
        );
      } else {
        throw new Error(`Type with the name ${name} has already been defined with a different constructor`);
      }
    }
    return (
      /** @type {InstanceType<Type>} */
      type
    );
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YArray<T>}
   *
   * @public
   */
  getArray(name = "") {
    return (
      /** @type {YArray<T>} */
      this.get(name, YArray)
    );
  }
  /**
   * @param {string} [name]
   * @return {YText}
   *
   * @public
   */
  getText(name = "") {
    return this.get(name, YText);
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YMap<T>}
   *
   * @public
   */
  getMap(name = "") {
    return (
      /** @type {YMap<T>} */
      this.get(name, YMap)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlElement}
   *
   * @public
   */
  getXmlElement(name = "") {
    return (
      /** @type {YXmlElement<{[key:string]:string}>} */
      this.get(name, YXmlElement)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlFragment}
   *
   * @public
   */
  getXmlFragment(name = "") {
    return this.get(name, YXmlFragment);
  }
  /**
   * Converts the entire document into a js object, recursively traversing each yjs type
   * Doesn't log types that have not been defined (using ydoc.getType(..)).
   *
   * @deprecated Do not use this method and rather call toJSON directly on the shared types.
   *
   * @return {Object<string, any>}
   */
  toJSON() {
    const doc2 = {};
    this.share.forEach((value, key) => {
      doc2[key] = value.toJSON();
    });
    return doc2;
  }
  /**
   * Emit `destroy` event and unregister all event handlers.
   */
  destroy() {
    from(this.subdocs).forEach((subdoc) => subdoc.destroy());
    const item = this._item;
    if (item !== null) {
      this._item = null;
      const content = (
        /** @type {ContentDoc} */
        item.content
      );
      content.doc = new Doc({ guid: this.guid, ...content.opts, shouldLoad: false });
      content.doc._item = item;
      transact(
        /** @type {any} */
        item.parent.doc,
        (transaction) => {
          const doc2 = content.doc;
          if (!item.deleted) {
            transaction.subdocsAdded.add(doc2);
          }
          transaction.subdocsRemoved.add(this);
        },
        null,
        true
      );
    }
    this.emit("destroyed", [true]);
    this.emit("destroy", [this]);
    super.destroy();
  }
};
var DSDecoderV1 = class {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(decoder2) {
    this.restDecoder = decoder2;
  }
  resetDsCurVal() {
  }
  /**
   * @return {number}
   */
  readDsClock() {
    return readVarUint(this.restDecoder);
  }
  /**
   * @return {number}
   */
  readDsLen() {
    return readVarUint(this.restDecoder);
  }
};
var UpdateDecoderV1 = class extends DSDecoderV1 {
  /**
   * @return {ID}
   */
  readLeftID() {
    return createID(readVarUint(this.restDecoder), readVarUint(this.restDecoder));
  }
  /**
   * @return {ID}
   */
  readRightID() {
    return createID(readVarUint(this.restDecoder), readVarUint(this.restDecoder));
  }
  /**
   * Read the next client id.
   * Use this in favor of readID whenever possible to reduce the number of objects created.
   */
  readClient() {
    return readVarUint(this.restDecoder);
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readInfo() {
    return readUint8(this.restDecoder);
  }
  /**
   * @return {string}
   */
  readString() {
    return readVarString(this.restDecoder);
  }
  /**
   * @return {boolean} isKey
   */
  readParentInfo() {
    return readVarUint(this.restDecoder) === 1;
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readTypeRef() {
    return readVarUint(this.restDecoder);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @return {number} len
   */
  readLen() {
    return readVarUint(this.restDecoder);
  }
  /**
   * @return {any}
   */
  readAny() {
    return readAny(this.restDecoder);
  }
  /**
   * @return {Uint8Array}
   */
  readBuf() {
    return copyUint8Array(readVarUint8Array(this.restDecoder));
  }
  /**
   * Legacy implementation uses JSON parse. We use any-decoding in v2.
   *
   * @return {any}
   */
  readJSON() {
    return JSON.parse(readVarString(this.restDecoder));
  }
  /**
   * @return {string}
   */
  readKey() {
    return readVarString(this.restDecoder);
  }
};
var DSDecoderV2 = class {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(decoder2) {
    this.dsCurrVal = 0;
    this.restDecoder = decoder2;
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  /**
   * @return {number}
   */
  readDsClock() {
    this.dsCurrVal += readVarUint(this.restDecoder);
    return this.dsCurrVal;
  }
  /**
   * @return {number}
   */
  readDsLen() {
    const diff2 = readVarUint(this.restDecoder) + 1;
    this.dsCurrVal += diff2;
    return diff2;
  }
};
var UpdateDecoderV2 = class extends DSDecoderV2 {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(decoder2) {
    super(decoder2);
    this.keys = [];
    readVarUint(decoder2);
    this.keyClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder2));
    this.clientDecoder = new UintOptRleDecoder(readVarUint8Array(decoder2));
    this.leftClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder2));
    this.rightClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder2));
    this.infoDecoder = new RleDecoder(readVarUint8Array(decoder2), readUint8);
    this.stringDecoder = new StringDecoder(readVarUint8Array(decoder2));
    this.parentInfoDecoder = new RleDecoder(readVarUint8Array(decoder2), readUint8);
    this.typeRefDecoder = new UintOptRleDecoder(readVarUint8Array(decoder2));
    this.lenDecoder = new UintOptRleDecoder(readVarUint8Array(decoder2));
  }
  /**
   * @return {ID}
   */
  readLeftID() {
    return new ID(this.clientDecoder.read(), this.leftClockDecoder.read());
  }
  /**
   * @return {ID}
   */
  readRightID() {
    return new ID(this.clientDecoder.read(), this.rightClockDecoder.read());
  }
  /**
   * Read the next client id.
   * Use this in favor of readID whenever possible to reduce the number of objects created.
   */
  readClient() {
    return this.clientDecoder.read();
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readInfo() {
    return (
      /** @type {number} */
      this.infoDecoder.read()
    );
  }
  /**
   * @return {string}
   */
  readString() {
    return this.stringDecoder.read();
  }
  /**
   * @return {boolean}
   */
  readParentInfo() {
    return this.parentInfoDecoder.read() === 1;
  }
  /**
   * @return {number} An unsigned 8-bit integer
   */
  readTypeRef() {
    return this.typeRefDecoder.read();
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @return {number}
   */
  readLen() {
    return this.lenDecoder.read();
  }
  /**
   * @return {any}
   */
  readAny() {
    return readAny(this.restDecoder);
  }
  /**
   * @return {Uint8Array}
   */
  readBuf() {
    return readVarUint8Array(this.restDecoder);
  }
  /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @return {any}
   */
  readJSON() {
    return readAny(this.restDecoder);
  }
  /**
   * @return {string}
   */
  readKey() {
    const keyClock = this.keyClockDecoder.read();
    if (keyClock < this.keys.length) {
      return this.keys[keyClock];
    } else {
      const key = this.stringDecoder.read();
      this.keys.push(key);
      return key;
    }
  }
};
var DSEncoderV1 = class {
  constructor() {
    this.restEncoder = createEncoder();
  }
  toUint8Array() {
    return toUint8Array(this.restEncoder);
  }
  resetDsCurVal() {
  }
  /**
   * @param {number} clock
   */
  writeDsClock(clock) {
    writeVarUint(this.restEncoder, clock);
  }
  /**
   * @param {number} len
   */
  writeDsLen(len) {
    writeVarUint(this.restEncoder, len);
  }
};
var UpdateEncoderV1 = class extends DSEncoderV1 {
  /**
   * @param {ID} id
   */
  writeLeftID(id2) {
    writeVarUint(this.restEncoder, id2.client);
    writeVarUint(this.restEncoder, id2.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(id2) {
    writeVarUint(this.restEncoder, id2.client);
    writeVarUint(this.restEncoder, id2.clock);
  }
  /**
   * Use writeClient and writeClock instead of writeID if possible.
   * @param {number} client
   */
  writeClient(client) {
    writeVarUint(this.restEncoder, client);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(info) {
    writeUint8(this.restEncoder, info);
  }
  /**
   * @param {string} s
   */
  writeString(s2) {
    writeVarString(this.restEncoder, s2);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(isYKey) {
    writeVarUint(this.restEncoder, isYKey ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(info) {
    writeVarUint(this.restEncoder, info);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(len) {
    writeVarUint(this.restEncoder, len);
  }
  /**
   * @param {any} any
   */
  writeAny(any2) {
    writeAny(this.restEncoder, any2);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(buf) {
    writeVarUint8Array(this.restEncoder, buf);
  }
  /**
   * @param {any} embed
   */
  writeJSON(embed) {
    writeVarString(this.restEncoder, JSON.stringify(embed));
  }
  /**
   * @param {string} key
   */
  writeKey(key) {
    writeVarString(this.restEncoder, key);
  }
};
var DSEncoderV2 = class {
  constructor() {
    this.restEncoder = createEncoder();
    this.dsCurrVal = 0;
  }
  toUint8Array() {
    return toUint8Array(this.restEncoder);
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  /**
   * @param {number} clock
   */
  writeDsClock(clock) {
    const diff2 = clock - this.dsCurrVal;
    this.dsCurrVal = clock;
    writeVarUint(this.restEncoder, diff2);
  }
  /**
   * @param {number} len
   */
  writeDsLen(len) {
    if (len === 0) {
      unexpectedCase();
    }
    writeVarUint(this.restEncoder, len - 1);
    this.dsCurrVal += len;
  }
};
var UpdateEncoderV2 = class extends DSEncoderV2 {
  constructor() {
    super();
    this.keyMap = /* @__PURE__ */ new Map();
    this.keyClock = 0;
    this.keyClockEncoder = new IntDiffOptRleEncoder();
    this.clientEncoder = new UintOptRleEncoder();
    this.leftClockEncoder = new IntDiffOptRleEncoder();
    this.rightClockEncoder = new IntDiffOptRleEncoder();
    this.infoEncoder = new RleEncoder(writeUint8);
    this.stringEncoder = new StringEncoder();
    this.parentInfoEncoder = new RleEncoder(writeUint8);
    this.typeRefEncoder = new UintOptRleEncoder();
    this.lenEncoder = new UintOptRleEncoder();
  }
  toUint8Array() {
    const encoder2 = createEncoder();
    writeVarUint(encoder2, 0);
    writeVarUint8Array(encoder2, this.keyClockEncoder.toUint8Array());
    writeVarUint8Array(encoder2, this.clientEncoder.toUint8Array());
    writeVarUint8Array(encoder2, this.leftClockEncoder.toUint8Array());
    writeVarUint8Array(encoder2, this.rightClockEncoder.toUint8Array());
    writeVarUint8Array(encoder2, toUint8Array(this.infoEncoder));
    writeVarUint8Array(encoder2, this.stringEncoder.toUint8Array());
    writeVarUint8Array(encoder2, toUint8Array(this.parentInfoEncoder));
    writeVarUint8Array(encoder2, this.typeRefEncoder.toUint8Array());
    writeVarUint8Array(encoder2, this.lenEncoder.toUint8Array());
    writeUint8Array(encoder2, toUint8Array(this.restEncoder));
    return toUint8Array(encoder2);
  }
  /**
   * @param {ID} id
   */
  writeLeftID(id2) {
    this.clientEncoder.write(id2.client);
    this.leftClockEncoder.write(id2.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(id2) {
    this.clientEncoder.write(id2.client);
    this.rightClockEncoder.write(id2.clock);
  }
  /**
   * @param {number} client
   */
  writeClient(client) {
    this.clientEncoder.write(client);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(info) {
    this.infoEncoder.write(info);
  }
  /**
   * @param {string} s
   */
  writeString(s2) {
    this.stringEncoder.write(s2);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(isYKey) {
    this.parentInfoEncoder.write(isYKey ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(info) {
    this.typeRefEncoder.write(info);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(len) {
    this.lenEncoder.write(len);
  }
  /**
   * @param {any} any
   */
  writeAny(any2) {
    writeAny(this.restEncoder, any2);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(buf) {
    writeVarUint8Array(this.restEncoder, buf);
  }
  /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @param {any} embed
   */
  writeJSON(embed) {
    writeAny(this.restEncoder, embed);
  }
  /**
   * Property keys are often reused. For example, in y-prosemirror the key `bold` might
   * occur very often. For a 3d application, the key `position` might occur very often.
   *
   * We cache these keys in a Map and refer to them via a unique number.
   *
   * @param {string} key
   */
  writeKey(key) {
    const clock = this.keyMap.get(key);
    if (clock === void 0) {
      this.keyClockEncoder.write(this.keyClock++);
      this.stringEncoder.write(key);
    } else {
      this.keyClockEncoder.write(clock);
    }
  }
};
var writeStructs = (encoder2, structs, client, clock) => {
  clock = max(clock, structs[0].id.clock);
  const startNewStructs = findIndexSS(structs, clock);
  writeVarUint(encoder2.restEncoder, structs.length - startNewStructs);
  encoder2.writeClient(client);
  writeVarUint(encoder2.restEncoder, clock);
  const firstStruct = structs[startNewStructs];
  firstStruct.write(encoder2, clock - firstStruct.id.clock);
  for (let i2 = startNewStructs + 1; i2 < structs.length; i2++) {
    structs[i2].write(encoder2, 0);
  }
};
var writeClientsStructs = (encoder2, store, _sm) => {
  const sm = /* @__PURE__ */ new Map();
  _sm.forEach((clock, client) => {
    if (getState(store, client) > clock) {
      sm.set(client, clock);
    }
  });
  getStateVector(store).forEach((_clock, client) => {
    if (!_sm.has(client)) {
      sm.set(client, 0);
    }
  });
  writeVarUint(encoder2.restEncoder, sm.size);
  from(sm.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, clock]) => {
    writeStructs(
      encoder2,
      /** @type {Array<GC|Item>} */
      store.clients.get(client),
      client,
      clock
    );
  });
};
var readClientsStructRefs = (decoder2, doc2) => {
  const clientRefs = create();
  const numOfStateUpdates = readVarUint(decoder2.restDecoder);
  for (let i2 = 0; i2 < numOfStateUpdates; i2++) {
    const numberOfStructs = readVarUint(decoder2.restDecoder);
    const refs = new Array(numberOfStructs);
    const client = decoder2.readClient();
    let clock = readVarUint(decoder2.restDecoder);
    clientRefs.set(client, { i: 0, refs });
    for (let i3 = 0; i3 < numberOfStructs; i3++) {
      const info = decoder2.readInfo();
      switch (BITS5 & info) {
        case 0: {
          const len = decoder2.readLen();
          refs[i3] = new GC(createID(client, clock), len);
          clock += len;
          break;
        }
        case 10: {
          const len = readVarUint(decoder2.restDecoder);
          refs[i3] = new Skip(createID(client, clock), len);
          clock += len;
          break;
        }
        default: {
          const cantCopyParentInfo = (info & (BIT7 | BIT8)) === 0;
          const struct = new Item(
            createID(client, clock),
            null,
            // leftd
            (info & BIT8) === BIT8 ? decoder2.readLeftID() : null,
            // origin
            null,
            // right
            (info & BIT7) === BIT7 ? decoder2.readRightID() : null,
            // right origin
            cantCopyParentInfo ? decoder2.readParentInfo() ? doc2.get(decoder2.readString()) : decoder2.readLeftID() : null,
            // parent
            cantCopyParentInfo && (info & BIT6) === BIT6 ? decoder2.readString() : null,
            // parentSub
            readItemContent(decoder2, info)
            // item content
          );
          refs[i3] = struct;
          clock += struct.length;
        }
      }
    }
  }
  return clientRefs;
};
var integrateStructs = (transaction, store, clientsStructRefs) => {
  const stack = [];
  let clientsStructRefsIds = from(clientsStructRefs.keys()).sort((a, b) => a - b);
  if (clientsStructRefsIds.length === 0) {
    return null;
  }
  const getNextStructTarget = () => {
    if (clientsStructRefsIds.length === 0) {
      return null;
    }
    let nextStructsTarget = (
      /** @type {{i:number,refs:Array<GC|Item>}} */
      clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1])
    );
    while (nextStructsTarget.refs.length === nextStructsTarget.i) {
      clientsStructRefsIds.pop();
      if (clientsStructRefsIds.length > 0) {
        nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */
        clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]);
      } else {
        return null;
      }
    }
    return nextStructsTarget;
  };
  let curStructsTarget = getNextStructTarget();
  if (curStructsTarget === null) {
    return null;
  }
  const restStructs = new StructStore();
  const missingSV = /* @__PURE__ */ new Map();
  const updateMissingSv = (client, clock) => {
    const mclock = missingSV.get(client);
    if (mclock == null || mclock > clock) {
      missingSV.set(client, clock);
    }
  };
  let stackHead = (
    /** @type {any} */
    curStructsTarget.refs[
      /** @type {any} */
      curStructsTarget.i++
    ]
  );
  const state = /* @__PURE__ */ new Map();
  const addStackToRestSS = () => {
    for (const item of stack) {
      const client = item.id.client;
      const unapplicableItems = clientsStructRefs.get(client);
      if (unapplicableItems) {
        unapplicableItems.i--;
        restStructs.clients.set(client, unapplicableItems.refs.slice(unapplicableItems.i));
        clientsStructRefs.delete(client);
        unapplicableItems.i = 0;
        unapplicableItems.refs = [];
      } else {
        restStructs.clients.set(client, [item]);
      }
      clientsStructRefsIds = clientsStructRefsIds.filter((c) => c !== client);
    }
    stack.length = 0;
  };
  while (true) {
    if (stackHead.constructor !== Skip) {
      const localClock = setIfUndefined(state, stackHead.id.client, () => getState(store, stackHead.id.client));
      const offset = localClock - stackHead.id.clock;
      if (offset < 0) {
        stack.push(stackHead);
        updateMissingSv(stackHead.id.client, stackHead.id.clock - 1);
        addStackToRestSS();
      } else {
        const missing = stackHead.getMissing(transaction, store);
        if (missing !== null) {
          stack.push(stackHead);
          const structRefs = clientsStructRefs.get(
            /** @type {number} */
            missing
          ) || { refs: [], i: 0 };
          if (structRefs.refs.length === structRefs.i) {
            updateMissingSv(
              /** @type {number} */
              missing,
              getState(store, missing)
            );
            addStackToRestSS();
          } else {
            stackHead = structRefs.refs[structRefs.i++];
            continue;
          }
        } else if (offset === 0 || offset < stackHead.length) {
          stackHead.integrate(transaction, offset);
          state.set(stackHead.id.client, stackHead.id.clock + stackHead.length);
        }
      }
    }
    if (stack.length > 0) {
      stackHead = /** @type {GC|Item} */
      stack.pop();
    } else if (curStructsTarget !== null && curStructsTarget.i < curStructsTarget.refs.length) {
      stackHead = /** @type {GC|Item} */
      curStructsTarget.refs[curStructsTarget.i++];
    } else {
      curStructsTarget = getNextStructTarget();
      if (curStructsTarget === null) {
        break;
      } else {
        stackHead = /** @type {GC|Item} */
        curStructsTarget.refs[curStructsTarget.i++];
      }
    }
  }
  if (restStructs.clients.size > 0) {
    const encoder2 = new UpdateEncoderV2();
    writeClientsStructs(encoder2, restStructs, /* @__PURE__ */ new Map());
    writeVarUint(encoder2.restEncoder, 0);
    return { missing: missingSV, update: encoder2.toUint8Array() };
  }
  return null;
};
var writeStructsFromTransaction = (encoder2, transaction) => writeClientsStructs(encoder2, transaction.doc.store, transaction.beforeState);
var readUpdateV2 = (decoder2, ydoc, transactionOrigin, structDecoder = new UpdateDecoderV2(decoder2)) => transact(ydoc, (transaction) => {
  transaction.local = false;
  let retry = false;
  const doc2 = transaction.doc;
  const store = doc2.store;
  const ss = readClientsStructRefs(structDecoder, doc2);
  const restStructs = integrateStructs(transaction, store, ss);
  const pending = store.pendingStructs;
  if (pending) {
    for (const [client, clock] of pending.missing) {
      if (clock < getState(store, client)) {
        retry = true;
        break;
      }
    }
    if (restStructs) {
      for (const [client, clock] of restStructs.missing) {
        const mclock = pending.missing.get(client);
        if (mclock == null || mclock > clock) {
          pending.missing.set(client, clock);
        }
      }
      pending.update = mergeUpdatesV2([pending.update, restStructs.update]);
    }
  } else {
    store.pendingStructs = restStructs;
  }
  const dsRest = readAndApplyDeleteSet(structDecoder, transaction, store);
  if (store.pendingDs) {
    const pendingDSUpdate = new UpdateDecoderV2(createDecoder(store.pendingDs));
    readVarUint(pendingDSUpdate.restDecoder);
    const dsRest2 = readAndApplyDeleteSet(pendingDSUpdate, transaction, store);
    if (dsRest && dsRest2) {
      store.pendingDs = mergeUpdatesV2([dsRest, dsRest2]);
    } else {
      store.pendingDs = dsRest || dsRest2;
    }
  } else {
    store.pendingDs = dsRest;
  }
  if (retry) {
    const update2 = (
      /** @type {{update: Uint8Array}} */
      store.pendingStructs.update
    );
    store.pendingStructs = null;
    applyUpdateV2(transaction.doc, update2);
  }
}, transactionOrigin, false);
var applyUpdateV2 = (ydoc, update2, transactionOrigin, YDecoder = UpdateDecoderV2) => {
  const decoder2 = createDecoder(update2);
  readUpdateV2(decoder2, ydoc, transactionOrigin, new YDecoder(decoder2));
};
var applyUpdate = (ydoc, update2, transactionOrigin) => applyUpdateV2(ydoc, update2, transactionOrigin, UpdateDecoderV1);
var writeStateAsUpdate = (encoder2, doc2, targetStateVector = /* @__PURE__ */ new Map()) => {
  writeClientsStructs(encoder2, doc2.store, targetStateVector);
  writeDeleteSet(encoder2, createDeleteSetFromStructStore(doc2.store));
};
var encodeStateAsUpdateV2 = (doc2, encodedTargetStateVector = new Uint8Array([0]), encoder2 = new UpdateEncoderV2()) => {
  const targetStateVector = decodeStateVector(encodedTargetStateVector);
  writeStateAsUpdate(encoder2, doc2, targetStateVector);
  const updates = [encoder2.toUint8Array()];
  if (doc2.store.pendingDs) {
    updates.push(doc2.store.pendingDs);
  }
  if (doc2.store.pendingStructs) {
    updates.push(diffUpdateV2(doc2.store.pendingStructs.update, encodedTargetStateVector));
  }
  if (updates.length > 1) {
    if (encoder2.constructor === UpdateEncoderV1) {
      return mergeUpdates(updates.map((update2, i2) => i2 === 0 ? update2 : convertUpdateFormatV2ToV1(update2)));
    } else if (encoder2.constructor === UpdateEncoderV2) {
      return mergeUpdatesV2(updates);
    }
  }
  return updates[0];
};
var encodeStateAsUpdate = (doc2, encodedTargetStateVector) => encodeStateAsUpdateV2(doc2, encodedTargetStateVector, new UpdateEncoderV1());
var readStateVector = (decoder2) => {
  const ss = /* @__PURE__ */ new Map();
  const ssLength = readVarUint(decoder2.restDecoder);
  for (let i2 = 0; i2 < ssLength; i2++) {
    const client = readVarUint(decoder2.restDecoder);
    const clock = readVarUint(decoder2.restDecoder);
    ss.set(client, clock);
  }
  return ss;
};
var decodeStateVector = (decodedState) => readStateVector(new DSDecoderV1(createDecoder(decodedState)));
var writeStateVector = (encoder2, sv) => {
  writeVarUint(encoder2.restEncoder, sv.size);
  from(sv.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, clock]) => {
    writeVarUint(encoder2.restEncoder, client);
    writeVarUint(encoder2.restEncoder, clock);
  });
  return encoder2;
};
var writeDocumentStateVector = (encoder2, doc2) => writeStateVector(encoder2, getStateVector(doc2.store));
var encodeStateVectorV2 = (doc2, encoder2 = new DSEncoderV2()) => {
  if (doc2 instanceof Map) {
    writeStateVector(encoder2, doc2);
  } else {
    writeDocumentStateVector(encoder2, doc2);
  }
  return encoder2.toUint8Array();
};
var encodeStateVector = (doc2) => encodeStateVectorV2(doc2, new DSEncoderV1());
var EventHandler = class {
  constructor() {
    this.l = [];
  }
};
var createEventHandler = () => new EventHandler();
var addEventHandlerListener = (eventHandler, f) => eventHandler.l.push(f);
var removeEventHandlerListener = (eventHandler, f) => {
  const l = eventHandler.l;
  const len = l.length;
  eventHandler.l = l.filter((g) => f !== g);
  if (len === eventHandler.l.length) {
    console.error("[yjs] Tried to remove event handler that doesn't exist.");
  }
};
var callEventHandlerListeners = (eventHandler, arg0, arg1) => callAll(eventHandler.l, [arg0, arg1]);
var ID = class {
  /**
   * @param {number} client client id
   * @param {number} clock unique per client id, continuous number
   */
  constructor(client, clock) {
    this.client = client;
    this.clock = clock;
  }
};
var compareIDs = (a, b) => a === b || a !== null && b !== null && a.client === b.client && a.clock === b.clock;
var createID = (client, clock) => new ID(client, clock);
var findRootTypeKey = (type) => {
  for (const [key, value] of type.doc.share.entries()) {
    if (value === type) {
      return key;
    }
  }
  throw unexpectedCase();
};
var PermanentUserData = class {
  /**
   * @param {Doc} doc
   * @param {YMap<any>} [storeType]
   */
  constructor(doc2, storeType = doc2.getMap("users")) {
    const dss = /* @__PURE__ */ new Map();
    this.yusers = storeType;
    this.doc = doc2;
    this.clients = /* @__PURE__ */ new Map();
    this.dss = dss;
    const initUser = (user, userDescription) => {
      const ds = user.get("ds");
      const ids = user.get("ids");
      const addClientId = (
        /** @param {number} clientid */
        (clientid) => this.clients.set(clientid, userDescription)
      );
      ds.observe(
        /** @param {YArrayEvent<any>} event */
        (event) => {
          event.changes.added.forEach((item) => {
            item.content.getContent().forEach((encodedDs) => {
              if (encodedDs instanceof Uint8Array) {
                this.dss.set(userDescription, mergeDeleteSets([this.dss.get(userDescription) || createDeleteSet(), readDeleteSet(new DSDecoderV1(createDecoder(encodedDs)))]));
              }
            });
          });
        }
      );
      this.dss.set(userDescription, mergeDeleteSets(ds.map((encodedDs) => readDeleteSet(new DSDecoderV1(createDecoder(encodedDs))))));
      ids.observe(
        /** @param {YArrayEvent<any>} event */
        (event) => event.changes.added.forEach((item) => item.content.getContent().forEach(addClientId))
      );
      ids.forEach(addClientId);
    };
    storeType.observe((event) => {
      event.keysChanged.forEach(
        (userDescription) => initUser(storeType.get(userDescription), userDescription)
      );
    });
    storeType.forEach(initUser);
  }
  /**
   * @param {Doc} doc
   * @param {number} clientid
   * @param {string} userDescription
   * @param {Object} conf
   * @param {function(Transaction, DeleteSet):boolean} [conf.filter]
   */
  setUserMapping(doc2, clientid, userDescription, { filter = () => true } = {}) {
    const users = this.yusers;
    let user = users.get(userDescription);
    if (!user) {
      user = new YMap();
      user.set("ids", new YArray());
      user.set("ds", new YArray());
      users.set(userDescription, user);
    }
    user.get("ids").push([clientid]);
    users.observe((_event) => {
      setTimeout(() => {
        const userOverwrite = users.get(userDescription);
        if (userOverwrite !== user) {
          user = userOverwrite;
          this.clients.forEach((_userDescription, clientid2) => {
            if (userDescription === _userDescription) {
              user.get("ids").push([clientid2]);
            }
          });
          const encoder2 = new DSEncoderV1();
          const ds = this.dss.get(userDescription);
          if (ds) {
            writeDeleteSet(encoder2, ds);
            user.get("ds").push([encoder2.toUint8Array()]);
          }
        }
      }, 0);
    });
    doc2.on(
      "afterTransaction",
      /** @param {Transaction} transaction */
      (transaction) => {
        setTimeout(() => {
          const yds = user.get("ds");
          const ds = transaction.deleteSet;
          if (transaction.local && ds.clients.size > 0 && filter(transaction, ds)) {
            const encoder2 = new DSEncoderV1();
            writeDeleteSet(encoder2, ds);
            yds.push([encoder2.toUint8Array()]);
          }
        });
      }
    );
  }
  /**
   * @param {number} clientid
   * @return {any}
   */
  getUserByClientId(clientid) {
    return this.clients.get(clientid) || null;
  }
  /**
   * @param {ID} id
   * @return {string | null}
   */
  getUserByDeletedId(id2) {
    for (const [userDescription, ds] of this.dss.entries()) {
      if (isDeleted(ds, id2)) {
        return userDescription;
      }
    }
    return null;
  }
};
var RelativePosition = class {
  /**
   * @param {ID|null} type
   * @param {string|null} tname
   * @param {ID|null} item
   * @param {number} assoc
   */
  constructor(type, tname, item, assoc = 0) {
    this.type = type;
    this.tname = tname;
    this.item = item;
    this.assoc = assoc;
  }
};
var createRelativePositionFromJSON = (json) => new RelativePosition(json.type == null ? null : createID(json.type.client, json.type.clock), json.tname || null, json.item == null ? null : createID(json.item.client, json.item.clock), json.assoc == null ? 0 : json.assoc);
var AbsolutePosition = class {
  /**
   * @param {AbstractType<any>} type
   * @param {number} index
   * @param {number} [assoc]
   */
  constructor(type, index, assoc = 0) {
    this.type = type;
    this.index = index;
    this.assoc = assoc;
  }
};
var createAbsolutePosition = (type, index, assoc = 0) => new AbsolutePosition(type, index, assoc);
var createRelativePosition = (type, item, assoc) => {
  let typeid = null;
  let tname = null;
  if (type._item === null) {
    tname = findRootTypeKey(type);
  } else {
    typeid = createID(type._item.id.client, type._item.id.clock);
  }
  return new RelativePosition(typeid, tname, item, assoc);
};
var createRelativePositionFromTypeIndex = (type, index, assoc = 0) => {
  let t2 = type._start;
  if (assoc < 0) {
    if (index === 0) {
      return createRelativePosition(type, null, assoc);
    }
    index--;
  }
  while (t2 !== null) {
    if (!t2.deleted && t2.countable) {
      if (t2.length > index) {
        return createRelativePosition(type, createID(t2.id.client, t2.id.clock + index), assoc);
      }
      index -= t2.length;
    }
    if (t2.right === null && assoc < 0) {
      return createRelativePosition(type, t2.lastId, assoc);
    }
    t2 = t2.right;
  }
  return createRelativePosition(type, null, assoc);
};
var createAbsolutePositionFromRelativePosition = (rpos, doc2) => {
  const store = doc2.store;
  const rightID = rpos.item;
  const typeID = rpos.type;
  const tname = rpos.tname;
  const assoc = rpos.assoc;
  let type = null;
  let index = 0;
  if (rightID !== null) {
    if (getState(store, rightID.client) <= rightID.clock) {
      return null;
    }
    const res = followRedone(store, rightID);
    const right = res.item;
    if (!(right instanceof Item)) {
      return null;
    }
    type = /** @type {AbstractType<any>} */
    right.parent;
    if (type._item === null || !type._item.deleted) {
      index = right.deleted || !right.countable ? 0 : res.diff + (assoc >= 0 ? 0 : 1);
      let n = right.left;
      while (n !== null) {
        if (!n.deleted && n.countable) {
          index += n.length;
        }
        n = n.left;
      }
    }
  } else {
    if (tname !== null) {
      type = doc2.get(tname);
    } else if (typeID !== null) {
      if (getState(store, typeID.client) <= typeID.clock) {
        return null;
      }
      const { item } = followRedone(store, typeID);
      if (item instanceof Item && item.content instanceof ContentType) {
        type = item.content.type;
      } else {
        return null;
      }
    } else {
      throw unexpectedCase();
    }
    if (assoc >= 0) {
      index = type._length;
    } else {
      index = 0;
    }
  }
  return createAbsolutePosition(type, index, rpos.assoc);
};
var compareRelativePositions = (a, b) => a === b || a !== null && b !== null && a.tname === b.tname && compareIDs(a.item, b.item) && compareIDs(a.type, b.type) && a.assoc === b.assoc;
var Snapshot = class {
  /**
   * @param {DeleteSet} ds
   * @param {Map<number,number>} sv state map
   */
  constructor(ds, sv) {
    this.ds = ds;
    this.sv = sv;
  }
};
var createSnapshot = (ds, sm) => new Snapshot(ds, sm);
var emptySnapshot = createSnapshot(createDeleteSet(), /* @__PURE__ */ new Map());
var isVisible = (item, snapshot) => snapshot === void 0 ? !item.deleted : snapshot.sv.has(item.id.client) && (snapshot.sv.get(item.id.client) || 0) > item.id.clock && !isDeleted(snapshot.ds, item.id);
var splitSnapshotAffectedStructs = (transaction, snapshot) => {
  const meta = setIfUndefined(transaction.meta, splitSnapshotAffectedStructs, create2);
  const store = transaction.doc.store;
  if (!meta.has(snapshot)) {
    snapshot.sv.forEach((clock, client) => {
      if (clock < getState(store, client)) {
        getItemCleanStart(transaction, createID(client, clock));
      }
    });
    iterateDeletedStructs(transaction, snapshot.ds, (_item) => {
    });
    meta.add(snapshot);
  }
};
var StructStore = class {
  constructor() {
    this.clients = /* @__PURE__ */ new Map();
    this.pendingStructs = null;
    this.pendingDs = null;
  }
};
var getStateVector = (store) => {
  const sm = /* @__PURE__ */ new Map();
  store.clients.forEach((structs, client) => {
    const struct = structs[structs.length - 1];
    sm.set(client, struct.id.clock + struct.length);
  });
  return sm;
};
var getState = (store, client) => {
  const structs = store.clients.get(client);
  if (structs === void 0) {
    return 0;
  }
  const lastStruct = structs[structs.length - 1];
  return lastStruct.id.clock + lastStruct.length;
};
var addStruct = (store, struct) => {
  let structs = store.clients.get(struct.id.client);
  if (structs === void 0) {
    structs = [];
    store.clients.set(struct.id.client, structs);
  } else {
    const lastStruct = structs[structs.length - 1];
    if (lastStruct.id.clock + lastStruct.length !== struct.id.clock) {
      throw unexpectedCase();
    }
  }
  structs.push(struct);
};
var findIndexSS = (structs, clock) => {
  let left = 0;
  let right = structs.length - 1;
  let mid = structs[right];
  let midclock = mid.id.clock;
  if (midclock === clock) {
    return right;
  }
  let midindex = floor(clock / (midclock + mid.length - 1) * right);
  while (left <= right) {
    mid = structs[midindex];
    midclock = mid.id.clock;
    if (midclock <= clock) {
      if (clock < midclock + mid.length) {
        return midindex;
      }
      left = midindex + 1;
    } else {
      right = midindex - 1;
    }
    midindex = floor((left + right) / 2);
  }
  throw unexpectedCase();
};
var find = (store, id2) => {
  const structs = store.clients.get(id2.client);
  return structs[findIndexSS(structs, id2.clock)];
};
var getItem = (
  /** @type {function(StructStore,ID):Item} */
  find
);
var findIndexCleanStart = (transaction, structs, clock) => {
  const index = findIndexSS(structs, clock);
  const struct = structs[index];
  if (struct.id.clock < clock && struct instanceof Item) {
    structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));
    return index + 1;
  }
  return index;
};
var getItemCleanStart = (transaction, id2) => {
  const structs = (
    /** @type {Array<Item>} */
    transaction.doc.store.clients.get(id2.client)
  );
  return structs[findIndexCleanStart(transaction, structs, id2.clock)];
};
var getItemCleanEnd = (transaction, store, id2) => {
  const structs = store.clients.get(id2.client);
  const index = findIndexSS(structs, id2.clock);
  const struct = structs[index];
  if (id2.clock !== struct.id.clock + struct.length - 1 && struct.constructor !== GC) {
    structs.splice(index + 1, 0, splitItem(transaction, struct, id2.clock - struct.id.clock + 1));
  }
  return struct;
};
var replaceStruct = (store, struct, newStruct) => {
  const structs = (
    /** @type {Array<GC|Item>} */
    store.clients.get(struct.id.client)
  );
  structs[findIndexSS(structs, struct.id.clock)] = newStruct;
};
var iterateStructs = (transaction, structs, clockStart, len, f) => {
  if (len === 0) {
    return;
  }
  const clockEnd = clockStart + len;
  let index = findIndexCleanStart(transaction, structs, clockStart);
  let struct;
  do {
    struct = structs[index++];
    if (clockEnd < struct.id.clock + struct.length) {
      findIndexCleanStart(transaction, structs, clockEnd);
    }
    f(struct);
  } while (index < structs.length && structs[index].id.clock < clockEnd);
};
var Transaction = class {
  /**
   * @param {Doc} doc
   * @param {any} origin
   * @param {boolean} local
   */
  constructor(doc2, origin, local) {
    this.doc = doc2;
    this.deleteSet = new DeleteSet();
    this.beforeState = getStateVector(doc2.store);
    this.afterState = /* @__PURE__ */ new Map();
    this.changed = /* @__PURE__ */ new Map();
    this.changedParentTypes = /* @__PURE__ */ new Map();
    this._mergeStructs = [];
    this.origin = origin;
    this.meta = /* @__PURE__ */ new Map();
    this.local = local;
    this.subdocsAdded = /* @__PURE__ */ new Set();
    this.subdocsRemoved = /* @__PURE__ */ new Set();
    this.subdocsLoaded = /* @__PURE__ */ new Set();
    this._needFormattingCleanup = false;
  }
};
var writeUpdateMessageFromTransaction = (encoder2, transaction) => {
  if (transaction.deleteSet.clients.size === 0 && !any(transaction.afterState, (clock, client) => transaction.beforeState.get(client) !== clock)) {
    return false;
  }
  sortAndMergeDeleteSet(transaction.deleteSet);
  writeStructsFromTransaction(encoder2, transaction);
  writeDeleteSet(encoder2, transaction.deleteSet);
  return true;
};
var addChangedTypeToTransaction = (transaction, type, parentSub) => {
  const item = type._item;
  if (item === null || item.id.clock < (transaction.beforeState.get(item.id.client) || 0) && !item.deleted) {
    setIfUndefined(transaction.changed, type, create2).add(parentSub);
  }
};
var tryToMergeWithLefts = (structs, pos) => {
  let right = structs[pos];
  let left = structs[pos - 1];
  let i2 = pos;
  for (; i2 > 0; right = left, left = structs[--i2 - 1]) {
    if (left.deleted === right.deleted && left.constructor === right.constructor) {
      if (left.mergeWith(right)) {
        if (right instanceof Item && right.parentSub !== null && /** @type {AbstractType<any>} */
        right.parent._map.get(right.parentSub) === right) {
          right.parent._map.set(
            right.parentSub,
            /** @type {Item} */
            left
          );
        }
        continue;
      }
    }
    break;
  }
  const merged = pos - i2;
  if (merged) {
    structs.splice(pos + 1 - merged, merged);
  }
  return merged;
};
var tryGcDeleteSet = (ds, store, gcFilter) => {
  for (const [client, deleteItems] of ds.clients.entries()) {
    const structs = (
      /** @type {Array<GC|Item>} */
      store.clients.get(client)
    );
    for (let di = deleteItems.length - 1; di >= 0; di--) {
      const deleteItem = deleteItems[di];
      const endDeleteItemClock = deleteItem.clock + deleteItem.len;
      for (let si = findIndexSS(structs, deleteItem.clock), struct = structs[si]; si < structs.length && struct.id.clock < endDeleteItemClock; struct = structs[++si]) {
        const struct2 = structs[si];
        if (deleteItem.clock + deleteItem.len <= struct2.id.clock) {
          break;
        }
        if (struct2 instanceof Item && struct2.deleted && !struct2.keep && gcFilter(struct2)) {
          struct2.gc(store, false);
        }
      }
    }
  }
};
var tryMergeDeleteSet = (ds, store) => {
  ds.clients.forEach((deleteItems, client) => {
    const structs = (
      /** @type {Array<GC|Item>} */
      store.clients.get(client)
    );
    for (let di = deleteItems.length - 1; di >= 0; di--) {
      const deleteItem = deleteItems[di];
      const mostRightIndexToCheck = min(structs.length - 1, 1 + findIndexSS(structs, deleteItem.clock + deleteItem.len - 1));
      for (let si = mostRightIndexToCheck, struct = structs[si]; si > 0 && struct.id.clock >= deleteItem.clock; struct = structs[si]) {
        si -= 1 + tryToMergeWithLefts(structs, si);
      }
    }
  });
};
var cleanupTransactions = (transactionCleanups, i2) => {
  if (i2 < transactionCleanups.length) {
    const transaction = transactionCleanups[i2];
    const doc2 = transaction.doc;
    const store = doc2.store;
    const ds = transaction.deleteSet;
    const mergeStructs = transaction._mergeStructs;
    try {
      sortAndMergeDeleteSet(ds);
      transaction.afterState = getStateVector(transaction.doc.store);
      doc2.emit("beforeObserverCalls", [transaction, doc2]);
      const fs = [];
      transaction.changed.forEach(
        (subs, itemtype) => fs.push(() => {
          if (itemtype._item === null || !itemtype._item.deleted) {
            itemtype._callObserver(transaction, subs);
          }
        })
      );
      fs.push(() => {
        transaction.changedParentTypes.forEach((events, type) => {
          if (type._dEH.l.length > 0 && (type._item === null || !type._item.deleted)) {
            events = events.filter(
              (event) => event.target._item === null || !event.target._item.deleted
            );
            events.forEach((event) => {
              event.currentTarget = type;
              event._path = null;
            });
            events.sort((event1, event2) => event1.path.length - event2.path.length);
            callEventHandlerListeners(type._dEH, events, transaction);
          }
        });
      });
      fs.push(() => doc2.emit("afterTransaction", [transaction, doc2]));
      callAll(fs, []);
      if (transaction._needFormattingCleanup) {
        cleanupYTextAfterTransaction(transaction);
      }
    } finally {
      if (doc2.gc) {
        tryGcDeleteSet(ds, store, doc2.gcFilter);
      }
      tryMergeDeleteSet(ds, store);
      transaction.afterState.forEach((clock, client) => {
        const beforeClock = transaction.beforeState.get(client) || 0;
        if (beforeClock !== clock) {
          const structs = (
            /** @type {Array<GC|Item>} */
            store.clients.get(client)
          );
          const firstChangePos = max(findIndexSS(structs, beforeClock), 1);
          for (let i3 = structs.length - 1; i3 >= firstChangePos; ) {
            i3 -= 1 + tryToMergeWithLefts(structs, i3);
          }
        }
      });
      for (let i3 = mergeStructs.length - 1; i3 >= 0; i3--) {
        const { client, clock } = mergeStructs[i3].id;
        const structs = (
          /** @type {Array<GC|Item>} */
          store.clients.get(client)
        );
        const replacedStructPos = findIndexSS(structs, clock);
        if (replacedStructPos + 1 < structs.length) {
          if (tryToMergeWithLefts(structs, replacedStructPos + 1) > 1) {
            continue;
          }
        }
        if (replacedStructPos > 0) {
          tryToMergeWithLefts(structs, replacedStructPos);
        }
      }
      if (!transaction.local && transaction.afterState.get(doc2.clientID) !== transaction.beforeState.get(doc2.clientID)) {
        print(ORANGE, BOLD, "[yjs] ", UNBOLD, RED, "Changed the client-id because another client seems to be using it.");
        doc2.clientID = generateNewClientId();
      }
      doc2.emit("afterTransactionCleanup", [transaction, doc2]);
      if (doc2._observers.has("update")) {
        const encoder2 = new UpdateEncoderV1();
        const hasContent2 = writeUpdateMessageFromTransaction(encoder2, transaction);
        if (hasContent2) {
          doc2.emit("update", [encoder2.toUint8Array(), transaction.origin, doc2, transaction]);
        }
      }
      if (doc2._observers.has("updateV2")) {
        const encoder2 = new UpdateEncoderV2();
        const hasContent2 = writeUpdateMessageFromTransaction(encoder2, transaction);
        if (hasContent2) {
          doc2.emit("updateV2", [encoder2.toUint8Array(), transaction.origin, doc2, transaction]);
        }
      }
      const { subdocsAdded, subdocsLoaded, subdocsRemoved } = transaction;
      if (subdocsAdded.size > 0 || subdocsRemoved.size > 0 || subdocsLoaded.size > 0) {
        subdocsAdded.forEach((subdoc) => {
          subdoc.clientID = doc2.clientID;
          if (subdoc.collectionid == null) {
            subdoc.collectionid = doc2.collectionid;
          }
          doc2.subdocs.add(subdoc);
        });
        subdocsRemoved.forEach((subdoc) => doc2.subdocs.delete(subdoc));
        doc2.emit("subdocs", [{ loaded: subdocsLoaded, added: subdocsAdded, removed: subdocsRemoved }, doc2, transaction]);
        subdocsRemoved.forEach((subdoc) => subdoc.destroy());
      }
      if (transactionCleanups.length <= i2 + 1) {
        doc2._transactionCleanups = [];
        doc2.emit("afterAllTransactions", [doc2, transactionCleanups]);
      } else {
        cleanupTransactions(transactionCleanups, i2 + 1);
      }
    }
  }
};
var transact = (doc2, f, origin = null, local = true) => {
  const transactionCleanups = doc2._transactionCleanups;
  let initialCall = false;
  let result = null;
  if (doc2._transaction === null) {
    initialCall = true;
    doc2._transaction = new Transaction(doc2, origin, local);
    transactionCleanups.push(doc2._transaction);
    if (transactionCleanups.length === 1) {
      doc2.emit("beforeAllTransactions", [doc2]);
    }
    doc2.emit("beforeTransaction", [doc2._transaction, doc2]);
  }
  try {
    result = f(doc2._transaction);
  } finally {
    if (initialCall) {
      const finishCleanup = doc2._transaction === transactionCleanups[0];
      doc2._transaction = null;
      if (finishCleanup) {
        cleanupTransactions(transactionCleanups, 0);
      }
    }
  }
  return result;
};
function* lazyStructReaderGenerator(decoder2) {
  const numOfStateUpdates = readVarUint(decoder2.restDecoder);
  for (let i2 = 0; i2 < numOfStateUpdates; i2++) {
    const numberOfStructs = readVarUint(decoder2.restDecoder);
    const client = decoder2.readClient();
    let clock = readVarUint(decoder2.restDecoder);
    for (let i3 = 0; i3 < numberOfStructs; i3++) {
      const info = decoder2.readInfo();
      if (info === 10) {
        const len = readVarUint(decoder2.restDecoder);
        yield new Skip(createID(client, clock), len);
        clock += len;
      } else if ((BITS5 & info) !== 0) {
        const cantCopyParentInfo = (info & (BIT7 | BIT8)) === 0;
        const struct = new Item(
          createID(client, clock),
          null,
          // left
          (info & BIT8) === BIT8 ? decoder2.readLeftID() : null,
          // origin
          null,
          // right
          (info & BIT7) === BIT7 ? decoder2.readRightID() : null,
          // right origin
          // @ts-ignore Force writing a string here.
          cantCopyParentInfo ? decoder2.readParentInfo() ? decoder2.readString() : decoder2.readLeftID() : null,
          // parent
          cantCopyParentInfo && (info & BIT6) === BIT6 ? decoder2.readString() : null,
          // parentSub
          readItemContent(decoder2, info)
          // item content
        );
        yield struct;
        clock += struct.length;
      } else {
        const len = decoder2.readLen();
        yield new GC(createID(client, clock), len);
        clock += len;
      }
    }
  }
}
var LazyStructReader = class {
  /**
   * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
   * @param {boolean} filterSkips
   */
  constructor(decoder2, filterSkips) {
    this.gen = lazyStructReaderGenerator(decoder2);
    this.curr = null;
    this.done = false;
    this.filterSkips = filterSkips;
    this.next();
  }
  /**
   * @return {Item | GC | Skip |null}
   */
  next() {
    do {
      this.curr = this.gen.next().value || null;
    } while (this.filterSkips && this.curr !== null && this.curr.constructor === Skip);
    return this.curr;
  }
};
var LazyStructWriter = class {
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  constructor(encoder2) {
    this.currClient = 0;
    this.startClock = 0;
    this.written = 0;
    this.encoder = encoder2;
    this.clientStructs = [];
  }
};
var mergeUpdates = (updates) => mergeUpdatesV2(updates, UpdateDecoderV1, UpdateEncoderV1);
var sliceStruct = (left, diff2) => {
  if (left.constructor === GC) {
    const { client, clock } = left.id;
    return new GC(createID(client, clock + diff2), left.length - diff2);
  } else if (left.constructor === Skip) {
    const { client, clock } = left.id;
    return new Skip(createID(client, clock + diff2), left.length - diff2);
  } else {
    const leftItem = (
      /** @type {Item} */
      left
    );
    const { client, clock } = leftItem.id;
    return new Item(
      createID(client, clock + diff2),
      null,
      createID(client, clock + diff2 - 1),
      null,
      leftItem.rightOrigin,
      leftItem.parent,
      leftItem.parentSub,
      leftItem.content.splice(diff2)
    );
  }
};
var mergeUpdatesV2 = (updates, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {
  if (updates.length === 1) {
    return updates[0];
  }
  const updateDecoders = updates.map((update2) => new YDecoder(createDecoder(update2)));
  let lazyStructDecoders = updateDecoders.map((decoder2) => new LazyStructReader(decoder2, true));
  let currWrite = null;
  const updateEncoder = new YEncoder();
  const lazyStructEncoder = new LazyStructWriter(updateEncoder);
  while (true) {
    lazyStructDecoders = lazyStructDecoders.filter((dec) => dec.curr !== null);
    lazyStructDecoders.sort(
      /** @type {function(any,any):number} */
      (dec1, dec2) => {
        if (dec1.curr.id.client === dec2.curr.id.client) {
          const clockDiff = dec1.curr.id.clock - dec2.curr.id.clock;
          if (clockDiff === 0) {
            return dec1.curr.constructor === dec2.curr.constructor ? 0 : dec1.curr.constructor === Skip ? 1 : -1;
          } else {
            return clockDiff;
          }
        } else {
          return dec2.curr.id.client - dec1.curr.id.client;
        }
      }
    );
    if (lazyStructDecoders.length === 0) {
      break;
    }
    const currDecoder = lazyStructDecoders[0];
    const firstClient = (
      /** @type {Item | GC} */
      currDecoder.curr.id.client
    );
    if (currWrite !== null) {
      let curr = (
        /** @type {Item | GC | null} */
        currDecoder.curr
      );
      let iterated = false;
      while (curr !== null && curr.id.clock + curr.length <= currWrite.struct.id.clock + currWrite.struct.length && curr.id.client >= currWrite.struct.id.client) {
        curr = currDecoder.next();
        iterated = true;
      }
      if (curr === null || // current decoder is empty
      curr.id.client !== firstClient || // check whether there is another decoder that has has updates from `firstClient`
      iterated && curr.id.clock > currWrite.struct.id.clock + currWrite.struct.length) {
        continue;
      }
      if (firstClient !== currWrite.struct.id.client) {
        writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
        currWrite = { struct: curr, offset: 0 };
        currDecoder.next();
      } else {
        if (currWrite.struct.id.clock + currWrite.struct.length < curr.id.clock) {
          if (currWrite.struct.constructor === Skip) {
            currWrite.struct.length = curr.id.clock + curr.length - currWrite.struct.id.clock;
          } else {
            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
            const diff2 = curr.id.clock - currWrite.struct.id.clock - currWrite.struct.length;
            const struct = new Skip(createID(firstClient, currWrite.struct.id.clock + currWrite.struct.length), diff2);
            currWrite = { struct, offset: 0 };
          }
        } else {
          const diff2 = currWrite.struct.id.clock + currWrite.struct.length - curr.id.clock;
          if (diff2 > 0) {
            if (currWrite.struct.constructor === Skip) {
              currWrite.struct.length -= diff2;
            } else {
              curr = sliceStruct(curr, diff2);
            }
          }
          if (!currWrite.struct.mergeWith(
            /** @type {any} */
            curr
          )) {
            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
            currWrite = { struct: curr, offset: 0 };
            currDecoder.next();
          }
        }
      }
    } else {
      currWrite = { struct: (
        /** @type {Item | GC} */
        currDecoder.curr
      ), offset: 0 };
      currDecoder.next();
    }
    for (let next = currDecoder.curr; next !== null && next.id.client === firstClient && next.id.clock === currWrite.struct.id.clock + currWrite.struct.length && next.constructor !== Skip; next = currDecoder.next()) {
      writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
      currWrite = { struct: next, offset: 0 };
    }
  }
  if (currWrite !== null) {
    writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
    currWrite = null;
  }
  finishLazyStructWriting(lazyStructEncoder);
  const dss = updateDecoders.map((decoder2) => readDeleteSet(decoder2));
  const ds = mergeDeleteSets(dss);
  writeDeleteSet(updateEncoder, ds);
  return updateEncoder.toUint8Array();
};
var diffUpdateV2 = (update2, sv, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {
  const state = decodeStateVector(sv);
  const encoder2 = new YEncoder();
  const lazyStructWriter = new LazyStructWriter(encoder2);
  const decoder2 = new YDecoder(createDecoder(update2));
  const reader = new LazyStructReader(decoder2, false);
  while (reader.curr) {
    const curr = reader.curr;
    const currClient = curr.id.client;
    const svClock = state.get(currClient) || 0;
    if (reader.curr.constructor === Skip) {
      reader.next();
      continue;
    }
    if (curr.id.clock + curr.length > svClock) {
      writeStructToLazyStructWriter(lazyStructWriter, curr, max(svClock - curr.id.clock, 0));
      reader.next();
      while (reader.curr && reader.curr.id.client === currClient) {
        writeStructToLazyStructWriter(lazyStructWriter, reader.curr, 0);
        reader.next();
      }
    } else {
      while (reader.curr && reader.curr.id.client === currClient && reader.curr.id.clock + reader.curr.length <= svClock) {
        reader.next();
      }
    }
  }
  finishLazyStructWriting(lazyStructWriter);
  const ds = readDeleteSet(decoder2);
  writeDeleteSet(encoder2, ds);
  return encoder2.toUint8Array();
};
var flushLazyStructWriter = (lazyWriter) => {
  if (lazyWriter.written > 0) {
    lazyWriter.clientStructs.push({ written: lazyWriter.written, restEncoder: toUint8Array(lazyWriter.encoder.restEncoder) });
    lazyWriter.encoder.restEncoder = createEncoder();
    lazyWriter.written = 0;
  }
};
var writeStructToLazyStructWriter = (lazyWriter, struct, offset) => {
  if (lazyWriter.written > 0 && lazyWriter.currClient !== struct.id.client) {
    flushLazyStructWriter(lazyWriter);
  }
  if (lazyWriter.written === 0) {
    lazyWriter.currClient = struct.id.client;
    lazyWriter.encoder.writeClient(struct.id.client);
    writeVarUint(lazyWriter.encoder.restEncoder, struct.id.clock + offset);
  }
  struct.write(lazyWriter.encoder, offset);
  lazyWriter.written++;
};
var finishLazyStructWriting = (lazyWriter) => {
  flushLazyStructWriter(lazyWriter);
  const restEncoder = lazyWriter.encoder.restEncoder;
  writeVarUint(restEncoder, lazyWriter.clientStructs.length);
  for (let i2 = 0; i2 < lazyWriter.clientStructs.length; i2++) {
    const partStructs = lazyWriter.clientStructs[i2];
    writeVarUint(restEncoder, partStructs.written);
    writeUint8Array(restEncoder, partStructs.restEncoder);
  }
};
var convertUpdateFormat = (update2, blockTransformer, YDecoder, YEncoder) => {
  const updateDecoder = new YDecoder(createDecoder(update2));
  const lazyDecoder = new LazyStructReader(updateDecoder, false);
  const updateEncoder = new YEncoder();
  const lazyWriter = new LazyStructWriter(updateEncoder);
  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {
    writeStructToLazyStructWriter(lazyWriter, blockTransformer(curr), 0);
  }
  finishLazyStructWriting(lazyWriter);
  const ds = readDeleteSet(updateDecoder);
  writeDeleteSet(updateEncoder, ds);
  return updateEncoder.toUint8Array();
};
var convertUpdateFormatV2ToV1 = (update2) => convertUpdateFormat(update2, id, UpdateDecoderV2, UpdateEncoderV1);
var errorComputeChanges = "You must not compute changes after the event-handler fired.";
var YEvent = class {
  /**
   * @param {T} target The changed type.
   * @param {Transaction} transaction
   */
  constructor(target, transaction) {
    this.target = target;
    this.currentTarget = target;
    this.transaction = transaction;
    this._changes = null;
    this._keys = null;
    this._delta = null;
    this._path = null;
  }
  /**
   * Computes the path from `y` to the changed type.
   *
   * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.
   *
   * The following property holds:
   * @example
   *   let type = y
   *   event.path.forEach(dir => {
   *     type = type.get(dir)
   *   })
   *   type === event.target // => true
   */
  get path() {
    return this._path || (this._path = getPathTo(this.currentTarget, this.target));
  }
  /**
   * Check if a struct is deleted by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  deletes(struct) {
    return isDeleted(this.transaction.deleteSet, struct.id);
  }
  /**
   * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}
   */
  get keys() {
    if (this._keys === null) {
      if (this.transaction.doc._transactionCleanups.length === 0) {
        throw create3(errorComputeChanges);
      }
      const keys2 = /* @__PURE__ */ new Map();
      const target = this.target;
      const changed = (
        /** @type Set<string|null> */
        this.transaction.changed.get(target)
      );
      changed.forEach((key) => {
        if (key !== null) {
          const item = (
            /** @type {Item} */
            target._map.get(key)
          );
          let action;
          let oldValue;
          if (this.adds(item)) {
            let prev = item.left;
            while (prev !== null && this.adds(prev)) {
              prev = prev.left;
            }
            if (this.deletes(item)) {
              if (prev !== null && this.deletes(prev)) {
                action = "delete";
                oldValue = last(prev.content.getContent());
              } else {
                return;
              }
            } else {
              if (prev !== null && this.deletes(prev)) {
                action = "update";
                oldValue = last(prev.content.getContent());
              } else {
                action = "add";
                oldValue = void 0;
              }
            }
          } else {
            if (this.deletes(item)) {
              action = "delete";
              oldValue = last(
                /** @type {Item} */
                item.content.getContent()
              );
            } else {
              return;
            }
          }
          keys2.set(key, { action, oldValue });
        }
      });
      this._keys = keys2;
    }
    return this._keys;
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {Array<{insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}
   */
  get delta() {
    return this.changes.delta;
  }
  /**
   * Check if a struct is added by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  adds(struct) {
    return struct.id.clock >= (this.transaction.beforeState.get(struct.id.client) || 0);
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    let changes = this._changes;
    if (changes === null) {
      if (this.transaction.doc._transactionCleanups.length === 0) {
        throw create3(errorComputeChanges);
      }
      const target = this.target;
      const added = create2();
      const deleted = create2();
      const delta = [];
      changes = {
        added,
        deleted,
        delta,
        keys: this.keys
      };
      const changed = (
        /** @type Set<string|null> */
        this.transaction.changed.get(target)
      );
      if (changed.has(null)) {
        let lastOp = null;
        const packOp = () => {
          if (lastOp) {
            delta.push(lastOp);
          }
        };
        for (let item = target._start; item !== null; item = item.right) {
          if (item.deleted) {
            if (this.deletes(item) && !this.adds(item)) {
              if (lastOp === null || lastOp.delete === void 0) {
                packOp();
                lastOp = { delete: 0 };
              }
              lastOp.delete += item.length;
              deleted.add(item);
            }
          } else {
            if (this.adds(item)) {
              if (lastOp === null || lastOp.insert === void 0) {
                packOp();
                lastOp = { insert: [] };
              }
              lastOp.insert = lastOp.insert.concat(item.content.getContent());
              added.add(item);
            } else {
              if (lastOp === null || lastOp.retain === void 0) {
                packOp();
                lastOp = { retain: 0 };
              }
              lastOp.retain += item.length;
            }
          }
        }
        if (lastOp !== null && lastOp.retain === void 0) {
          packOp();
        }
      }
      this._changes = changes;
    }
    return (
      /** @type {any} */
      changes
    );
  }
};
var getPathTo = (parent, child) => {
  const path = [];
  while (child._item !== null && child !== parent) {
    if (child._item.parentSub !== null) {
      path.unshift(child._item.parentSub);
    } else {
      let i2 = 0;
      let c = (
        /** @type {AbstractType<any>} */
        child._item.parent._start
      );
      while (c !== child._item && c !== null) {
        if (!c.deleted) {
          i2++;
        }
        c = c.right;
      }
      path.unshift(i2);
    }
    child = /** @type {AbstractType<any>} */
    child._item.parent;
  }
  return path;
};
var maxSearchMarker = 80;
var globalSearchMarkerTimestamp = 0;
var ArraySearchMarker = class {
  /**
   * @param {Item} p
   * @param {number} index
   */
  constructor(p, index) {
    p.marker = true;
    this.p = p;
    this.index = index;
    this.timestamp = globalSearchMarkerTimestamp++;
  }
};
var refreshMarkerTimestamp = (marker) => {
  marker.timestamp = globalSearchMarkerTimestamp++;
};
var overwriteMarker = (marker, p, index) => {
  marker.p.marker = false;
  marker.p = p;
  p.marker = true;
  marker.index = index;
  marker.timestamp = globalSearchMarkerTimestamp++;
};
var markPosition = (searchMarker, p, index) => {
  if (searchMarker.length >= maxSearchMarker) {
    const marker = searchMarker.reduce((a, b) => a.timestamp < b.timestamp ? a : b);
    overwriteMarker(marker, p, index);
    return marker;
  } else {
    const pm = new ArraySearchMarker(p, index);
    searchMarker.push(pm);
    return pm;
  }
};
var findMarker = (yarray, index) => {
  if (yarray._start === null || index === 0 || yarray._searchMarker === null) {
    return null;
  }
  const marker = yarray._searchMarker.length === 0 ? null : yarray._searchMarker.reduce((a, b) => abs(index - a.index) < abs(index - b.index) ? a : b);
  let p = yarray._start;
  let pindex = 0;
  if (marker !== null) {
    p = marker.p;
    pindex = marker.index;
    refreshMarkerTimestamp(marker);
  }
  while (p.right !== null && pindex < index) {
    if (!p.deleted && p.countable) {
      if (index < pindex + p.length) {
        break;
      }
      pindex += p.length;
    }
    p = p.right;
  }
  while (p.left !== null && pindex > index) {
    p = p.left;
    if (!p.deleted && p.countable) {
      pindex -= p.length;
    }
  }
  while (p.left !== null && p.left.id.client === p.id.client && p.left.id.clock + p.left.length === p.id.clock) {
    p = p.left;
    if (!p.deleted && p.countable) {
      pindex -= p.length;
    }
  }
  if (marker !== null && abs(marker.index - pindex) < /** @type {YText|YArray<any>} */
  p.parent.length / maxSearchMarker) {
    overwriteMarker(marker, p, pindex);
    return marker;
  } else {
    return markPosition(yarray._searchMarker, p, pindex);
  }
};
var updateMarkerChanges = (searchMarker, index, len) => {
  for (let i2 = searchMarker.length - 1; i2 >= 0; i2--) {
    const m = searchMarker[i2];
    if (len > 0) {
      let p = m.p;
      p.marker = false;
      while (p && (p.deleted || !p.countable)) {
        p = p.left;
        if (p && !p.deleted && p.countable) {
          m.index -= p.length;
        }
      }
      if (p === null || p.marker === true) {
        searchMarker.splice(i2, 1);
        continue;
      }
      m.p = p;
      p.marker = true;
    }
    if (index < m.index || len > 0 && index === m.index) {
      m.index = max(index, m.index + len);
    }
  }
};
var callTypeObservers = (type, transaction, event) => {
  const changedType = type;
  const changedParentTypes = transaction.changedParentTypes;
  while (true) {
    setIfUndefined(changedParentTypes, type, () => []).push(event);
    if (type._item === null) {
      break;
    }
    type = /** @type {AbstractType<any>} */
    type._item.parent;
  }
  callEventHandlerListeners(changedType._eH, event, transaction);
};
var AbstractType = class {
  constructor() {
    this._item = null;
    this._map = /* @__PURE__ */ new Map();
    this._start = null;
    this.doc = null;
    this._length = 0;
    this._eH = createEventHandler();
    this._dEH = createEventHandler();
    this._searchMarker = null;
  }
  /**
   * @return {AbstractType<any>|null}
   */
  get parent() {
    return this._item ? (
      /** @type {AbstractType<any>} */
      this._item.parent
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item|null} item
   */
  _integrate(y, item) {
    this.doc = y;
    this._item = item;
  }
  /**
   * @return {AbstractType<EventType>}
   */
  _copy() {
    throw methodUnimplemented();
  }
  /**
   * @return {AbstractType<EventType>}
   */
  clone() {
    throw methodUnimplemented();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} _encoder
   */
  _write(_encoder) {
  }
  /**
   * The first non-deleted item
   */
  get _first() {
    let n = this._start;
    while (n !== null && n.deleted) {
      n = n.right;
    }
    return n;
  }
  /**
   * Creates YEvent and calls all type observers.
   * Must be implemented by each type.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} _parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, _parentSubs) {
    if (!transaction.local && this._searchMarker) {
      this._searchMarker.length = 0;
    }
  }
  /**
   * Observe all events that are created on this type.
   *
   * @param {function(EventType, Transaction):void} f Observer function
   */
  observe(f) {
    addEventHandlerListener(this._eH, f);
  }
  /**
   * Observe all events that are created by this type and its children.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  observeDeep(f) {
    addEventHandlerListener(this._dEH, f);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(EventType,Transaction):void} f Observer function
   */
  unobserve(f) {
    removeEventHandlerListener(this._eH, f);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  unobserveDeep(f) {
    removeEventHandlerListener(this._dEH, f);
  }
  /**
   * @abstract
   * @return {any}
   */
  toJSON() {
  }
};
var typeListSlice = (type, start, end) => {
  if (start < 0) {
    start = type._length + start;
  }
  if (end < 0) {
    end = type._length + end;
  }
  let len = end - start;
  const cs = [];
  let n = type._start;
  while (n !== null && len > 0) {
    if (n.countable && !n.deleted) {
      const c = n.content.getContent();
      if (c.length <= start) {
        start -= c.length;
      } else {
        for (let i2 = start; i2 < c.length && len > 0; i2++) {
          cs.push(c[i2]);
          len--;
        }
        start = 0;
      }
    }
    n = n.right;
  }
  return cs;
};
var typeListToArray = (type) => {
  const cs = [];
  let n = type._start;
  while (n !== null) {
    if (n.countable && !n.deleted) {
      const c = n.content.getContent();
      for (let i2 = 0; i2 < c.length; i2++) {
        cs.push(c[i2]);
      }
    }
    n = n.right;
  }
  return cs;
};
var typeListForEach = (type, f) => {
  let index = 0;
  let n = type._start;
  while (n !== null) {
    if (n.countable && !n.deleted) {
      const c = n.content.getContent();
      for (let i2 = 0; i2 < c.length; i2++) {
        f(c[i2], index++, type);
      }
    }
    n = n.right;
  }
};
var typeListMap = (type, f) => {
  const result = [];
  typeListForEach(type, (c, i2) => {
    result.push(f(c, i2, type));
  });
  return result;
};
var typeListCreateIterator = (type) => {
  let n = type._start;
  let currentContent = null;
  let currentContentIndex = 0;
  return {
    [Symbol.iterator]() {
      return this;
    },
    next: () => {
      if (currentContent === null) {
        while (n !== null && n.deleted) {
          n = n.right;
        }
        if (n === null) {
          return {
            done: true,
            value: void 0
          };
        }
        currentContent = n.content.getContent();
        currentContentIndex = 0;
        n = n.right;
      }
      const value = currentContent[currentContentIndex++];
      if (currentContent.length <= currentContentIndex) {
        currentContent = null;
      }
      return {
        done: false,
        value
      };
    }
  };
};
var typeListGet = (type, index) => {
  const marker = findMarker(type, index);
  let n = type._start;
  if (marker !== null) {
    n = marker.p;
    index -= marker.index;
  }
  for (; n !== null; n = n.right) {
    if (!n.deleted && n.countable) {
      if (index < n.length) {
        return n.content.getContent()[index];
      }
      index -= n.length;
    }
  }
};
var typeListInsertGenericsAfter = (transaction, parent, referenceItem, content) => {
  let left = referenceItem;
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  const store = doc2.store;
  const right = referenceItem === null ? parent._start : referenceItem.right;
  let jsonContent = [];
  const packJsonContent = () => {
    if (jsonContent.length > 0) {
      left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentAny(jsonContent));
      left.integrate(transaction, 0);
      jsonContent = [];
    }
  };
  content.forEach((c) => {
    if (c === null) {
      jsonContent.push(c);
    } else {
      switch (c.constructor) {
        case Number:
        case Object:
        case Boolean:
        case Array:
        case String:
          jsonContent.push(c);
          break;
        default:
          packJsonContent();
          switch (c.constructor) {
            case Uint8Array:
            case ArrayBuffer:
              left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentBinary(new Uint8Array(
                /** @type {Uint8Array} */
                c
              )));
              left.integrate(transaction, 0);
              break;
            case Doc:
              left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentDoc(
                /** @type {Doc} */
                c
              ));
              left.integrate(transaction, 0);
              break;
            default:
              if (c instanceof AbstractType) {
                left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentType(c));
                left.integrate(transaction, 0);
              } else {
                throw new Error("Unexpected content type in insert operation");
              }
          }
      }
    }
  });
  packJsonContent();
};
var lengthExceeded = () => create3("Length exceeded!");
var typeListInsertGenerics = (transaction, parent, index, content) => {
  if (index > parent._length) {
    throw lengthExceeded();
  }
  if (index === 0) {
    if (parent._searchMarker) {
      updateMarkerChanges(parent._searchMarker, index, content.length);
    }
    return typeListInsertGenericsAfter(transaction, parent, null, content);
  }
  const startIndex = index;
  const marker = findMarker(parent, index);
  let n = parent._start;
  if (marker !== null) {
    n = marker.p;
    index -= marker.index;
    if (index === 0) {
      n = n.prev;
      index += n && n.countable && !n.deleted ? n.length : 0;
    }
  }
  for (; n !== null; n = n.right) {
    if (!n.deleted && n.countable) {
      if (index <= n.length) {
        if (index < n.length) {
          getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));
        }
        break;
      }
      index -= n.length;
    }
  }
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, startIndex, content.length);
  }
  return typeListInsertGenericsAfter(transaction, parent, n, content);
};
var typeListPushGenerics = (transaction, parent, content) => {
  const marker = (parent._searchMarker || []).reduce((maxMarker, currMarker) => currMarker.index > maxMarker.index ? currMarker : maxMarker, { index: 0, p: parent._start });
  let n = marker.p;
  if (n) {
    while (n.right) {
      n = n.right;
    }
  }
  return typeListInsertGenericsAfter(transaction, parent, n, content);
};
var typeListDelete = (transaction, parent, index, length4) => {
  if (length4 === 0) {
    return;
  }
  const startIndex = index;
  const startLength = length4;
  const marker = findMarker(parent, index);
  let n = parent._start;
  if (marker !== null) {
    n = marker.p;
    index -= marker.index;
  }
  for (; n !== null && index > 0; n = n.right) {
    if (!n.deleted && n.countable) {
      if (index < n.length) {
        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));
      }
      index -= n.length;
    }
  }
  while (length4 > 0 && n !== null) {
    if (!n.deleted) {
      if (length4 < n.length) {
        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + length4));
      }
      n.delete(transaction);
      length4 -= n.length;
    }
    n = n.right;
  }
  if (length4 > 0) {
    throw lengthExceeded();
  }
  if (parent._searchMarker) {
    updateMarkerChanges(
      parent._searchMarker,
      startIndex,
      -startLength + length4
      /* in case we remove the above exception */
    );
  }
};
var typeMapDelete = (transaction, parent, key) => {
  const c = parent._map.get(key);
  if (c !== void 0) {
    c.delete(transaction);
  }
};
var typeMapSet = (transaction, parent, key, value) => {
  const left = parent._map.get(key) || null;
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  let content;
  if (value == null) {
    content = new ContentAny([value]);
  } else {
    switch (value.constructor) {
      case Number:
      case Object:
      case Boolean:
      case Array:
      case String:
        content = new ContentAny([value]);
        break;
      case Uint8Array:
        content = new ContentBinary(
          /** @type {Uint8Array} */
          value
        );
        break;
      case Doc:
        content = new ContentDoc(
          /** @type {Doc} */
          value
        );
        break;
      default:
        if (value instanceof AbstractType) {
          content = new ContentType(value);
        } else {
          throw new Error("Unexpected content type");
        }
    }
  }
  new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, null, null, parent, key, content).integrate(transaction, 0);
};
var typeMapGet = (parent, key) => {
  const val = parent._map.get(key);
  return val !== void 0 && !val.deleted ? val.content.getContent()[val.length - 1] : void 0;
};
var typeMapGetAll = (parent) => {
  const res = {};
  parent._map.forEach((value, key) => {
    if (!value.deleted) {
      res[key] = value.content.getContent()[value.length - 1];
    }
  });
  return res;
};
var typeMapHas = (parent, key) => {
  const val = parent._map.get(key);
  return val !== void 0 && !val.deleted;
};
var typeMapGetAllSnapshot = (parent, snapshot) => {
  const res = {};
  parent._map.forEach((value, key) => {
    let v = value;
    while (v !== null && (!snapshot.sv.has(v.id.client) || v.id.clock >= (snapshot.sv.get(v.id.client) || 0))) {
      v = v.left;
    }
    if (v !== null && isVisible(v, snapshot)) {
      res[key] = v.content.getContent()[v.length - 1];
    }
  });
  return res;
};
var createMapIterator = (map3) => iteratorFilter(
  map3.entries(),
  /** @param {any} entry */
  (entry) => !entry[1].deleted
);
var YArrayEvent = class extends YEvent {
  /**
   * @param {YArray<T>} yarray The changed type
   * @param {Transaction} transaction The transaction object
   */
  constructor(yarray, transaction) {
    super(yarray, transaction);
    this._transaction = transaction;
  }
};
var YArray = class extends AbstractType {
  constructor() {
    super();
    this._prelimContent = [];
    this._searchMarker = [];
  }
  /**
   * Construct a new YArray containing the specified items.
   * @template {Object<string,any>|Array<any>|number|null|string|Uint8Array} T
   * @param {Array<T>} items
   * @return {YArray<T>}
   */
  static from(items) {
    const a = new YArray();
    a.push(items);
    return a;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y, item) {
    super._integrate(y, item);
    this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    );
    this._prelimContent = null;
  }
  /**
   * @return {YArray<T>}
   */
  _copy() {
    return new YArray();
  }
  /**
   * @return {YArray<T>}
   */
  clone() {
    const arr = new YArray();
    arr.insert(0, this.toArray().map(
      (el) => el instanceof AbstractType ? (
        /** @type {typeof el} */
        el.clone()
      ) : el
    ));
    return arr;
  }
  get length() {
    return this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  /**
   * Creates YArrayEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    super._callObserver(transaction, parentSubs);
    callTypeObservers(this, transaction, new YArrayEvent(this, transaction));
  }
  /**
   * Inserts new content at an index.
   *
   * Important: This function expects an array of content. Not just a content
   * object. The reason for this "weirdness" is that inserting several elements
   * is very efficient when it is done as a single operation.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  yarray.insert(0, ['a'])
   *  // Insert numbers 1, 2 at position 1
   *  yarray.insert(1, [1, 2])
   *
   * @param {number} index The index to insert content at.
   * @param {Array<T>} content The array of content
   */
  insert(index, content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListInsertGenerics(
          transaction,
          this,
          index,
          /** @type {any} */
          content
        );
      });
    } else {
      this._prelimContent.splice(index, 0, ...content);
    }
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<T>} content Array of content to append.
   *
   * @todo Use the following implementation in all types.
   */
  push(content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListPushGenerics(
          transaction,
          this,
          /** @type {any} */
          content
        );
      });
    } else {
      this._prelimContent.push(...content);
    }
  }
  /**
   * Preppends content to this YArray.
   *
   * @param {Array<T>} content Array of content to preppend.
   */
  unshift(content) {
    this.insert(0, content);
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} length The number of elements to remove. Defaults to 1.
   */
  delete(index, length4 = 1) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListDelete(transaction, this, index, length4);
      });
    } else {
      this._prelimContent.splice(index, length4);
    }
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {T}
   */
  get(index) {
    return typeListGet(this, index);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<T>}
   */
  toArray() {
    return typeListToArray(this);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<T>}
   */
  slice(start = 0, end = this.length) {
    return typeListSlice(this, start, end);
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Array<any>}
   */
  toJSON() {
    return this.map((c) => c instanceof AbstractType ? c.toJSON() : c);
  }
  /**
   * Returns an Array with the result of calling a provided function on every
   * element of this YArray.
   *
   * @template M
   * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array
   * @return {Array<M>} A new array with each element being the result of the
   *                 callback function
   */
  map(f) {
    return typeListMap(
      this,
      /** @type {any} */
      f
    );
  }
  /**
   * Executes a provided function once on overy element of this YArray.
   *
   * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.
   */
  forEach(f) {
    typeListForEach(this, f);
  }
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return typeListCreateIterator(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder2) {
    encoder2.writeTypeRef(YArrayRefID);
  }
};
var readYArray = (_decoder) => new YArray();
var YMapEvent = class extends YEvent {
  /**
   * @param {YMap<T>} ymap The YArray that changed.
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed.
   */
  constructor(ymap, transaction, subs) {
    super(ymap, transaction);
    this.keysChanged = subs;
  }
};
var YMap = class extends AbstractType {
  /**
   *
   * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap
   */
  constructor(entries) {
    super();
    this._prelimContent = null;
    if (entries === void 0) {
      this._prelimContent = /* @__PURE__ */ new Map();
    } else {
      this._prelimContent = new Map(entries);
    }
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y, item) {
    super._integrate(y, item);
    this._prelimContent.forEach((value, key) => {
      this.set(key, value);
    });
    this._prelimContent = null;
  }
  /**
   * @return {YMap<MapType>}
   */
  _copy() {
    return new YMap();
  }
  /**
   * @return {YMap<MapType>}
   */
  clone() {
    const map3 = new YMap();
    this.forEach((value, key) => {
      map3.set(key, value instanceof AbstractType ? (
        /** @type {typeof value} */
        value.clone()
      ) : value);
    });
    return map3;
  }
  /**
   * Creates YMapEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    callTypeObservers(this, transaction, new YMapEvent(this, transaction, parentSubs));
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Object<string,any>}
   */
  toJSON() {
    const map3 = {};
    this._map.forEach((item, key) => {
      if (!item.deleted) {
        const v = item.content.getContent()[item.length - 1];
        map3[key] = v instanceof AbstractType ? v.toJSON() : v;
      }
    });
    return map3;
  }
  /**
   * Returns the size of the YMap (count of key/value pairs)
   *
   * @return {number}
   */
  get size() {
    return [...createMapIterator(this._map)].length;
  }
  /**
   * Returns the keys for each element in the YMap Type.
   *
   * @return {IterableIterator<string>}
   */
  keys() {
    return iteratorMap(
      createMapIterator(this._map),
      /** @param {any} v */
      (v) => v[0]
    );
  }
  /**
   * Returns the values for each element in the YMap Type.
   *
   * @return {IterableIterator<MapType>}
   */
  values() {
    return iteratorMap(
      createMapIterator(this._map),
      /** @param {any} v */
      (v) => v[1].content.getContent()[v[1].length - 1]
    );
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  entries() {
    return iteratorMap(
      createMapIterator(this._map),
      /** @param {any} v */
      (v) => (
        /** @type {any} */
        [v[0], v[1].content.getContent()[v[1].length - 1]]
      )
    );
  }
  /**
   * Executes a provided function on once on every key-value pair.
   *
   * @param {function(MapType,string,YMap<MapType>):void} f A function to execute on every element of this YArray.
   */
  forEach(f) {
    this._map.forEach((item, key) => {
      if (!item.deleted) {
        f(item.content.getContent()[item.length - 1], key, this);
      }
    });
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Remove a specified element from this YMap.
   *
   * @param {string} key The key of the element to remove.
   */
  delete(key) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapDelete(transaction, this, key);
      });
    } else {
      this._prelimContent.delete(key);
    }
  }
  /**
   * Adds or updates an element with a specified key and value.
   * @template {MapType} VAL
   *
   * @param {string} key The key of the element to add to this YMap
   * @param {VAL} value The value of the element to add
   * @return {VAL}
   */
  set(key, value) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapSet(
          transaction,
          this,
          key,
          /** @type {any} */
          value
        );
      });
    } else {
      this._prelimContent.set(key, value);
    }
    return value;
  }
  /**
   * Returns a specified element from this YMap.
   *
   * @param {string} key
   * @return {MapType|undefined}
   */
  get(key) {
    return (
      /** @type {any} */
      typeMapGet(this, key)
    );
  }
  /**
   * Returns a boolean indicating whether the specified key exists or not.
   *
   * @param {string} key The key to test.
   * @return {boolean}
   */
  has(key) {
    return typeMapHas(this, key);
  }
  /**
   * Removes all elements from this YMap.
   */
  clear() {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        this.forEach(function(_value, key, map3) {
          typeMapDelete(transaction, map3, key);
        });
      });
    } else {
      this._prelimContent.clear();
    }
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder2) {
    encoder2.writeTypeRef(YMapRefID);
  }
};
var readYMap = (_decoder) => new YMap();
var equalAttrs = (a, b) => a === b || typeof a === "object" && typeof b === "object" && a && b && equalFlat(a, b);
var ItemTextListPosition = class {
  /**
   * @param {Item|null} left
   * @param {Item|null} right
   * @param {number} index
   * @param {Map<string,any>} currentAttributes
   */
  constructor(left, right, index, currentAttributes) {
    this.left = left;
    this.right = right;
    this.index = index;
    this.currentAttributes = currentAttributes;
  }
  /**
   * Only call this if you know that this.right is defined
   */
  forward() {
    if (this.right === null) {
      unexpectedCase();
    }
    switch (this.right.content.constructor) {
      case ContentFormat:
        if (!this.right.deleted) {
          updateCurrentAttributes(
            this.currentAttributes,
            /** @type {ContentFormat} */
            this.right.content
          );
        }
        break;
      default:
        if (!this.right.deleted) {
          this.index += this.right.length;
        }
        break;
    }
    this.left = this.right;
    this.right = this.right.right;
  }
};
var findNextPosition = (transaction, pos, count2) => {
  while (pos.right !== null && count2 > 0) {
    switch (pos.right.content.constructor) {
      case ContentFormat:
        if (!pos.right.deleted) {
          updateCurrentAttributes(
            pos.currentAttributes,
            /** @type {ContentFormat} */
            pos.right.content
          );
        }
        break;
      default:
        if (!pos.right.deleted) {
          if (count2 < pos.right.length) {
            getItemCleanStart(transaction, createID(pos.right.id.client, pos.right.id.clock + count2));
          }
          pos.index += pos.right.length;
          count2 -= pos.right.length;
        }
        break;
    }
    pos.left = pos.right;
    pos.right = pos.right.right;
  }
  return pos;
};
var findPosition = (transaction, parent, index, useSearchMarker) => {
  const currentAttributes = /* @__PURE__ */ new Map();
  const marker = useSearchMarker ? findMarker(parent, index) : null;
  if (marker) {
    const pos = new ItemTextListPosition(marker.p.left, marker.p, marker.index, currentAttributes);
    return findNextPosition(transaction, pos, index - marker.index);
  } else {
    const pos = new ItemTextListPosition(null, parent._start, 0, currentAttributes);
    return findNextPosition(transaction, pos, index);
  }
};
var insertNegatedAttributes = (transaction, parent, currPos, negatedAttributes) => {
  while (currPos.right !== null && (currPos.right.deleted === true || currPos.right.content.constructor === ContentFormat && equalAttrs(
    negatedAttributes.get(
      /** @type {ContentFormat} */
      currPos.right.content.key
    ),
    /** @type {ContentFormat} */
    currPos.right.content.value
  ))) {
    if (!currPos.right.deleted) {
      negatedAttributes.delete(
        /** @type {ContentFormat} */
        currPos.right.content.key
      );
    }
    currPos.forward();
  }
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  negatedAttributes.forEach((val, key) => {
    const left = currPos.left;
    const right = currPos.right;
    const nextFormat = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));
    nextFormat.integrate(transaction, 0);
    currPos.right = nextFormat;
    currPos.forward();
  });
};
var updateCurrentAttributes = (currentAttributes, format) => {
  const { key, value } = format;
  if (value === null) {
    currentAttributes.delete(key);
  } else {
    currentAttributes.set(key, value);
  }
};
var minimizeAttributeChanges = (currPos, attributes) => {
  var _a2;
  while (true) {
    if (currPos.right === null) {
      break;
    } else if (currPos.right.deleted || currPos.right.content.constructor === ContentFormat && equalAttrs(
      (_a2 = attributes[
        /** @type {ContentFormat} */
        currPos.right.content.key
      ]) != null ? _a2 : null,
      /** @type {ContentFormat} */
      currPos.right.content.value
    ))
      ;
    else {
      break;
    }
    currPos.forward();
  }
};
var insertAttributes = (transaction, parent, currPos, attributes) => {
  var _a2;
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  const negatedAttributes = /* @__PURE__ */ new Map();
  for (const key in attributes) {
    const val = attributes[key];
    const currentVal = (_a2 = currPos.currentAttributes.get(key)) != null ? _a2 : null;
    if (!equalAttrs(currentVal, val)) {
      negatedAttributes.set(key, currentVal);
      const { left, right } = currPos;
      currPos.right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));
      currPos.right.integrate(transaction, 0);
      currPos.forward();
    }
  }
  return negatedAttributes;
};
var insertText = (transaction, parent, currPos, text3, attributes) => {
  currPos.currentAttributes.forEach((_val, key) => {
    if (attributes[key] === void 0) {
      attributes[key] = null;
    }
  });
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  minimizeAttributeChanges(currPos, attributes);
  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
  const content = text3.constructor === String ? new ContentString(
    /** @type {string} */
    text3
  ) : text3 instanceof AbstractType ? new ContentType(text3) : new ContentEmbed(text3);
  let { left, right, index } = currPos;
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, currPos.index, content.getLength());
  }
  right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, content);
  right.integrate(transaction, 0);
  currPos.right = right;
  currPos.index = index;
  currPos.forward();
  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
};
var formatText = (transaction, parent, currPos, length4, attributes) => {
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  minimizeAttributeChanges(currPos, attributes);
  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
  iterationLoop:
    while (currPos.right !== null && (length4 > 0 || negatedAttributes.size > 0 && (currPos.right.deleted || currPos.right.content.constructor === ContentFormat))) {
      if (!currPos.right.deleted) {
        switch (currPos.right.content.constructor) {
          case ContentFormat: {
            const { key, value } = (
              /** @type {ContentFormat} */
              currPos.right.content
            );
            const attr2 = attributes[key];
            if (attr2 !== void 0) {
              if (equalAttrs(attr2, value)) {
                negatedAttributes.delete(key);
              } else {
                if (length4 === 0) {
                  break iterationLoop;
                }
                negatedAttributes.set(key, value);
              }
              currPos.right.delete(transaction);
            } else {
              currPos.currentAttributes.set(key, value);
            }
            break;
          }
          default:
            if (length4 < currPos.right.length) {
              getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length4));
            }
            length4 -= currPos.right.length;
            break;
        }
      }
      currPos.forward();
    }
  if (length4 > 0) {
    let newlines = "";
    for (; length4 > 0; length4--) {
      newlines += "\n";
    }
    currPos.right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), currPos.left, currPos.left && currPos.left.lastId, currPos.right, currPos.right && currPos.right.id, parent, null, new ContentString(newlines));
    currPos.right.integrate(transaction, 0);
    currPos.forward();
  }
  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
};
var cleanupFormattingGap = (transaction, start, curr, startAttributes, currAttributes) => {
  var _a2, _b2;
  let end = start;
  const endFormats = create();
  while (end && (!end.countable || end.deleted)) {
    if (!end.deleted && end.content.constructor === ContentFormat) {
      const cf = (
        /** @type {ContentFormat} */
        end.content
      );
      endFormats.set(cf.key, cf);
    }
    end = end.right;
  }
  let cleanups = 0;
  let reachedCurr = false;
  while (start !== end) {
    if (curr === start) {
      reachedCurr = true;
    }
    if (!start.deleted) {
      const content = start.content;
      switch (content.constructor) {
        case ContentFormat: {
          const { key, value } = (
            /** @type {ContentFormat} */
            content
          );
          const startAttrValue = (_a2 = startAttributes.get(key)) != null ? _a2 : null;
          if (endFormats.get(key) !== content || startAttrValue === value) {
            start.delete(transaction);
            cleanups++;
            if (!reachedCurr && ((_b2 = currAttributes.get(key)) != null ? _b2 : null) === value && startAttrValue !== value) {
              if (startAttrValue === null) {
                currAttributes.delete(key);
              } else {
                currAttributes.set(key, startAttrValue);
              }
            }
          }
          if (!reachedCurr && !start.deleted) {
            updateCurrentAttributes(
              currAttributes,
              /** @type {ContentFormat} */
              content
            );
          }
          break;
        }
      }
    }
    start = /** @type {Item} */
    start.right;
  }
  return cleanups;
};
var cleanupContextlessFormattingGap = (transaction, item) => {
  while (item && item.right && (item.right.deleted || !item.right.countable)) {
    item = item.right;
  }
  const attrs = /* @__PURE__ */ new Set();
  while (item && (item.deleted || !item.countable)) {
    if (!item.deleted && item.content.constructor === ContentFormat) {
      const key = (
        /** @type {ContentFormat} */
        item.content.key
      );
      if (attrs.has(key)) {
        item.delete(transaction);
      } else {
        attrs.add(key);
      }
    }
    item = item.left;
  }
};
var cleanupYTextFormatting = (type) => {
  let res = 0;
  transact(
    /** @type {Doc} */
    type.doc,
    (transaction) => {
      let start = (
        /** @type {Item} */
        type._start
      );
      let end = type._start;
      let startAttributes = create();
      const currentAttributes = copy(startAttributes);
      while (end) {
        if (end.deleted === false) {
          switch (end.content.constructor) {
            case ContentFormat:
              updateCurrentAttributes(
                currentAttributes,
                /** @type {ContentFormat} */
                end.content
              );
              break;
            default:
              res += cleanupFormattingGap(transaction, start, end, startAttributes, currentAttributes);
              startAttributes = copy(currentAttributes);
              start = end;
              break;
          }
        }
        end = end.right;
      }
    }
  );
  return res;
};
var cleanupYTextAfterTransaction = (transaction) => {
  const needFullCleanup = /* @__PURE__ */ new Set();
  const doc2 = transaction.doc;
  for (const [client, afterClock] of transaction.afterState.entries()) {
    const clock = transaction.beforeState.get(client) || 0;
    if (afterClock === clock) {
      continue;
    }
    iterateStructs(
      transaction,
      /** @type {Array<Item|GC>} */
      doc2.store.clients.get(client),
      clock,
      afterClock,
      (item) => {
        if (!item.deleted && /** @type {Item} */
        item.content.constructor === ContentFormat && item.constructor !== GC) {
          needFullCleanup.add(
            /** @type {any} */
            item.parent
          );
        }
      }
    );
  }
  transact(doc2, (t2) => {
    iterateDeletedStructs(transaction, transaction.deleteSet, (item) => {
      if (item instanceof GC || !/** @type {YText} */
      item.parent._hasFormatting || needFullCleanup.has(
        /** @type {YText} */
        item.parent
      )) {
        return;
      }
      const parent = (
        /** @type {YText} */
        item.parent
      );
      if (item.content.constructor === ContentFormat) {
        needFullCleanup.add(parent);
      } else {
        cleanupContextlessFormattingGap(t2, item);
      }
    });
    for (const yText of needFullCleanup) {
      cleanupYTextFormatting(yText);
    }
  });
};
var deleteText = (transaction, currPos, length4) => {
  const startLength = length4;
  const startAttrs = copy(currPos.currentAttributes);
  const start = currPos.right;
  while (length4 > 0 && currPos.right !== null) {
    if (currPos.right.deleted === false) {
      switch (currPos.right.content.constructor) {
        case ContentType:
        case ContentEmbed:
        case ContentString:
          if (length4 < currPos.right.length) {
            getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length4));
          }
          length4 -= currPos.right.length;
          currPos.right.delete(transaction);
          break;
      }
    }
    currPos.forward();
  }
  if (start) {
    cleanupFormattingGap(transaction, start, currPos.right, startAttrs, currPos.currentAttributes);
  }
  const parent = (
    /** @type {AbstractType<any>} */
    /** @type {Item} */
    (currPos.left || currPos.right).parent
  );
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, currPos.index, -startLength + length4);
  }
  return currPos;
};
var YTextEvent = class extends YEvent {
  /**
   * @param {YText} ytext
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed
   */
  constructor(ytext, transaction, subs) {
    super(ytext, transaction);
    this.childListChanged = false;
    this.keysChanged = /* @__PURE__ */ new Set();
    subs.forEach((sub) => {
      if (sub === null) {
        this.childListChanged = true;
      } else {
        this.keysChanged.add(sub);
      }
    });
  }
  /**
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    if (this._changes === null) {
      const changes = {
        keys: this.keys,
        delta: this.delta,
        added: /* @__PURE__ */ new Set(),
        deleted: /* @__PURE__ */ new Set()
      };
      this._changes = changes;
    }
    return (
      /** @type {any} */
      this._changes
    );
  }
  /**
   * Compute the changes in the delta format.
   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.
   *
   * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}
   *
   * @public
   */
  get delta() {
    if (this._delta === null) {
      const y = (
        /** @type {Doc} */
        this.target.doc
      );
      const delta = [];
      transact(y, (transaction) => {
        var _a2, _b2, _c;
        const currentAttributes = /* @__PURE__ */ new Map();
        const oldAttributes = /* @__PURE__ */ new Map();
        let item = this.target._start;
        let action = null;
        const attributes = {};
        let insert2 = "";
        let retain = 0;
        let deleteLen = 0;
        const addOp = () => {
          if (action !== null) {
            let op = null;
            switch (action) {
              case "delete":
                if (deleteLen > 0) {
                  op = { delete: deleteLen };
                }
                deleteLen = 0;
                break;
              case "insert":
                if (typeof insert2 === "object" || insert2.length > 0) {
                  op = { insert: insert2 };
                  if (currentAttributes.size > 0) {
                    op.attributes = {};
                    currentAttributes.forEach((value, key) => {
                      if (value !== null) {
                        op.attributes[key] = value;
                      }
                    });
                  }
                }
                insert2 = "";
                break;
              case "retain":
                if (retain > 0) {
                  op = { retain };
                  if (!isEmpty(attributes)) {
                    op.attributes = assign({}, attributes);
                  }
                }
                retain = 0;
                break;
            }
            if (op)
              delta.push(op);
            action = null;
          }
        };
        while (item !== null) {
          switch (item.content.constructor) {
            case ContentType:
            case ContentEmbed:
              if (this.adds(item)) {
                if (!this.deletes(item)) {
                  addOp();
                  action = "insert";
                  insert2 = item.content.getContent()[0];
                  addOp();
                }
              } else if (this.deletes(item)) {
                if (action !== "delete") {
                  addOp();
                  action = "delete";
                }
                deleteLen += 1;
              } else if (!item.deleted) {
                if (action !== "retain") {
                  addOp();
                  action = "retain";
                }
                retain += 1;
              }
              break;
            case ContentString:
              if (this.adds(item)) {
                if (!this.deletes(item)) {
                  if (action !== "insert") {
                    addOp();
                    action = "insert";
                  }
                  insert2 += /** @type {ContentString} */
                  item.content.str;
                }
              } else if (this.deletes(item)) {
                if (action !== "delete") {
                  addOp();
                  action = "delete";
                }
                deleteLen += item.length;
              } else if (!item.deleted) {
                if (action !== "retain") {
                  addOp();
                  action = "retain";
                }
                retain += item.length;
              }
              break;
            case ContentFormat: {
              const { key, value } = (
                /** @type {ContentFormat} */
                item.content
              );
              if (this.adds(item)) {
                if (!this.deletes(item)) {
                  const curVal = (_a2 = currentAttributes.get(key)) != null ? _a2 : null;
                  if (!equalAttrs(curVal, value)) {
                    if (action === "retain") {
                      addOp();
                    }
                    if (equalAttrs(value, (_b2 = oldAttributes.get(key)) != null ? _b2 : null)) {
                      delete attributes[key];
                    } else {
                      attributes[key] = value;
                    }
                  } else if (value !== null) {
                    item.delete(transaction);
                  }
                }
              } else if (this.deletes(item)) {
                oldAttributes.set(key, value);
                const curVal = (_c = currentAttributes.get(key)) != null ? _c : null;
                if (!equalAttrs(curVal, value)) {
                  if (action === "retain") {
                    addOp();
                  }
                  attributes[key] = curVal;
                }
              } else if (!item.deleted) {
                oldAttributes.set(key, value);
                const attr2 = attributes[key];
                if (attr2 !== void 0) {
                  if (!equalAttrs(attr2, value)) {
                    if (action === "retain") {
                      addOp();
                    }
                    if (value === null) {
                      delete attributes[key];
                    } else {
                      attributes[key] = value;
                    }
                  } else if (attr2 !== null) {
                    item.delete(transaction);
                  }
                }
              }
              if (!item.deleted) {
                if (action === "insert") {
                  addOp();
                }
                updateCurrentAttributes(
                  currentAttributes,
                  /** @type {ContentFormat} */
                  item.content
                );
              }
              break;
            }
          }
          item = item.right;
        }
        addOp();
        while (delta.length > 0) {
          const lastOp = delta[delta.length - 1];
          if (lastOp.retain !== void 0 && lastOp.attributes === void 0) {
            delta.pop();
          } else {
            break;
          }
        }
      });
      this._delta = delta;
    }
    return (
      /** @type {any} */
      this._delta
    );
  }
};
var YText = class extends AbstractType {
  /**
   * @param {String} [string] The initial value of the YText.
   */
  constructor(string) {
    super();
    this._pending = string !== void 0 ? [() => this.insert(0, string)] : [];
    this._searchMarker = [];
    this._hasFormatting = false;
  }
  /**
   * Number of characters of this text type.
   *
   * @type {number}
   */
  get length() {
    return this._length;
  }
  /**
   * @param {Doc} y
   * @param {Item} item
   */
  _integrate(y, item) {
    super._integrate(y, item);
    try {
      this._pending.forEach((f) => f());
    } catch (e2) {
      console.error(e2);
    }
    this._pending = null;
  }
  _copy() {
    return new YText();
  }
  /**
   * @return {YText}
   */
  clone() {
    const text3 = new YText();
    text3.applyDelta(this.toDelta());
    return text3;
  }
  /**
   * Creates YTextEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    super._callObserver(transaction, parentSubs);
    const event = new YTextEvent(this, transaction, parentSubs);
    callTypeObservers(this, transaction, event);
    if (!transaction.local && this._hasFormatting) {
      transaction._needFormattingCleanup = true;
    }
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @public
   */
  toString() {
    let str = "";
    let n = this._start;
    while (n !== null) {
      if (!n.deleted && n.countable && n.content.constructor === ContentString) {
        str += /** @type {ContentString} */
        n.content.str;
      }
      n = n.right;
    }
    return str;
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @return {string}
   * @public
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Apply a {@link Delta} on this shared YText type.
   *
   * @param {any} delta The changes to apply on this element.
   * @param {object}  opts
   * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.
   *
   *
   * @public
   */
  applyDelta(delta, { sanitize = true } = {}) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        const currPos = new ItemTextListPosition(null, this._start, 0, /* @__PURE__ */ new Map());
        for (let i2 = 0; i2 < delta.length; i2++) {
          const op = delta[i2];
          if (op.insert !== void 0) {
            const ins = !sanitize && typeof op.insert === "string" && i2 === delta.length - 1 && currPos.right === null && op.insert.slice(-1) === "\n" ? op.insert.slice(0, -1) : op.insert;
            if (typeof ins !== "string" || ins.length > 0) {
              insertText(transaction, this, currPos, ins, op.attributes || {});
            }
          } else if (op.retain !== void 0) {
            formatText(transaction, this, currPos, op.retain, op.attributes || {});
          } else if (op.delete !== void 0) {
            deleteText(transaction, currPos, op.delete);
          }
        }
      });
    } else {
      this._pending.push(() => this.applyDelta(delta));
    }
  }
  /**
   * Returns the Delta representation of this YText type.
   *
   * @param {Snapshot} [snapshot]
   * @param {Snapshot} [prevSnapshot]
   * @param {function('removed' | 'added', ID):any} [computeYChange]
   * @return {any} The Delta representation of this type.
   *
   * @public
   */
  toDelta(snapshot, prevSnapshot, computeYChange) {
    const ops = [];
    const currentAttributes = /* @__PURE__ */ new Map();
    const doc2 = (
      /** @type {Doc} */
      this.doc
    );
    let str = "";
    let n = this._start;
    function packStr() {
      if (str.length > 0) {
        const attributes = {};
        let addAttributes = false;
        currentAttributes.forEach((value, key) => {
          addAttributes = true;
          attributes[key] = value;
        });
        const op = { insert: str };
        if (addAttributes) {
          op.attributes = attributes;
        }
        ops.push(op);
        str = "";
      }
    }
    const computeDelta = () => {
      while (n !== null) {
        if (isVisible(n, snapshot) || prevSnapshot !== void 0 && isVisible(n, prevSnapshot)) {
          switch (n.content.constructor) {
            case ContentString: {
              const cur = currentAttributes.get("ychange");
              if (snapshot !== void 0 && !isVisible(n, snapshot)) {
                if (cur === void 0 || cur.user !== n.id.client || cur.type !== "removed") {
                  packStr();
                  currentAttributes.set("ychange", computeYChange ? computeYChange("removed", n.id) : { type: "removed" });
                }
              } else if (prevSnapshot !== void 0 && !isVisible(n, prevSnapshot)) {
                if (cur === void 0 || cur.user !== n.id.client || cur.type !== "added") {
                  packStr();
                  currentAttributes.set("ychange", computeYChange ? computeYChange("added", n.id) : { type: "added" });
                }
              } else if (cur !== void 0) {
                packStr();
                currentAttributes.delete("ychange");
              }
              str += /** @type {ContentString} */
              n.content.str;
              break;
            }
            case ContentType:
            case ContentEmbed: {
              packStr();
              const op = {
                insert: n.content.getContent()[0]
              };
              if (currentAttributes.size > 0) {
                const attrs = (
                  /** @type {Object<string,any>} */
                  {}
                );
                op.attributes = attrs;
                currentAttributes.forEach((value, key) => {
                  attrs[key] = value;
                });
              }
              ops.push(op);
              break;
            }
            case ContentFormat:
              if (isVisible(n, snapshot)) {
                packStr();
                updateCurrentAttributes(
                  currentAttributes,
                  /** @type {ContentFormat} */
                  n.content
                );
              }
              break;
          }
        }
        n = n.right;
      }
      packStr();
    };
    if (snapshot || prevSnapshot) {
      transact(doc2, (transaction) => {
        if (snapshot) {
          splitSnapshotAffectedStructs(transaction, snapshot);
        }
        if (prevSnapshot) {
          splitSnapshotAffectedStructs(transaction, prevSnapshot);
        }
        computeDelta();
      }, "cleanup");
    } else {
      computeDelta();
    }
    return ops;
  }
  /**
   * Insert text at a given index.
   *
   * @param {number} index The index at which to start inserting.
   * @param {String} text The text to insert at the specified position.
   * @param {TextAttributes} [attributes] Optionally define some formatting
   *                                    information to apply on the inserted
   *                                    Text.
   * @public
   */
  insert(index, text3, attributes) {
    if (text3.length <= 0) {
      return;
    }
    const y = this.doc;
    if (y !== null) {
      transact(y, (transaction) => {
        const pos = findPosition(transaction, this, index, !attributes);
        if (!attributes) {
          attributes = {};
          pos.currentAttributes.forEach((v, k) => {
            attributes[k] = v;
          });
        }
        insertText(transaction, this, pos, text3, attributes);
      });
    } else {
      this._pending.push(() => this.insert(index, text3, attributes));
    }
  }
  /**
   * Inserts an embed at a index.
   *
   * @param {number} index The index to insert the embed at.
   * @param {Object | AbstractType<any>} embed The Object that represents the embed.
   * @param {TextAttributes} [attributes] Attribute information to apply on the
   *                                    embed
   *
   * @public
   */
  insertEmbed(index, embed, attributes) {
    const y = this.doc;
    if (y !== null) {
      transact(y, (transaction) => {
        const pos = findPosition(transaction, this, index, !attributes);
        insertText(transaction, this, pos, embed, attributes || {});
      });
    } else {
      this._pending.push(() => this.insertEmbed(index, embed, attributes || {}));
    }
  }
  /**
   * Deletes text starting from an index.
   *
   * @param {number} index Index at which to start deleting.
   * @param {number} length The number of characters to remove. Defaults to 1.
   *
   * @public
   */
  delete(index, length4) {
    if (length4 === 0) {
      return;
    }
    const y = this.doc;
    if (y !== null) {
      transact(y, (transaction) => {
        deleteText(transaction, findPosition(transaction, this, index, true), length4);
      });
    } else {
      this._pending.push(() => this.delete(index, length4));
    }
  }
  /**
   * Assigns properties to a range of text.
   *
   * @param {number} index The position where to start formatting.
   * @param {number} length The amount of characters to assign properties to.
   * @param {TextAttributes} attributes Attribute information to apply on the
   *                                    text.
   *
   * @public
   */
  format(index, length4, attributes) {
    if (length4 === 0) {
      return;
    }
    const y = this.doc;
    if (y !== null) {
      transact(y, (transaction) => {
        const pos = findPosition(transaction, this, index, false);
        if (pos.right === null) {
          return;
        }
        formatText(transaction, this, pos, length4, attributes);
      });
    } else {
      this._pending.push(() => this.format(index, length4, attributes));
    }
  }
  /**
   * Removes an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(attributeName) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapDelete(transaction, this, attributeName);
      });
    } else {
      this._pending.push(() => this.removeAttribute(attributeName));
    }
  }
  /**
   * Sets or updates an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be set.
   * @param {any} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(attributeName, attributeValue) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapSet(transaction, this, attributeName, attributeValue);
      });
    } else {
      this._pending.push(() => this.setAttribute(attributeName, attributeValue));
    }
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {any} The queried attribute value.
   *
   * @public
   */
  getAttribute(attributeName) {
    return (
      /** @type {any} */
      typeMapGet(this, attributeName)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @return {Object<string, any>} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes() {
    return typeMapGetAll(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder2) {
    encoder2.writeTypeRef(YTextRefID);
  }
};
var readYText = (_decoder) => new YText();
var YXmlTreeWalker = class {
  /**
   * @param {YXmlFragment | YXmlElement} root
   * @param {function(AbstractType<any>):boolean} [f]
   */
  constructor(root, f = () => true) {
    this._filter = f;
    this._root = root;
    this._currentNode = /** @type {Item} */
    root._start;
    this._firstCall = true;
  }
  [Symbol.iterator]() {
    return this;
  }
  /**
   * Get the next node.
   *
   * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.
   *
   * @public
   */
  next() {
    let n = this._currentNode;
    let type = n && n.content && /** @type {any} */
    n.content.type;
    if (n !== null && (!this._firstCall || n.deleted || !this._filter(type))) {
      do {
        type = /** @type {any} */
        n.content.type;
        if (!n.deleted && (type.constructor === YXmlElement || type.constructor === YXmlFragment) && type._start !== null) {
          n = type._start;
        } else {
          while (n !== null) {
            if (n.right !== null) {
              n = n.right;
              break;
            } else if (n.parent === this._root) {
              n = null;
            } else {
              n = /** @type {AbstractType<any>} */
              n.parent._item;
            }
          }
        }
      } while (n !== null && (n.deleted || !this._filter(
        /** @type {ContentType} */
        n.content.type
      )));
    }
    this._firstCall = false;
    if (n === null) {
      return { value: void 0, done: true };
    }
    this._currentNode = n;
    return { value: (
      /** @type {any} */
      n.content.type
    ), done: false };
  }
};
var YXmlFragment = class extends AbstractType {
  constructor() {
    super();
    this._prelimContent = [];
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get firstChild() {
    const first = this._first;
    return first ? first.content.getContent()[0] : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y, item) {
    super._integrate(y, item);
    this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    );
    this._prelimContent = null;
  }
  _copy() {
    return new YXmlFragment();
  }
  /**
   * @return {YXmlFragment}
   */
  clone() {
    const el = new YXmlFragment();
    el.insert(0, this.toArray().map((item) => item instanceof AbstractType ? item.clone() : item));
    return el;
  }
  get length() {
    return this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  /**
   * Create a subtree of childNodes.
   *
   * @example
   * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')
   * for (let node in walker) {
   *   // `node` is a div node
   *   nop(node)
   * }
   *
   * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and
   *                          returns a Boolean indicating whether the child
   *                          is to be included in the subtree.
   * @return {YXmlTreeWalker} A subtree and a position within it.
   *
   * @public
   */
  createTreeWalker(filter) {
    return new YXmlTreeWalker(this, filter);
  }
  /**
   * Returns the first YXmlElement that matches the query.
   * Similar to DOM's {@link querySelector}.
   *
   * Query support:
   *   - tagname
   * TODO:
   *   - id
   *   - attribute
   *
   * @param {CSS_Selector} query The query on the children.
   * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.
   *
   * @public
   */
  querySelector(query) {
    query = query.toUpperCase();
    const iterator = new YXmlTreeWalker(this, (element3) => element3.nodeName && element3.nodeName.toUpperCase() === query);
    const next = iterator.next();
    if (next.done) {
      return null;
    } else {
      return next.value;
    }
  }
  /**
   * Returns all YXmlElements that match the query.
   * Similar to Dom's {@link querySelectorAll}.
   *
   * @todo Does not yet support all queries. Currently only query by tagName.
   *
   * @param {CSS_Selector} query The query on the children
   * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.
   *
   * @public
   */
  querySelectorAll(query) {
    query = query.toUpperCase();
    return from(new YXmlTreeWalker(this, (element3) => element3.nodeName && element3.nodeName.toUpperCase() === query));
  }
  /**
   * Creates YXmlEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    callTypeObservers(this, transaction, new YXmlEvent(this, parentSubs, transaction));
  }
  /**
   * Get the string representation of all the children of this YXmlFragment.
   *
   * @return {string} The string representation of all children.
   */
  toString() {
    return typeListMap(this, (xml) => xml.toString()).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks = {}, binding) {
    const fragment2 = _document.createDocumentFragment();
    if (binding !== void 0) {
      binding._createAssociation(fragment2, this);
    }
    typeListForEach(this, (xmlType) => {
      fragment2.insertBefore(xmlType.toDOM(_document, hooks, binding), null);
    });
    return fragment2;
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {number} index The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insert(index, content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListInsertGenerics(transaction, this, index, content);
      });
    } else {
      this._prelimContent.splice(index, 0, ...content);
    }
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insertAfter(ref, content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        const refItem = ref && ref instanceof AbstractType ? ref._item : ref;
        typeListInsertGenericsAfter(transaction, this, refItem, content);
      });
    } else {
      const pc = (
        /** @type {Array<any>} */
        this._prelimContent
      );
      const index = ref === null ? 0 : pc.findIndex((el) => el === ref) + 1;
      if (index === 0 && ref !== null) {
        throw create3("Reference item not found");
      }
      pc.splice(index, 0, ...content);
    }
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} [length=1] The number of elements to remove. Defaults to 1.
   */
  delete(index, length4 = 1) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListDelete(transaction, this, index, length4);
      });
    } else {
      this._prelimContent.splice(index, length4);
    }
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<YXmlElement|YXmlText|YXmlHook>}
   */
  toArray() {
    return typeListToArray(this);
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to append.
   */
  push(content) {
    this.insert(this.length, content);
  }
  /**
   * Preppends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to preppend.
   */
  unshift(content) {
    this.insert(0, content);
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {YXmlElement|YXmlText}
   */
  get(index) {
    return typeListGet(this, index);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<YXmlElement|YXmlText>}
   */
  slice(start = 0, end = this.length) {
    return typeListSlice(this, start, end);
  }
  /**
   * Executes a provided function on once on overy child element.
   *
   * @param {function(YXmlElement|YXmlText,number, typeof self):void} f A function to execute on every element of this YArray.
   */
  forEach(f) {
    typeListForEach(this, f);
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(encoder2) {
    encoder2.writeTypeRef(YXmlFragmentRefID);
  }
};
var readYXmlFragment = (_decoder) => new YXmlFragment();
var YXmlElement = class extends YXmlFragment {
  constructor(nodeName = "UNDEFINED") {
    super();
    this.nodeName = nodeName;
    this._prelimAttrs = /* @__PURE__ */ new Map();
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const n = this._item ? this._item.next : null;
    return n ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const n = this._item ? this._item.prev : null;
    return n ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n.content.type
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y, item) {
    super._integrate(y, item);
    /** @type {Map<string, any>} */
    this._prelimAttrs.forEach((value, key) => {
      this.setAttribute(key, value);
    });
    this._prelimAttrs = null;
  }
  /**
   * Creates an Item with the same effect as this Item (without position effect)
   *
   * @return {YXmlElement}
   */
  _copy() {
    return new YXmlElement(this.nodeName);
  }
  /**
   * @return {YXmlElement<KV>}
   */
  clone() {
    const el = new YXmlElement(this.nodeName);
    const attrs = this.getAttributes();
    forEach(attrs, (value, key) => {
      if (typeof value === "string") {
        el.setAttribute(key, value);
      }
    });
    el.insert(0, this.toArray().map((item) => item instanceof AbstractType ? item.clone() : item));
    return el;
  }
  /**
   * Returns the XML serialization of this YXmlElement.
   * The attributes are ordered by attribute-name, so you can easily use this
   * method to compare YXmlElements
   *
   * @return {string} The string representation of this type.
   *
   * @public
   */
  toString() {
    const attrs = this.getAttributes();
    const stringBuilder = [];
    const keys2 = [];
    for (const key in attrs) {
      keys2.push(key);
    }
    keys2.sort();
    const keysLen = keys2.length;
    for (let i2 = 0; i2 < keysLen; i2++) {
      const key = keys2[i2];
      stringBuilder.push(key + '="' + attrs[key] + '"');
    }
    const nodeName = this.nodeName.toLocaleLowerCase();
    const attrsString = stringBuilder.length > 0 ? " " + stringBuilder.join(" ") : "";
    return `<${nodeName}${attrsString}>${super.toString()}</${nodeName}>`;
  }
  /**
   * Removes an attribute from this YXmlElement.
   *
   * @param {string} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(attributeName) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapDelete(transaction, this, attributeName);
      });
    } else {
      this._prelimAttrs.delete(attributeName);
    }
  }
  /**
   * Sets or updates an attribute.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that is to be set.
   * @param {KV[KEY]} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(attributeName, attributeValue) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapSet(transaction, this, attributeName, attributeValue);
      });
    } else {
      this._prelimAttrs.set(attributeName, attributeValue);
    }
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {KV[KEY]|undefined} The queried attribute value.
   *
   * @public
   */
  getAttribute(attributeName) {
    return (
      /** @type {any} */
      typeMapGet(this, attributeName)
    );
  }
  /**
   * Returns whether an attribute exists
   *
   * @param {string} attributeName The attribute name to check for existence.
   * @return {boolean} whether the attribute exists.
   *
   * @public
   */
  hasAttribute(attributeName) {
    return (
      /** @type {any} */
      typeMapHas(this, attributeName)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @param {Snapshot} [snapshot]
   * @return {{ [Key in Extract<keyof KV,string>]?: KV[Key]}} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes(snapshot) {
    return (
      /** @type {any} */
      snapshot ? typeMapGetAllSnapshot(this, snapshot) : typeMapGetAll(this)
    );
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks = {}, binding) {
    const dom = _document.createElement(this.nodeName);
    const attrs = this.getAttributes();
    for (const key in attrs) {
      const value = attrs[key];
      if (typeof value === "string") {
        dom.setAttribute(key, value);
      }
    }
    typeListForEach(this, (yxml) => {
      dom.appendChild(yxml.toDOM(_document, hooks, binding));
    });
    if (binding !== void 0) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(encoder2) {
    encoder2.writeTypeRef(YXmlElementRefID);
    encoder2.writeKey(this.nodeName);
  }
};
var readYXmlElement = (decoder2) => new YXmlElement(decoder2.readKey());
var YXmlEvent = class extends YEvent {
  /**
   * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.
   * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the
   *                   child list changed.
   * @param {Transaction} transaction The transaction instance with wich the
   *                                  change was created.
   */
  constructor(target, subs, transaction) {
    super(target, transaction);
    this.childListChanged = false;
    this.attributesChanged = /* @__PURE__ */ new Set();
    subs.forEach((sub) => {
      if (sub === null) {
        this.childListChanged = true;
      } else {
        this.attributesChanged.add(sub);
      }
    });
  }
};
var YXmlHook = class extends YMap {
  /**
   * @param {string} hookName nodeName of the Dom Node.
   */
  constructor(hookName) {
    super();
    this.hookName = hookName;
  }
  /**
   * Creates an Item with the same effect as this Item (without position effect)
   */
  _copy() {
    return new YXmlHook(this.hookName);
  }
  /**
   * @return {YXmlHook}
   */
  clone() {
    const el = new YXmlHook(this.hookName);
    this.forEach((value, key) => {
      el.set(key, value);
    });
    return el;
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object.<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type
   * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks = {}, binding) {
    const hook = hooks[this.hookName];
    let dom;
    if (hook !== void 0) {
      dom = hook.createDom(this);
    } else {
      dom = document.createElement(this.hookName);
    }
    dom.setAttribute("data-yjs-hook", this.hookName);
    if (binding !== void 0) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(encoder2) {
    encoder2.writeTypeRef(YXmlHookRefID);
    encoder2.writeKey(this.hookName);
  }
};
var readYXmlHook = (decoder2) => new YXmlHook(decoder2.readKey());
var YXmlText = class extends YText {
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const n = this._item ? this._item.next : null;
    return n ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const n = this._item ? this._item.prev : null;
    return n ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n.content.type
    ) : null;
  }
  _copy() {
    return new YXmlText();
  }
  /**
   * @return {YXmlText}
   */
  clone() {
    const text3 = new YXmlText();
    text3.applyDelta(this.toDelta());
    return text3;
  }
  /**
   * Creates a Dom Element that mirrors this YXmlText.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks, binding) {
    const dom = _document.createTextNode(this.toString());
    if (binding !== void 0) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  toString() {
    return this.toDelta().map((delta) => {
      const nestedNodes = [];
      for (const nodeName in delta.attributes) {
        const attrs = [];
        for (const key in delta.attributes[nodeName]) {
          attrs.push({ key, value: delta.attributes[nodeName][key] });
        }
        attrs.sort((a, b) => a.key < b.key ? -1 : 1);
        nestedNodes.push({ nodeName, attrs });
      }
      nestedNodes.sort((a, b) => a.nodeName < b.nodeName ? -1 : 1);
      let str = "";
      for (let i2 = 0; i2 < nestedNodes.length; i2++) {
        const node = nestedNodes[i2];
        str += `<${node.nodeName}`;
        for (let j = 0; j < node.attrs.length; j++) {
          const attr2 = node.attrs[j];
          str += ` ${attr2.key}="${attr2.value}"`;
        }
        str += ">";
      }
      str += delta.insert;
      for (let i2 = nestedNodes.length - 1; i2 >= 0; i2--) {
        str += `</${nestedNodes[i2].nodeName}>`;
      }
      return str;
    }).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder2) {
    encoder2.writeTypeRef(YXmlTextRefID);
  }
};
var readYXmlText = (decoder2) => new YXmlText();
var AbstractStruct = class {
  /**
   * @param {ID} id
   * @param {number} length
   */
  constructor(id2, length4) {
    this.id = id2;
    this.length = length4;
  }
  /**
   * @type {boolean}
   */
  get deleted() {
    throw methodUnimplemented();
  }
  /**
   * Merge this struct with the item to the right.
   * This method is already assuming that `this.id.clock + this.length === this.id.clock`.
   * Also this method does *not* remove right from StructStore!
   * @param {AbstractStruct} right
   * @return {boolean} wether this merged with right
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   * @param {number} encodingRef
   */
  write(encoder2, offset, encodingRef) {
    throw methodUnimplemented();
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    throw methodUnimplemented();
  }
};
var structGCRefNumber = 0;
var GC = class extends AbstractStruct {
  get deleted() {
    return true;
  }
  delete() {
  }
  /**
   * @param {GC} right
   * @return {boolean}
   */
  mergeWith(right) {
    if (this.constructor !== right.constructor) {
      return false;
    }
    this.length += right.length;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    if (offset > 0) {
      this.id.clock += offset;
      this.length -= offset;
    }
    addStruct(transaction.doc.store, this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder2, offset) {
    encoder2.writeInfo(structGCRefNumber);
    encoder2.writeLen(this.length - offset);
  }
  /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(transaction, store) {
    return null;
  }
};
var ContentBinary = class {
  /**
   * @param {Uint8Array} content
   */
  constructor(content) {
    this.content = content;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.content];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentBinary}
   */
  copy() {
    return new ContentBinary(this.content);
  }
  /**
   * @param {number} offset
   * @return {ContentBinary}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentBinary} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder2, offset) {
    encoder2.writeBuf(this.content);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 3;
  }
};
var readContentBinary = (decoder2) => new ContentBinary(decoder2.readBuf());
var ContentDeleted = class {
  /**
   * @param {number} len
   */
  constructor(len) {
    this.len = len;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.len;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return false;
  }
  /**
   * @return {ContentDeleted}
   */
  copy() {
    return new ContentDeleted(this.len);
  }
  /**
   * @param {number} offset
   * @return {ContentDeleted}
   */
  splice(offset) {
    const right = new ContentDeleted(this.len - offset);
    this.len = offset;
    return right;
  }
  /**
   * @param {ContentDeleted} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.len += right.len;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
    addToDeleteSet(transaction.deleteSet, item.id.client, item.id.clock, this.len);
    item.markDeleted();
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder2, offset) {
    encoder2.writeLen(this.len - offset);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 1;
  }
};
var readContentDeleted = (decoder2) => new ContentDeleted(decoder2.readLen());
var createDocFromOpts = (guid, opts) => new Doc({ guid, ...opts, shouldLoad: opts.shouldLoad || opts.autoLoad || false });
var ContentDoc = class {
  /**
   * @param {Doc} doc
   */
  constructor(doc2) {
    if (doc2._item) {
      console.error("This document was already integrated as a sub-document. You should create a second instance instead with the same guid.");
    }
    this.doc = doc2;
    const opts = {};
    this.opts = opts;
    if (!doc2.gc) {
      opts.gc = false;
    }
    if (doc2.autoLoad) {
      opts.autoLoad = true;
    }
    if (doc2.meta !== null) {
      opts.meta = doc2.meta;
    }
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.doc];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentDoc}
   */
  copy() {
    return new ContentDoc(createDocFromOpts(this.doc.guid, this.opts));
  }
  /**
   * @param {number} offset
   * @return {ContentDoc}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentDoc} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
    this.doc._item = item;
    transaction.subdocsAdded.add(this.doc);
    if (this.doc.shouldLoad) {
      transaction.subdocsLoaded.add(this.doc);
    }
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
    if (transaction.subdocsAdded.has(this.doc)) {
      transaction.subdocsAdded.delete(this.doc);
    } else {
      transaction.subdocsRemoved.add(this.doc);
    }
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder2, offset) {
    encoder2.writeString(this.doc.guid);
    encoder2.writeAny(this.opts);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 9;
  }
};
var readContentDoc = (decoder2) => new ContentDoc(createDocFromOpts(decoder2.readString(), decoder2.readAny()));
var ContentEmbed = class {
  /**
   * @param {Object} embed
   */
  constructor(embed) {
    this.embed = embed;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.embed];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentEmbed}
   */
  copy() {
    return new ContentEmbed(this.embed);
  }
  /**
   * @param {number} offset
   * @return {ContentEmbed}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentEmbed} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder2, offset) {
    encoder2.writeJSON(this.embed);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 5;
  }
};
var readContentEmbed = (decoder2) => new ContentEmbed(decoder2.readJSON());
var ContentFormat = class {
  /**
   * @param {string} key
   * @param {Object} value
   */
  constructor(key, value) {
    this.key = key;
    this.value = value;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return false;
  }
  /**
   * @return {ContentFormat}
   */
  copy() {
    return new ContentFormat(this.key, this.value);
  }
  /**
   * @param {number} _offset
   * @return {ContentFormat}
   */
  splice(_offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentFormat} _right
   * @return {boolean}
   */
  mergeWith(_right) {
    return false;
  }
  /**
   * @param {Transaction} _transaction
   * @param {Item} item
   */
  integrate(_transaction, item) {
    const p = (
      /** @type {YText} */
      item.parent
    );
    p._searchMarker = null;
    p._hasFormatting = true;
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder2, offset) {
    encoder2.writeKey(this.key);
    encoder2.writeJSON(this.value);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 6;
  }
};
var readContentFormat = (decoder2) => new ContentFormat(decoder2.readKey(), decoder2.readJSON());
var ContentJSON = class {
  /**
   * @param {Array<any>} arr
   */
  constructor(arr) {
    this.arr = arr;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.arr.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.arr;
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentJSON}
   */
  copy() {
    return new ContentJSON(this.arr);
  }
  /**
   * @param {number} offset
   * @return {ContentJSON}
   */
  splice(offset) {
    const right = new ContentJSON(this.arr.slice(offset));
    this.arr = this.arr.slice(0, offset);
    return right;
  }
  /**
   * @param {ContentJSON} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.arr = this.arr.concat(right.arr);
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder2, offset) {
    const len = this.arr.length;
    encoder2.writeLen(len - offset);
    for (let i2 = offset; i2 < len; i2++) {
      const c = this.arr[i2];
      encoder2.writeString(c === void 0 ? "undefined" : JSON.stringify(c));
    }
  }
  /**
   * @return {number}
   */
  getRef() {
    return 2;
  }
};
var readContentJSON = (decoder2) => {
  const len = decoder2.readLen();
  const cs = [];
  for (let i2 = 0; i2 < len; i2++) {
    const c = decoder2.readString();
    if (c === "undefined") {
      cs.push(void 0);
    } else {
      cs.push(JSON.parse(c));
    }
  }
  return new ContentJSON(cs);
};
var ContentAny = class {
  /**
   * @param {Array<any>} arr
   */
  constructor(arr) {
    this.arr = arr;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.arr.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.arr;
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentAny}
   */
  copy() {
    return new ContentAny(this.arr);
  }
  /**
   * @param {number} offset
   * @return {ContentAny}
   */
  splice(offset) {
    const right = new ContentAny(this.arr.slice(offset));
    this.arr = this.arr.slice(0, offset);
    return right;
  }
  /**
   * @param {ContentAny} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.arr = this.arr.concat(right.arr);
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder2, offset) {
    const len = this.arr.length;
    encoder2.writeLen(len - offset);
    for (let i2 = offset; i2 < len; i2++) {
      const c = this.arr[i2];
      encoder2.writeAny(c);
    }
  }
  /**
   * @return {number}
   */
  getRef() {
    return 8;
  }
};
var readContentAny = (decoder2) => {
  const len = decoder2.readLen();
  const cs = [];
  for (let i2 = 0; i2 < len; i2++) {
    cs.push(decoder2.readAny());
  }
  return new ContentAny(cs);
};
var ContentString = class {
  /**
   * @param {string} str
   */
  constructor(str) {
    this.str = str;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.str.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.str.split("");
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentString}
   */
  copy() {
    return new ContentString(this.str);
  }
  /**
   * @param {number} offset
   * @return {ContentString}
   */
  splice(offset) {
    const right = new ContentString(this.str.slice(offset));
    this.str = this.str.slice(0, offset);
    const firstCharCode = this.str.charCodeAt(offset - 1);
    if (firstCharCode >= 55296 && firstCharCode <= 56319) {
      this.str = this.str.slice(0, offset - 1) + "\uFFFD";
      right.str = "\uFFFD" + right.str.slice(1);
    }
    return right;
  }
  /**
   * @param {ContentString} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.str += right.str;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder2, offset) {
    encoder2.writeString(offset === 0 ? this.str : this.str.slice(offset));
  }
  /**
   * @return {number}
   */
  getRef() {
    return 4;
  }
};
var readContentString = (decoder2) => new ContentString(decoder2.readString());
var typeRefs = [
  readYArray,
  readYMap,
  readYText,
  readYXmlElement,
  readYXmlFragment,
  readYXmlHook,
  readYXmlText
];
var YArrayRefID = 0;
var YMapRefID = 1;
var YTextRefID = 2;
var YXmlElementRefID = 3;
var YXmlFragmentRefID = 4;
var YXmlHookRefID = 5;
var YXmlTextRefID = 6;
var ContentType = class {
  /**
   * @param {AbstractType<any>} type
   */
  constructor(type) {
    this.type = type;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.type];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentType}
   */
  copy() {
    return new ContentType(this.type._copy());
  }
  /**
   * @param {number} offset
   * @return {ContentType}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentType} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
    this.type._integrate(transaction.doc, item);
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
    let item = this.type._start;
    while (item !== null) {
      if (!item.deleted) {
        item.delete(transaction);
      } else if (item.id.clock < (transaction.beforeState.get(item.id.client) || 0)) {
        transaction._mergeStructs.push(item);
      }
      item = item.right;
    }
    this.type._map.forEach((item2) => {
      if (!item2.deleted) {
        item2.delete(transaction);
      } else if (item2.id.clock < (transaction.beforeState.get(item2.id.client) || 0)) {
        transaction._mergeStructs.push(item2);
      }
    });
    transaction.changed.delete(this.type);
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
    let item = this.type._start;
    while (item !== null) {
      item.gc(store, true);
      item = item.right;
    }
    this.type._start = null;
    this.type._map.forEach(
      /** @param {Item | null} item */
      (item2) => {
        while (item2 !== null) {
          item2.gc(store, true);
          item2 = item2.left;
        }
      }
    );
    this.type._map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder2, offset) {
    this.type._write(encoder2);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 7;
  }
};
var readContentType = (decoder2) => new ContentType(typeRefs[decoder2.readTypeRef()](decoder2));
var followRedone = (store, id2) => {
  let nextID = id2;
  let diff2 = 0;
  let item;
  do {
    if (diff2 > 0) {
      nextID = createID(nextID.client, nextID.clock + diff2);
    }
    item = getItem(store, nextID);
    diff2 = nextID.clock - item.id.clock;
    nextID = item.redone;
  } while (nextID !== null && item instanceof Item);
  return {
    item,
    diff: diff2
  };
};
var splitItem = (transaction, leftItem, diff2) => {
  const { client, clock } = leftItem.id;
  const rightItem = new Item(
    createID(client, clock + diff2),
    leftItem,
    createID(client, clock + diff2 - 1),
    leftItem.right,
    leftItem.rightOrigin,
    leftItem.parent,
    leftItem.parentSub,
    leftItem.content.splice(diff2)
  );
  if (leftItem.deleted) {
    rightItem.markDeleted();
  }
  if (leftItem.keep) {
    rightItem.keep = true;
  }
  if (leftItem.redone !== null) {
    rightItem.redone = createID(leftItem.redone.client, leftItem.redone.clock + diff2);
  }
  leftItem.right = rightItem;
  if (rightItem.right !== null) {
    rightItem.right.left = rightItem;
  }
  transaction._mergeStructs.push(rightItem);
  if (rightItem.parentSub !== null && rightItem.right === null) {
    rightItem.parent._map.set(rightItem.parentSub, rightItem);
  }
  leftItem.length = diff2;
  return rightItem;
};
var Item = class extends AbstractStruct {
  /**
   * @param {ID} id
   * @param {Item | null} left
   * @param {ID | null} origin
   * @param {Item | null} right
   * @param {ID | null} rightOrigin
   * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.
   * @param {string | null} parentSub
   * @param {AbstractContent} content
   */
  constructor(id2, left, origin, right, rightOrigin, parent, parentSub, content) {
    super(id2, content.getLength());
    this.origin = origin;
    this.left = left;
    this.right = right;
    this.rightOrigin = rightOrigin;
    this.parent = parent;
    this.parentSub = parentSub;
    this.redone = null;
    this.content = content;
    this.info = this.content.isCountable() ? BIT2 : 0;
  }
  /**
   * This is used to mark the item as an indexed fast-search marker
   *
   * @type {boolean}
   */
  set marker(isMarked) {
    if ((this.info & BIT4) > 0 !== isMarked) {
      this.info ^= BIT4;
    }
  }
  get marker() {
    return (this.info & BIT4) > 0;
  }
  /**
   * If true, do not garbage collect this Item.
   */
  get keep() {
    return (this.info & BIT1) > 0;
  }
  set keep(doKeep) {
    if (this.keep !== doKeep) {
      this.info ^= BIT1;
    }
  }
  get countable() {
    return (this.info & BIT2) > 0;
  }
  /**
   * Whether this item was deleted or not.
   * @type {Boolean}
   */
  get deleted() {
    return (this.info & BIT3) > 0;
  }
  set deleted(doDelete) {
    if (this.deleted !== doDelete) {
      this.info ^= BIT3;
    }
  }
  markDeleted() {
    this.info |= BIT3;
  }
  /**
   * Return the creator clientID of the missing op or define missing items and return null.
   *
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(transaction, store) {
    if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= getState(store, this.origin.client)) {
      return this.origin.client;
    }
    if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= getState(store, this.rightOrigin.client)) {
      return this.rightOrigin.client;
    }
    if (this.parent && this.parent.constructor === ID && this.id.client !== this.parent.client && this.parent.clock >= getState(store, this.parent.client)) {
      return this.parent.client;
    }
    if (this.origin) {
      this.left = getItemCleanEnd(transaction, store, this.origin);
      this.origin = this.left.lastId;
    }
    if (this.rightOrigin) {
      this.right = getItemCleanStart(transaction, this.rightOrigin);
      this.rightOrigin = this.right.id;
    }
    if (this.left && this.left.constructor === GC || this.right && this.right.constructor === GC) {
      this.parent = null;
    } else if (!this.parent) {
      if (this.left && this.left.constructor === Item) {
        this.parent = this.left.parent;
        this.parentSub = this.left.parentSub;
      }
      if (this.right && this.right.constructor === Item) {
        this.parent = this.right.parent;
        this.parentSub = this.right.parentSub;
      }
    } else if (this.parent.constructor === ID) {
      const parentItem = getItem(store, this.parent);
      if (parentItem.constructor === GC) {
        this.parent = null;
      } else {
        this.parent = /** @type {ContentType} */
        parentItem.content.type;
      }
    }
    return null;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    if (offset > 0) {
      this.id.clock += offset;
      this.left = getItemCleanEnd(transaction, transaction.doc.store, createID(this.id.client, this.id.clock - 1));
      this.origin = this.left.lastId;
      this.content = this.content.splice(offset);
      this.length -= offset;
    }
    if (this.parent) {
      if (!this.left && (!this.right || this.right.left !== null) || this.left && this.left.right !== this.right) {
        let left = this.left;
        let o;
        if (left !== null) {
          o = left.right;
        } else if (this.parentSub !== null) {
          o = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null;
          while (o !== null && o.left !== null) {
            o = o.left;
          }
        } else {
          o = /** @type {AbstractType<any>} */
          this.parent._start;
        }
        const conflictingItems = /* @__PURE__ */ new Set();
        const itemsBeforeOrigin = /* @__PURE__ */ new Set();
        while (o !== null && o !== this.right) {
          itemsBeforeOrigin.add(o);
          conflictingItems.add(o);
          if (compareIDs(this.origin, o.origin)) {
            if (o.id.client < this.id.client) {
              left = o;
              conflictingItems.clear();
            } else if (compareIDs(this.rightOrigin, o.rightOrigin)) {
              break;
            }
          } else if (o.origin !== null && itemsBeforeOrigin.has(getItem(transaction.doc.store, o.origin))) {
            if (!conflictingItems.has(getItem(transaction.doc.store, o.origin))) {
              left = o;
              conflictingItems.clear();
            }
          } else {
            break;
          }
          o = o.right;
        }
        this.left = left;
      }
      if (this.left !== null) {
        const right = this.left.right;
        this.right = right;
        this.left.right = this;
      } else {
        let r;
        if (this.parentSub !== null) {
          r = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null;
          while (r !== null && r.left !== null) {
            r = r.left;
          }
        } else {
          r = /** @type {AbstractType<any>} */
          this.parent._start;
          this.parent._start = this;
        }
        this.right = r;
      }
      if (this.right !== null) {
        this.right.left = this;
      } else if (this.parentSub !== null) {
        this.parent._map.set(this.parentSub, this);
        if (this.left !== null) {
          this.left.delete(transaction);
        }
      }
      if (this.parentSub === null && this.countable && !this.deleted) {
        this.parent._length += this.length;
      }
      addStruct(transaction.doc.store, this);
      this.content.integrate(transaction, this);
      addChangedTypeToTransaction(
        transaction,
        /** @type {AbstractType<any>} */
        this.parent,
        this.parentSub
      );
      if (
        /** @type {AbstractType<any>} */
        this.parent._item !== null && /** @type {AbstractType<any>} */
        this.parent._item.deleted || this.parentSub !== null && this.right !== null
      ) {
        this.delete(transaction);
      }
    } else {
      new GC(this.id, this.length).integrate(transaction, 0);
    }
  }
  /**
   * Returns the next non-deleted item
   */
  get next() {
    let n = this.right;
    while (n !== null && n.deleted) {
      n = n.right;
    }
    return n;
  }
  /**
   * Returns the previous non-deleted item
   */
  get prev() {
    let n = this.left;
    while (n !== null && n.deleted) {
      n = n.left;
    }
    return n;
  }
  /**
   * Computes the last content address of this Item.
   */
  get lastId() {
    return this.length === 1 ? this.id : createID(this.id.client, this.id.clock + this.length - 1);
  }
  /**
   * Try to merge two items
   *
   * @param {Item} right
   * @return {boolean}
   */
  mergeWith(right) {
    if (this.constructor === right.constructor && compareIDs(right.origin, this.lastId) && this.right === right && compareIDs(this.rightOrigin, right.rightOrigin) && this.id.client === right.id.client && this.id.clock + this.length === right.id.clock && this.deleted === right.deleted && this.redone === null && right.redone === null && this.content.constructor === right.content.constructor && this.content.mergeWith(right.content)) {
      const searchMarker = (
        /** @type {AbstractType<any>} */
        this.parent._searchMarker
      );
      if (searchMarker) {
        searchMarker.forEach((marker) => {
          if (marker.p === right) {
            marker.p = this;
            if (!this.deleted && this.countable) {
              marker.index -= this.length;
            }
          }
        });
      }
      if (right.keep) {
        this.keep = true;
      }
      this.right = right.right;
      if (this.right !== null) {
        this.right.left = this;
      }
      this.length += right.length;
      return true;
    }
    return false;
  }
  /**
   * Mark this Item as deleted.
   *
   * @param {Transaction} transaction
   */
  delete(transaction) {
    if (!this.deleted) {
      const parent = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      if (this.countable && this.parentSub === null) {
        parent._length -= this.length;
      }
      this.markDeleted();
      addToDeleteSet(transaction.deleteSet, this.id.client, this.id.clock, this.length);
      addChangedTypeToTransaction(transaction, parent, this.parentSub);
      this.content.delete(transaction);
    }
  }
  /**
   * @param {StructStore} store
   * @param {boolean} parentGCd
   */
  gc(store, parentGCd) {
    if (!this.deleted) {
      throw unexpectedCase();
    }
    this.content.gc(store);
    if (parentGCd) {
      replaceStruct(store, this, new GC(this.id, this.length));
    } else {
      this.content = new ContentDeleted(this.length);
    }
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   */
  write(encoder2, offset) {
    const origin = offset > 0 ? createID(this.id.client, this.id.clock + offset - 1) : this.origin;
    const rightOrigin = this.rightOrigin;
    const parentSub = this.parentSub;
    const info = this.content.getRef() & BITS5 | (origin === null ? 0 : BIT8) | // origin is defined
    (rightOrigin === null ? 0 : BIT7) | // right origin is defined
    (parentSub === null ? 0 : BIT6);
    encoder2.writeInfo(info);
    if (origin !== null) {
      encoder2.writeLeftID(origin);
    }
    if (rightOrigin !== null) {
      encoder2.writeRightID(rightOrigin);
    }
    if (origin === null && rightOrigin === null) {
      const parent = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      if (parent._item !== void 0) {
        const parentItem = parent._item;
        if (parentItem === null) {
          const ykey = findRootTypeKey(parent);
          encoder2.writeParentInfo(true);
          encoder2.writeString(ykey);
        } else {
          encoder2.writeParentInfo(false);
          encoder2.writeLeftID(parentItem.id);
        }
      } else if (parent.constructor === String) {
        encoder2.writeParentInfo(true);
        encoder2.writeString(parent);
      } else if (parent.constructor === ID) {
        encoder2.writeParentInfo(false);
        encoder2.writeLeftID(parent);
      } else {
        unexpectedCase();
      }
      if (parentSub !== null) {
        encoder2.writeString(parentSub);
      }
    }
    this.content.write(encoder2, offset);
  }
};
var readItemContent = (decoder2, info) => contentRefs[info & BITS5](decoder2);
var contentRefs = [
  () => {
    unexpectedCase();
  },
  // GC is not ItemContent
  readContentDeleted,
  // 1
  readContentJSON,
  // 2
  readContentBinary,
  // 3
  readContentString,
  // 4
  readContentEmbed,
  // 5
  readContentFormat,
  // 6
  readContentType,
  // 7
  readContentAny,
  // 8
  readContentDoc,
  // 9
  () => {
    unexpectedCase();
  }
  // 10 - Skip is not ItemContent
];
var structSkipRefNumber = 10;
var Skip = class extends AbstractStruct {
  get deleted() {
    return true;
  }
  delete() {
  }
  /**
   * @param {Skip} right
   * @return {boolean}
   */
  mergeWith(right) {
    if (this.constructor !== right.constructor) {
      return false;
    }
    this.length += right.length;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    unexpectedCase();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder2, offset) {
    encoder2.writeInfo(structSkipRefNumber);
    writeVarUint(encoder2.restEncoder, this.length - offset);
  }
  /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(transaction, store) {
    return null;
  }
};
var glo = (
  /** @type {any} */
  typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {}
);
var importIdentifier = "__ $YJS$ __";
if (glo[importIdentifier] === true) {
  console.error("Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438");
}
glo[importIdentifier] = true;

// src/SharedFolder.ts
var import_obsidian = require("obsidian");

// node_modules/lib0/indexeddb.js
var rtop = (request) => create4((resolve, reject) => {
  request.onerror = (event) => reject(new Error(event.target.error));
  request.onsuccess = (event) => resolve(event.target.result);
});
var openDB = (name, initDB) => create4((resolve, reject) => {
  const request = indexedDB.open(name);
  request.onupgradeneeded = (event) => initDB(event.target.result);
  request.onerror = (event) => reject(create3(event.target.error));
  request.onsuccess = (event) => {
    const db = event.target.result;
    db.onversionchange = () => {
      db.close();
    };
    resolve(db);
  };
});
var deleteDB = (name) => rtop(indexedDB.deleteDatabase(name));
var createStores = (db, definitions) => definitions.forEach(
  (d) => (
    // @ts-ignore
    db.createObjectStore.apply(db, d)
  )
);
var transact2 = (db, stores, access = "readwrite") => {
  const transaction = db.transaction(stores, access);
  return stores.map((store) => getStore(transaction, store));
};
var count = (store, range) => rtop(store.count(range));
var get = (store, key) => rtop(store.get(key));
var del = (store, key) => rtop(store.delete(key));
var put = (store, item, key) => rtop(store.put(item, key));
var addAutoKey = (store, item) => rtop(store.add(item));
var getAll = (store, range, limit) => rtop(store.getAll(range, limit));
var queryFirst = (store, query, direction) => {
  let first = null;
  return iterateKeys(store, query, (key) => {
    first = key;
    return false;
  }, direction).then(() => first);
};
var getLastKey = (store, range = null) => queryFirst(store, range, "prev");
var iterateOnRequest = (request, f) => create4((resolve, reject) => {
  request.onerror = reject;
  request.onsuccess = async (event) => {
    const cursor = event.target.result;
    if (cursor === null || await f(cursor) === false) {
      return resolve();
    }
    cursor.continue();
  };
});
var iterateKeys = (store, keyrange, f, direction = "next") => iterateOnRequest(store.openKeyCursor(keyrange, direction), (cursor) => f(cursor.key));
var getStore = (t2, store) => t2.objectStore(store);
var createIDBKeyRangeUpperBound = (upper, upperOpen) => IDBKeyRange.upperBound(upper, upperOpen);
var createIDBKeyRangeLowerBound = (lower, lowerOpen) => IDBKeyRange.lowerBound(lower, lowerOpen);

// node_modules/y-indexeddb/src/y-indexeddb.js
var customStoreName = "custom";
var updatesStoreName = "updates";
var PREFERRED_TRIM_SIZE = 500;
var fetchUpdates = (idbPersistence, beforeApplyUpdatesCallback = () => {
}, afterApplyUpdatesCallback = () => {
}) => {
  const [updatesStore] = transact2(
    /** @type {IDBDatabase} */
    idbPersistence.db,
    [updatesStoreName]
  );
  return getAll(updatesStore, createIDBKeyRangeLowerBound(idbPersistence._dbref, false)).then((updates) => {
    if (!idbPersistence._destroyed) {
      beforeApplyUpdatesCallback(updatesStore);
      transact(idbPersistence.doc, () => {
        updates.forEach((val) => applyUpdate(idbPersistence.doc, val));
      }, idbPersistence, false);
      afterApplyUpdatesCallback(updatesStore);
    }
  }).then(() => getLastKey(updatesStore).then((lastKey) => {
    idbPersistence._dbref = lastKey + 1;
  })).then(() => count(updatesStore).then((cnt) => {
    idbPersistence._dbsize = cnt;
  })).then(() => updatesStore);
};
var storeState = (idbPersistence, forceStore = true) => fetchUpdates(idbPersistence).then((updatesStore) => {
  if (forceStore || idbPersistence._dbsize >= PREFERRED_TRIM_SIZE) {
    addAutoKey(updatesStore, encodeStateAsUpdate(idbPersistence.doc)).then(() => del(updatesStore, createIDBKeyRangeUpperBound(idbPersistence._dbref, true))).then(() => count(updatesStore).then((cnt) => {
      idbPersistence._dbsize = cnt;
    }));
  }
});
var IndexeddbPersistence = class extends Observable {
  /**
   * @param {string} name
   * @param {Y.Doc} doc
   */
  constructor(name, doc2) {
    super();
    this.doc = doc2;
    this.name = name;
    this._dbref = 0;
    this._dbsize = 0;
    this._destroyed = false;
    this.db = null;
    this.synced = false;
    this._db = openDB(
      name,
      (db) => createStores(db, [
        ["updates", { autoIncrement: true }],
        ["custom"]
      ])
    );
    this.whenSynced = create4((resolve) => this.on("synced", () => resolve(this)));
    this._db.then((db) => {
      this.db = db;
      const beforeApplyUpdatesCallback = (updatesStore) => addAutoKey(updatesStore, encodeStateAsUpdate(doc2));
      const afterApplyUpdatesCallback = () => {
        if (this._destroyed)
          return this;
        this.synced = true;
        this.emit("synced", [this]);
      };
      fetchUpdates(this, beforeApplyUpdatesCallback, afterApplyUpdatesCallback);
    });
    this._storeTimeout = 1e3;
    this._storeTimeoutId = null;
    this._storeUpdate = (update2, origin) => {
      if (this.db && origin !== this) {
        const [updatesStore] = transact2(
          /** @type {IDBDatabase} */
          this.db,
          [updatesStoreName]
        );
        addAutoKey(updatesStore, update2);
        if (++this._dbsize >= PREFERRED_TRIM_SIZE) {
          if (this._storeTimeoutId !== null) {
            clearTimeout(this._storeTimeoutId);
          }
          this._storeTimeoutId = setTimeout(() => {
            storeState(this, false);
            this._storeTimeoutId = null;
          }, this._storeTimeout);
        }
      }
    };
    doc2.on("update", this._storeUpdate);
    this.destroy = this.destroy.bind(this);
    doc2.on("destroy", this.destroy);
  }
  destroy() {
    if (this._storeTimeoutId) {
      clearTimeout(this._storeTimeoutId);
    }
    this.doc.off("update", this._storeUpdate);
    this.doc.off("destroy", this.destroy);
    this._destroyed = true;
    return this._db.then((db) => {
      db.close();
    });
  }
  /**
   * Destroys this instance and removes all data from indexeddb.
   *
   * @return {Promise<void>}
   */
  clearData() {
    return this.destroy().then(() => {
      deleteDB(this.name);
    });
  }
  /**
   * @param {String | number | ArrayBuffer | Date} key
   * @return {Promise<String | number | ArrayBuffer | Date | any>}
   */
  get(key) {
    return this._db.then((db) => {
      const [custom] = transact2(db, [customStoreName], "readonly");
      return get(custom, key);
    });
  }
  /**
   * @param {String | number | ArrayBuffer | Date} key
   * @param {String | number | ArrayBuffer | Date} value
   * @return {Promise<String | number | ArrayBuffer | Date>}
   */
  set(key, value) {
    return this._db.then((db) => {
      const [custom] = transact2(db, [customStoreName]);
      return put(custom, value, key);
    });
  }
  /**
   * @param {String | number | ArrayBuffer | Date} key
   * @return {Promise<undefined>}
   */
  del(key) {
    return this._db.then((db) => {
      const [custom] = transact2(db, [customStoreName]);
      return del(custom, key);
    });
  }
};

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues2;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues2) {
    getRandomValues2 = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues2) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues2(rnds8);
}

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i2 = 0; i2 < 256; ++i2) {
  byteToHex.push((i2 + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i2 = 0; i2 < 16; ++i2) {
      buf[offset + i2] = rnds[i2];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// src/SharedFolder.ts
var import_path_browserify = __toESM(require_path_browserify());

// node_modules/y-protocols/sync.js
var messageYjsSyncStep1 = 0;
var messageYjsSyncStep2 = 1;
var messageYjsUpdate = 2;
var writeSyncStep1 = (encoder2, doc2) => {
  writeVarUint(encoder2, messageYjsSyncStep1);
  const sv = encodeStateVector(doc2);
  writeVarUint8Array(encoder2, sv);
};
var writeSyncStep2 = (encoder2, doc2, encodedStateVector) => {
  writeVarUint(encoder2, messageYjsSyncStep2);
  writeVarUint8Array(encoder2, encodeStateAsUpdate(doc2, encodedStateVector));
};
var readSyncStep1 = (decoder2, encoder2, doc2) => writeSyncStep2(encoder2, doc2, readVarUint8Array(decoder2));
var readSyncStep2 = (decoder2, doc2, transactionOrigin) => {
  try {
    applyUpdate(doc2, readVarUint8Array(decoder2), transactionOrigin);
  } catch (error) {
    console.error("Caught error while handling a Yjs update", error);
  }
};
var writeUpdate = (encoder2, update2) => {
  writeVarUint(encoder2, messageYjsUpdate);
  writeVarUint8Array(encoder2, update2);
};
var readUpdate = readSyncStep2;
var readSyncMessage = (decoder2, encoder2, doc2, transactionOrigin) => {
  const messageType = readVarUint(decoder2);
  switch (messageType) {
    case messageYjsSyncStep1:
      readSyncStep1(decoder2, encoder2, doc2);
      break;
    case messageYjsSyncStep2:
      readSyncStep2(decoder2, doc2, transactionOrigin);
      break;
    case messageYjsUpdate:
      readUpdate(decoder2, doc2, transactionOrigin);
      break;
    default:
      throw new Error("Unknown message type");
  }
  return messageType;
};

// node_modules/y-protocols/auth.js
var messagePermissionDenied = 0;
var readAuthMessage = (decoder2, y, permissionDeniedHandler2) => {
  switch (readVarUint(decoder2)) {
    case messagePermissionDenied:
      permissionDeniedHandler2(y, readVarString(decoder2));
  }
};

// node_modules/y-protocols/awareness.js
var outdatedTimeout = 3e4;
var Awareness = class extends Observable {
  /**
   * @param {Y.Doc} doc
   */
  constructor(doc2) {
    super();
    this.doc = doc2;
    this.clientID = doc2.clientID;
    this.states = /* @__PURE__ */ new Map();
    this.meta = /* @__PURE__ */ new Map();
    this._checkInterval = /** @type {any} */
    setInterval(() => {
      const now2 = getUnixTime();
      if (this.getLocalState() !== null && outdatedTimeout / 2 <= now2 - /** @type {{lastUpdated:number}} */
      this.meta.get(this.clientID).lastUpdated) {
        this.setLocalState(this.getLocalState());
      }
      const remove = [];
      this.meta.forEach((meta, clientid) => {
        if (clientid !== this.clientID && outdatedTimeout <= now2 - meta.lastUpdated && this.states.has(clientid)) {
          remove.push(clientid);
        }
      });
      if (remove.length > 0) {
        removeAwarenessStates(this, remove, "timeout");
      }
    }, floor(outdatedTimeout / 10));
    doc2.on("destroy", () => {
      this.destroy();
    });
    this.setLocalState({});
  }
  destroy() {
    this.emit("destroy", [this]);
    this.setLocalState(null);
    super.destroy();
    clearInterval(this._checkInterval);
  }
  /**
   * @return {Object<string,any>|null}
   */
  getLocalState() {
    return this.states.get(this.clientID) || null;
  }
  /**
   * @param {Object<string,any>|null} state
   */
  setLocalState(state) {
    const clientID = this.clientID;
    const currLocalMeta = this.meta.get(clientID);
    const clock = currLocalMeta === void 0 ? 0 : currLocalMeta.clock + 1;
    const prevState = this.states.get(clientID);
    if (state === null) {
      this.states.delete(clientID);
    } else {
      this.states.set(clientID, state);
    }
    this.meta.set(clientID, {
      clock,
      lastUpdated: getUnixTime()
    });
    const added = [];
    const updated = [];
    const filteredUpdated = [];
    const removed = [];
    if (state === null) {
      removed.push(clientID);
    } else if (prevState == null) {
      if (state != null) {
        added.push(clientID);
      }
    } else {
      updated.push(clientID);
      if (!equalityDeep(prevState, state)) {
        filteredUpdated.push(clientID);
      }
    }
    if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {
      this.emit("change", [{ added, updated: filteredUpdated, removed }, "local"]);
    }
    this.emit("update", [{ added, updated, removed }, "local"]);
  }
  /**
   * @param {string} field
   * @param {any} value
   */
  setLocalStateField(field, value) {
    const state = this.getLocalState();
    if (state !== null) {
      this.setLocalState({
        ...state,
        [field]: value
      });
    }
  }
  /**
   * @return {Map<number,Object<string,any>>}
   */
  getStates() {
    return this.states;
  }
};
var removeAwarenessStates = (awareness, clients, origin) => {
  const removed = [];
  for (let i2 = 0; i2 < clients.length; i2++) {
    const clientID = clients[i2];
    if (awareness.states.has(clientID)) {
      awareness.states.delete(clientID);
      if (clientID === awareness.clientID) {
        const curMeta = (
          /** @type {MetaClientState} */
          awareness.meta.get(clientID)
        );
        awareness.meta.set(clientID, {
          clock: curMeta.clock + 1,
          lastUpdated: getUnixTime()
        });
      }
      removed.push(clientID);
    }
  }
  if (removed.length > 0) {
    awareness.emit("change", [{ added: [], updated: [], removed }, origin]);
    awareness.emit("update", [{ added: [], updated: [], removed }, origin]);
  }
};
var encodeAwarenessUpdate = (awareness, clients, states = awareness.states) => {
  const len = clients.length;
  const encoder2 = createEncoder();
  writeVarUint(encoder2, len);
  for (let i2 = 0; i2 < len; i2++) {
    const clientID = clients[i2];
    const state = states.get(clientID) || null;
    const clock = (
      /** @type {MetaClientState} */
      awareness.meta.get(clientID).clock
    );
    writeVarUint(encoder2, clientID);
    writeVarUint(encoder2, clock);
    writeVarString(encoder2, JSON.stringify(state));
  }
  return toUint8Array(encoder2);
};
var applyAwarenessUpdate = (awareness, update2, origin) => {
  const decoder2 = createDecoder(update2);
  const timestamp = getUnixTime();
  const added = [];
  const updated = [];
  const filteredUpdated = [];
  const removed = [];
  const len = readVarUint(decoder2);
  for (let i2 = 0; i2 < len; i2++) {
    const clientID = readVarUint(decoder2);
    let clock = readVarUint(decoder2);
    const state = JSON.parse(readVarString(decoder2));
    const clientMeta = awareness.meta.get(clientID);
    const prevState = awareness.states.get(clientID);
    const currClock = clientMeta === void 0 ? 0 : clientMeta.clock;
    if (currClock < clock || currClock === clock && state === null && awareness.states.has(clientID)) {
      if (state === null) {
        if (clientID === awareness.clientID && awareness.getLocalState() != null) {
          clock++;
        } else {
          awareness.states.delete(clientID);
        }
      } else {
        awareness.states.set(clientID, state);
      }
      awareness.meta.set(clientID, {
        clock,
        lastUpdated: timestamp
      });
      if (clientMeta === void 0 && state !== null) {
        added.push(clientID);
      } else if (clientMeta !== void 0 && state === null) {
        removed.push(clientID);
      } else if (state !== null) {
        if (!equalityDeep(state, prevState)) {
          filteredUpdated.push(clientID);
        }
        updated.push(clientID);
      }
    }
  }
  if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {
    awareness.emit("change", [{
      added,
      updated: filteredUpdated,
      removed
    }, origin]);
  }
  if (added.length > 0 || updated.length > 0 || removed.length > 0) {
    awareness.emit("update", [{
      added,
      updated,
      removed
    }, origin]);
  }
};

// node_modules/@y-sweet/client/dist/main.mjs
var create7 = () => /* @__PURE__ */ new Map();
var setIfUndefined2 = (map22, key, createT) => {
  let set = map22.get(key);
  if (set === void 0) {
    map22.set(key, set = createT());
  }
  return set;
};
var create22 = () => /* @__PURE__ */ new Set();
var from2 = Array.from;
var isArray2 = Array.isArray;
var fromCharCode2 = String.fromCharCode;
var fromCodePoint2 = String.fromCodePoint;
var MAX_UTF16_CHARACTER2 = fromCharCode2(65535);
var toLowerCase2 = (s2) => s2.toLowerCase();
var trimLeftRegex2 = /^\s*/g;
var trimLeft2 = (s2) => s2.replace(trimLeftRegex2, "");
var fromCamelCaseRegex2 = /([A-Z])/g;
var fromCamelCase2 = (s2, separator) => trimLeft2(s2.replace(fromCamelCaseRegex2, (match) => `${separator}${toLowerCase2(match)}`));
var _encodeUtf8Polyfill2 = (str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  const buf = new Uint8Array(len);
  for (let i2 = 0; i2 < len; i2++) {
    buf[i2] = /** @type {number} */
    encodedString.codePointAt(i2);
  }
  return buf;
};
var utf8TextEncoder2 = (
  /** @type {TextEncoder} */
  typeof TextEncoder !== "undefined" ? new TextEncoder() : null
);
var _encodeUtf8Native2 = (str) => utf8TextEncoder2.encode(str);
var encodeUtf82 = utf8TextEncoder2 ? _encodeUtf8Native2 : _encodeUtf8Polyfill2;
var utf8TextDecoder2 = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8", { fatal: true, ignoreBOM: true });
if (utf8TextDecoder2 && utf8TextDecoder2.decode(new Uint8Array()).length === 1) {
  utf8TextDecoder2 = null;
}
var undefinedToNull2 = (v) => v === void 0 ? null : v;
var VarStoragePolyfill2 = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {string} key
   * @param {any} newValue
   */
  setItem(key, newValue) {
    this.map.set(key, newValue);
  }
  /**
   * @param {string} key
   */
  getItem(key) {
    return this.map.get(key);
  }
};
var _localStorage2 = new VarStoragePolyfill2();
var usePolyfill2 = true;
try {
  if (typeof localStorage !== "undefined") {
    _localStorage2 = localStorage;
    usePolyfill2 = false;
  }
} catch (e2) {
}
var varStorage2 = _localStorage2;
var onChange = (eventHandler) => usePolyfill2 || addEventListener(
  "storage",
  /** @type {any} */
  eventHandler
);
var offChange = (eventHandler) => usePolyfill2 || removeEventListener(
  "storage",
  /** @type {any} */
  eventHandler
);
var map2 = (obj, f) => {
  const results = [];
  for (const key in obj) {
    results.push(f(obj[key], key));
  }
  return results;
};
var isOneOf2 = (value, options) => options.includes(value);
var isNode2 = typeof process !== "undefined" && process.release && /node|io\.js/.test(process.release.name);
var isBrowser2 = typeof window !== "undefined" && typeof document !== "undefined" && !isNode2;
var isMac2 = typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
var params2;
var args2 = [];
var computeParams2 = () => {
  if (params2 === void 0) {
    if (isNode2) {
      params2 = create7();
      const pargs = process.argv;
      let currParamName = null;
      for (let i2 = 0; i2 < pargs.length; i2++) {
        const parg = pargs[i2];
        if (parg[0] === "-") {
          if (currParamName !== null) {
            params2.set(currParamName, "");
          }
          currParamName = parg;
        } else {
          if (currParamName !== null) {
            params2.set(currParamName, parg);
            currParamName = null;
          } else {
            args2.push(parg);
          }
        }
      }
      if (currParamName !== null) {
        params2.set(currParamName, "");
      }
    } else if (typeof location === "object") {
      params2 = create7();
      (location.search || "?").slice(1).split("&").forEach((kv) => {
        if (kv.length !== 0) {
          const [key, value] = kv.split("=");
          params2.set(`--${fromCamelCase2(key, "-")}`, value);
          params2.set(`-${fromCamelCase2(key, "-")}`, value);
        }
      });
    } else {
      params2 = create7();
    }
  }
  return params2;
};
var hasParam2 = (name) => computeParams2().has(name);
var getVariable2 = (name) => isNode2 ? undefinedToNull2(process.env[name.toUpperCase()]) : undefinedToNull2(varStorage2.getItem(name));
var hasConf2 = (name) => hasParam2("--" + name) || getVariable2(name) !== null;
var production2 = hasConf2("production");
var forceColor2 = isNode2 && isOneOf2(process.env.FORCE_COLOR, ["true", "1", "2"]);
var supportsColor2 = !hasParam2("no-colors") && (!isNode2 || process.stdout.isTTY || forceColor2) && (!isNode2 || hasParam2("color") || forceColor2 || getVariable2("COLORTERM") !== null || (getVariable2("TERM") || "").includes("color"));
var floor2 = Math.floor;
var min2 = (a, b) => a < b ? a : b;
var max2 = (a, b) => a > b ? a : b;
var isNaN4 = Number.isNaN;
var pow = Math.pow;
var BIT82 = 128;
var BIT182 = 1 << 17;
var BIT192 = 1 << 18;
var BIT202 = 1 << 19;
var BIT212 = 1 << 20;
var BIT222 = 1 << 21;
var BIT232 = 1 << 22;
var BIT242 = 1 << 23;
var BIT252 = 1 << 24;
var BIT262 = 1 << 25;
var BIT272 = 1 << 26;
var BIT282 = 1 << 27;
var BIT292 = 1 << 28;
var BIT302 = 1 << 29;
var BIT312 = 1 << 30;
var BIT322 = 1 << 31;
var BITS72 = 127;
var BITS172 = BIT182 - 1;
var BITS182 = BIT192 - 1;
var BITS192 = BIT202 - 1;
var BITS202 = BIT212 - 1;
var BITS212 = BIT222 - 1;
var BITS222 = BIT232 - 1;
var BITS232 = BIT242 - 1;
var BITS242 = BIT252 - 1;
var BITS252 = BIT262 - 1;
var BITS262 = BIT272 - 1;
var BITS272 = BIT282 - 1;
var BITS282 = BIT292 - 1;
var BITS292 = BIT302 - 1;
var BITS302 = BIT312 - 1;
var MAX_SAFE_INTEGER2 = Number.MAX_SAFE_INTEGER;
var MIN_SAFE_INTEGER2 = Number.MIN_SAFE_INTEGER;
var LOWEST_INT322 = 1 << 31;
var isInteger2 = Number.isInteger || ((num) => typeof num === "number" && isFinite(num) && floor2(num) === num);
var isNaN22 = Number.isNaN;
var parseInt3 = Number.parseInt;
var Encoder2 = class {
  constructor() {
    this.cpos = 0;
    this.cbuf = new Uint8Array(100);
    this.bufs = [];
  }
};
var createEncoder2 = () => new Encoder2();
var length3 = (encoder2) => {
  let len = encoder2.cpos;
  for (let i2 = 0; i2 < encoder2.bufs.length; i2++) {
    len += encoder2.bufs[i2].length;
  }
  return len;
};
var toUint8Array2 = (encoder2) => {
  const uint8arr = new Uint8Array(length3(encoder2));
  let curPos = 0;
  for (let i2 = 0; i2 < encoder2.bufs.length; i2++) {
    const d = encoder2.bufs[i2];
    uint8arr.set(d, curPos);
    curPos += d.length;
  }
  uint8arr.set(createUint8ArrayViewFromArrayBuffer(encoder2.cbuf.buffer, 0, encoder2.cpos), curPos);
  return uint8arr;
};
var write2 = (encoder2, num) => {
  const bufferLen = encoder2.cbuf.length;
  if (encoder2.cpos === bufferLen) {
    encoder2.bufs.push(encoder2.cbuf);
    encoder2.cbuf = new Uint8Array(bufferLen * 2);
    encoder2.cpos = 0;
  }
  encoder2.cbuf[encoder2.cpos++] = num;
};
var writeVarUint2 = (encoder2, num) => {
  while (num > BITS72) {
    write2(encoder2, BIT82 | BITS72 & num);
    num = floor2(num / 128);
  }
  write2(encoder2, BITS72 & num);
};
var _strBuffer2 = new Uint8Array(3e4);
var _maxStrBSize2 = _strBuffer2.length / 3;
var _writeVarStringNative2 = (encoder2, str) => {
  if (str.length < _maxStrBSize2) {
    const written = utf8TextEncoder2.encodeInto(str, _strBuffer2).written || 0;
    writeVarUint2(encoder2, written);
    for (let i2 = 0; i2 < written; i2++) {
      write2(encoder2, _strBuffer2[i2]);
    }
  } else {
    writeVarUint8Array2(encoder2, encodeUtf82(str));
  }
};
var _writeVarStringPolyfill2 = (encoder2, str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  writeVarUint2(encoder2, len);
  for (let i2 = 0; i2 < len; i2++) {
    write2(
      encoder2,
      /** @type {number} */
      encodedString.codePointAt(i2)
    );
  }
};
var writeVarString2 = utf8TextEncoder2 && /** @type {any} */
utf8TextEncoder2.encodeInto ? _writeVarStringNative2 : _writeVarStringPolyfill2;
var writeUint8Array2 = (encoder2, uint8Array) => {
  const bufferLen = encoder2.cbuf.length;
  const cpos = encoder2.cpos;
  const leftCopyLen = min2(bufferLen - cpos, uint8Array.length);
  const rightCopyLen = uint8Array.length - leftCopyLen;
  encoder2.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);
  encoder2.cpos += leftCopyLen;
  if (rightCopyLen > 0) {
    encoder2.bufs.push(encoder2.cbuf);
    encoder2.cbuf = new Uint8Array(max2(bufferLen * 2, rightCopyLen));
    encoder2.cbuf.set(uint8Array.subarray(leftCopyLen));
    encoder2.cpos = rightCopyLen;
  }
};
var writeVarUint8Array2 = (encoder2, uint8Array) => {
  writeVarUint2(encoder2, uint8Array.byteLength);
  writeUint8Array2(encoder2, uint8Array);
};
var floatTestBed2 = new DataView(new ArrayBuffer(4));
var create32 = (s2) => new Error(s2);
var errorUnexpectedEndOfArray2 = create32("Unexpected end of array");
var errorIntegerOutOfRange2 = create32("Integer out of Range");
var Decoder2 = class {
  /**
   * @param {Uint8Array} uint8Array Binary data to decode
   */
  constructor(uint8Array) {
    this.arr = uint8Array;
    this.pos = 0;
  }
};
var createDecoder2 = (uint8Array) => new Decoder2(uint8Array);
var readUint8Array2 = (decoder2, len) => {
  const view = createUint8ArrayViewFromArrayBuffer(decoder2.arr.buffer, decoder2.pos + decoder2.arr.byteOffset, len);
  decoder2.pos += len;
  return view;
};
var readVarUint8Array2 = (decoder2) => readUint8Array2(decoder2, readVarUint2(decoder2));
var readVarUint2 = (decoder2) => {
  let num = 0;
  let mult = 1;
  const len = decoder2.arr.length;
  while (decoder2.pos < len) {
    const r = decoder2.arr[decoder2.pos++];
    num = num + (r & BITS72) * mult;
    mult *= 128;
    if (r < BIT82) {
      return num;
    }
    if (num > MAX_SAFE_INTEGER2) {
      throw errorIntegerOutOfRange2;
    }
  }
  throw errorUnexpectedEndOfArray2;
};
var createUint8ArrayFromLen2 = (len) => new Uint8Array(len);
var createUint8ArrayViewFromArrayBuffer = (buffer, byteOffset, length22) => new Uint8Array(buffer, byteOffset, length22);
var createUint8ArrayFromArrayBuffer = (buffer) => new Uint8Array(buffer);
var toBase64Browser = (bytes) => {
  let s2 = "";
  for (let i2 = 0; i2 < bytes.byteLength; i2++) {
    s2 += fromCharCode2(bytes[i2]);
  }
  return btoa(s2);
};
var toBase64Node = (bytes) => Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength).toString("base64");
var fromBase64Browser = (s2) => {
  const a = atob(s2);
  const bytes = createUint8ArrayFromLen2(a.length);
  for (let i2 = 0; i2 < a.length; i2++) {
    bytes[i2] = a.charCodeAt(i2);
  }
  return bytes;
};
var fromBase64Node = (s2) => {
  const buf = Buffer.from(s2, "base64");
  return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
};
var toBase64 = isBrowser2 ? toBase64Browser : toBase64Node;
var fromBase64 = isBrowser2 ? fromBase64Browser : fromBase64Node;
var channels = /* @__PURE__ */ new Map();
var LocalStoragePolyfill = class {
  /**
   * @param {string} room
   */
  constructor(room) {
    this.room = room;
    this.onmessage = null;
    this._onChange = (e2) => e2.key === room && this.onmessage !== null && this.onmessage({ data: fromBase64(e2.newValue || "") });
    onChange(this._onChange);
  }
  /**
   * @param {ArrayBuffer} buf
   */
  postMessage(buf) {
    varStorage2.setItem(this.room, toBase64(createUint8ArrayFromArrayBuffer(buf)));
  }
  close() {
    offChange(this._onChange);
  }
};
var BC = typeof BroadcastChannel === "undefined" ? LocalStoragePolyfill : BroadcastChannel;
var getChannel = (room) => setIfUndefined2(channels, room, () => {
  const subs = create22();
  const bc = new BC(room);
  bc.onmessage = (e2) => subs.forEach((sub) => sub(e2.data, "broadcastchannel"));
  return {
    bc,
    subs
  };
});
var subscribe = (room, f) => {
  getChannel(room).subs.add(f);
  return f;
};
var unsubscribe = (room, f) => {
  const channel = getChannel(room);
  const unsubscribed = channel.subs.delete(f);
  if (unsubscribed && channel.subs.size === 0) {
    channel.bc.close();
    channels.delete(room);
  }
  return unsubscribed;
};
var publish = (room, data, origin = null) => {
  const c = getChannel(room);
  c.bc.postMessage(data);
  c.subs.forEach((sub) => sub(data, origin));
};
var getUnixTime2 = Date.now;
var Observable2 = class {
  constructor() {
    this._observers = create7();
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  on(name, f) {
    setIfUndefined2(this._observers, name, create22).add(f);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  once(name, f) {
    const _f = (...args22) => {
      this.off(name, _f);
      f(...args22);
    };
    this.on(name, _f);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  off(name, f) {
    const observers = this._observers.get(name);
    if (observers !== void 0) {
      observers.delete(f);
      if (observers.size === 0) {
        this._observers.delete(name);
      }
    }
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @param {N} name The event name.
   * @param {Array<any>} args The arguments that are applied to the event listener.
   */
  emit(name, args22) {
    return from2((this._observers.get(name) || create7()).values()).forEach((f) => f(...args22));
  }
  destroy() {
    this._observers = create7();
  }
};
var encodeQueryParams = (params22) => map2(params22, (val, key) => `${encodeURIComponent(key)}=${encodeURIComponent(val)}`).join("&");
var messageSync = 0;
var messageQueryAwareness = 3;
var messageAwareness = 1;
var messageAuth = 2;
var messageHandlers = [];
messageHandlers[messageSync] = (encoder2, decoder2, provider, emitSynced, _messageType) => {
  writeVarUint2(encoder2, messageSync);
  const syncMessageType = readSyncMessage(decoder2, encoder2, provider.doc, provider);
  if (emitSynced && syncMessageType === messageYjsSyncStep2 && !provider.synced) {
    provider.synced = true;
  }
};
messageHandlers[messageQueryAwareness] = (encoder2, _decoder, provider, _emitSynced, _messageType) => {
  writeVarUint2(encoder2, messageAwareness);
  writeVarUint8Array2(
    encoder2,
    encodeAwarenessUpdate(
      provider.awareness,
      Array.from(provider.awareness.getStates().keys())
    )
  );
};
messageHandlers[messageAwareness] = (_encoder, decoder2, provider, _emitSynced, _messageType) => {
  applyAwarenessUpdate(
    provider.awareness,
    readVarUint8Array2(decoder2),
    provider
  );
};
messageHandlers[messageAuth] = (_encoder, decoder2, provider, _emitSynced, _messageType) => {
  readAuthMessage(
    decoder2,
    provider.doc,
    (_ydoc, reason) => permissionDeniedHandler(provider, reason)
  );
};
var messageReconnectTimeout = 3e4;
var permissionDeniedHandler = (provider, reason) => console.warn(`Permission denied to access ${provider.url}.
${reason}`);
var readMessage = (provider, buf, emitSynced) => {
  const decoder2 = createDecoder2(buf);
  const encoder2 = createEncoder2();
  const messageType = readVarUint2(decoder2);
  const messageHandler = provider.messageHandlers[messageType];
  if (
    /** @type {any} */
    messageHandler
  ) {
    messageHandler(encoder2, decoder2, provider, emitSynced, messageType);
  } else {
    console.error("Unable to compute message");
  }
  return encoder2;
};
var setupWS = (provider) => {
  if (provider.shouldConnect && provider.ws === null) {
    const websocket = new provider._WS(provider.url);
    websocket.binaryType = "arraybuffer";
    provider.ws = websocket;
    provider.wsconnecting = true;
    provider.wsconnected = false;
    provider.synced = false;
    websocket.onmessage = (event) => {
      provider.wsLastMessageReceived = getUnixTime2();
      const encoder2 = readMessage(provider, new Uint8Array(event.data), true);
      if (length3(encoder2) > 1) {
        websocket.send(toUint8Array2(encoder2));
      }
    };
    websocket.onerror = (event) => {
      provider.emit("connection-error", [event, provider]);
    };
    websocket.onclose = (event) => {
      provider.emit("connection-close", [event, provider]);
      provider.ws = null;
      provider.wsconnecting = false;
      if (provider.wsconnected) {
        provider.wsconnected = false;
        provider.synced = false;
        removeAwarenessStates(
          provider.awareness,
          Array.from(provider.awareness.getStates().keys()).filter(
            (client) => client !== provider.doc.clientID
          ),
          provider
        );
        provider.emit("status", [
          {
            status: "disconnected"
          }
        ]);
      } else {
        provider.wsUnsuccessfulReconnects++;
      }
      setTimeout(
        setupWS,
        min2(pow(2, provider.wsUnsuccessfulReconnects) * 100, provider.maxBackoffTime),
        provider
      );
    };
    websocket.onopen = () => {
      provider.wsLastMessageReceived = getUnixTime2();
      provider.wsconnecting = false;
      provider.wsconnected = true;
      provider.wsUnsuccessfulReconnects = 0;
      provider.emit("status", [
        {
          status: "connected"
        }
      ]);
      const encoder2 = createEncoder2();
      writeVarUint2(encoder2, messageSync);
      writeSyncStep1(encoder2, provider.doc);
      websocket.send(toUint8Array2(encoder2));
      if (provider.awareness.getLocalState() !== null) {
        const encoderAwarenessState = createEncoder2();
        writeVarUint2(encoderAwarenessState, messageAwareness);
        writeVarUint8Array2(
          encoderAwarenessState,
          encodeAwarenessUpdate(provider.awareness, [provider.doc.clientID])
        );
        websocket.send(toUint8Array2(encoderAwarenessState));
      }
    };
    provider.emit("status", [
      {
        status: "connecting"
      }
    ]);
  }
};
var broadcastMessage = (provider, buf) => {
  const ws = provider.ws;
  if (provider.wsconnected && ws && ws.readyState === ws.OPEN) {
    ws.send(buf);
  }
  if (provider.bcconnected) {
    publish(provider.bcChannel, buf, provider);
  }
};
var YSweetProvider = class extends Observable2 {
  /**
   * @param serverUrl - server url
   * @param roomname - room name
   * @param doc - Y.Doc instance
   * @param opts - options
   * @param opts.connect - connect option
   * @param opts.awareness - awareness protocol instance
   * @param opts.params - parameters
   * @param opts.WebSocketPolyfill - WebSocket polyfill
   * @param opts.resyncInterval - resync interval
   * @param opts.maxBackoffTime - maximum backoff time
   * @param opts.disableBc - disable broadcast channel
   */
  constructor(serverUrl, roomname, doc2, {
    connect = true,
    awareness = new Awareness(doc2),
    params: params22 = {},
    WebSocketPolyfill = WebSocket,
    resyncInterval = -1,
    maxBackoffTime = 2500,
    disableBc = false
  } = {}) {
    super();
    while (serverUrl[serverUrl.length - 1] === "/") {
      serverUrl = serverUrl.slice(0, serverUrl.length - 1);
    }
    const encodedParams = encodeQueryParams(params22);
    this.maxBackoffTime = maxBackoffTime;
    this.bcChannel = serverUrl + "/" + roomname;
    this.url = serverUrl + "/" + roomname + (encodedParams.length === 0 ? "" : "?" + encodedParams);
    this.roomname = roomname;
    this.doc = doc2;
    this._WS = WebSocketPolyfill;
    this.awareness = awareness;
    this.wsconnected = false;
    this.wsconnecting = false;
    this.bcconnected = false;
    this.disableBc = disableBc;
    this.wsUnsuccessfulReconnects = 0;
    this.messageHandlers = messageHandlers.slice();
    this._synced = false;
    this.ws = null;
    this.wsLastMessageReceived = 0;
    this.shouldConnect = connect;
    this._resyncInterval = 0;
    if (resyncInterval > 0) {
      this._resyncInterval = setInterval(() => {
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
          const encoder2 = createEncoder2();
          writeVarUint2(encoder2, messageSync);
          writeSyncStep1(encoder2, doc2);
          this.ws.send(toUint8Array2(encoder2));
        }
      }, resyncInterval);
    }
    this._bcSubscriber = (data, origin) => {
      if (origin !== this) {
        const encoder2 = readMessage(this, new Uint8Array(data), false);
        if (length3(encoder2) > 1) {
          publish(this.bcChannel, toUint8Array2(encoder2), this);
        }
      }
    };
    this._updateHandler = (update2, origin) => {
      if (origin !== this) {
        const encoder2 = createEncoder2();
        writeVarUint2(encoder2, messageSync);
        writeUpdate(encoder2, update2);
        broadcastMessage(this, toUint8Array2(encoder2));
      }
    };
    this.doc.on("update", this._updateHandler);
    this._awarenessUpdateHandler = ({ added, updated, removed }, _origin) => {
      const changedClients = added.concat(updated).concat(removed);
      const encoder2 = createEncoder2();
      writeVarUint2(encoder2, messageAwareness);
      writeVarUint8Array2(
        encoder2,
        encodeAwarenessUpdate(awareness, changedClients)
      );
      broadcastMessage(this, toUint8Array2(encoder2));
    };
    this._unloadHandler = () => {
      removeAwarenessStates(this.awareness, [doc2.clientID], "window unload");
    };
    if (typeof window !== "undefined") {
      window.addEventListener("unload", this._unloadHandler);
    } else if (typeof process !== "undefined") {
      process.on("exit", this._unloadHandler);
    }
    awareness.on("update", this._awarenessUpdateHandler);
    this._checkInterval = setInterval(() => {
      var _a2;
      if (this.wsconnected && messageReconnectTimeout < getUnixTime2() - this.wsLastMessageReceived) {
        (_a2 = this.ws) == null ? void 0 : _a2.close();
      }
    }, messageReconnectTimeout / 10);
    if (connect) {
      this.connect();
    }
  }
  /**
   * @type {boolean}
   */
  get synced() {
    return this._synced;
  }
  set synced(state) {
    if (this._synced !== state) {
      this._synced = state;
      this.emit("synced", [state]);
      this.emit("sync", [state]);
    }
  }
  destroy() {
    if (this._resyncInterval !== 0) {
      clearInterval(this._resyncInterval);
    }
    clearInterval(this._checkInterval);
    this.disconnect();
    if (typeof window !== "undefined") {
      window.removeEventListener("unload", this._unloadHandler);
    } else if (typeof process !== "undefined") {
      process.off("exit", this._unloadHandler);
    }
    this.awareness.off("update", this._awarenessUpdateHandler);
    this.doc.off("update", this._updateHandler);
    super.destroy();
  }
  connectBc() {
    if (this.disableBc) {
      return;
    }
    if (!this.bcconnected) {
      subscribe(this.bcChannel, this._bcSubscriber);
      this.bcconnected = true;
    }
    const encoderSync = createEncoder2();
    writeVarUint2(encoderSync, messageSync);
    writeSyncStep1(encoderSync, this.doc);
    publish(this.bcChannel, toUint8Array2(encoderSync), this);
    const encoderState = createEncoder2();
    writeVarUint2(encoderState, messageSync);
    writeSyncStep2(encoderState, this.doc);
    publish(this.bcChannel, toUint8Array2(encoderState), this);
    const encoderAwarenessQuery = createEncoder2();
    writeVarUint2(encoderAwarenessQuery, messageQueryAwareness);
    publish(this.bcChannel, toUint8Array2(encoderAwarenessQuery), this);
    const encoderAwarenessState = createEncoder2();
    writeVarUint2(encoderAwarenessState, messageAwareness);
    writeVarUint8Array2(
      encoderAwarenessState,
      encodeAwarenessUpdate(this.awareness, [this.doc.clientID])
    );
    publish(this.bcChannel, toUint8Array2(encoderAwarenessState), this);
  }
  disconnectBc() {
    const encoder2 = createEncoder2();
    writeVarUint2(encoder2, messageAwareness);
    writeVarUint8Array2(
      encoder2,
      encodeAwarenessUpdate(this.awareness, [this.doc.clientID], /* @__PURE__ */ new Map())
    );
    broadcastMessage(this, toUint8Array2(encoder2));
    if (this.bcconnected) {
      unsubscribe(this.bcChannel, this._bcSubscriber);
      this.bcconnected = false;
    }
  }
  disconnect() {
    this.shouldConnect = false;
    this.disconnectBc();
    if (this.ws !== null) {
      this.ws.close();
    }
  }
  connect() {
    this.shouldConnect = true;
    if (!this.wsconnected && this.ws === null) {
      setupWS(this);
      this.connectBc();
    }
  }
};

// src/debug.ts
var RelayInstances = /* @__PURE__ */ new WeakMap();
var debugging = false;
function setDebugging(debug2) {
  debugging = debug2;
}
var logConfig = {
  maxFileSize: 1024 * 1024,
  // 1MB
  maxBackups: 5,
  disableConsole: false,
  batchInterval: 1e3,
  // 1 second
  maxRetries: 3
};
var currentLogFile;
var fileAdapter;
var logBuffer = [];
function initializeLogger(adapter, timeProvider, logFilePath, config) {
  fileAdapter = adapter;
  currentLogFile = logFilePath;
  if (config) {
    logConfig = { ...logConfig, ...config };
  }
  timeProvider.setInterval(flushLogs, logConfig.batchInterval);
}
async function flushLogs() {
  if (logBuffer.length === 0)
    return;
  const entries = [...logBuffer];
  logBuffer.length = 0;
  for (let retry = 0; retry < logConfig.maxRetries; retry++) {
    try {
      await rotateLogIfNeeded();
      const logContent = entries.map(formatLogEntry).join("\n") + "\n";
      await fileAdapter.append(currentLogFile, logContent);
      return;
    } catch (error) {
      console.error(`Failed to write logs (attempt ${retry + 1}):`, error);
      if (retry === logConfig.maxRetries - 1) {
        console.error("Max retries reached. Discarding log entries.");
      }
    }
  }
}
async function rotateLogIfNeeded() {
  const stat = await fileAdapter.stat(currentLogFile);
  if (stat && stat.size > logConfig.maxFileSize) {
    for (let i2 = logConfig.maxBackups; i2 > 0; i2--) {
      const oldFile = `${currentLogFile}.${i2}`;
      const newFile = `${currentLogFile}.${i2 + 1}`;
      if (await fileAdapter.exists(oldFile)) {
        if (i2 === logConfig.maxBackups) {
          await fileAdapter.remove(oldFile);
        } else {
          await fileAdapter.rename(oldFile, newFile);
        }
      }
    }
    if (await fileAdapter.exists(currentLogFile)) {
      await fileAdapter.rename(currentLogFile, `${currentLogFile}.1`);
    }
    await fileAdapter.write(currentLogFile, "");
  }
}
function formatLogEntry(entry) {
  return `[${entry.timestamp}] [${entry.level.toUpperCase()}] ${entry.message}
    at ${entry.callerInfo}`;
}
function createToastFunction(notifier, debug2) {
  return debug2 ? (error) => {
    notifier.notify(error.name + "\n" + error.message);
    return error;
  } : (error) => {
    notifier.notify(
      error.name + ":\nAn error has occurred, please reload Obsidian."
    );
    return error;
  };
}
var SENSITIVE_KEYS = ["token", "authorization", "email"];
function serializeArg(arg) {
  if (typeof arg === "object" && arg !== null) {
    const seen = /* @__PURE__ */ new WeakSet();
    try {
      return JSON.stringify(
        arg,
        (key, value) => {
          var _a2;
          if (typeof value === "object" && value !== null) {
            if (seen.has(value)) {
              return "[Circular]";
            }
            seen.add(value);
          }
          if (typeof key === "string" && SENSITIVE_KEYS.some(
            (sk) => key.toLowerCase().includes(sk.toLowerCase())
          )) {
            return "[REDACTED]";
          }
          if (value instanceof Error) {
            return {
              name: value.name,
              message: value.message,
              stack: (_a2 = value.stack) == null ? void 0 : _a2.split("\n").map((line) => line.trim()).join(" ")
            };
          }
          return value;
        },
        2
      );
    } catch (error) {
      if (error instanceof Error) {
        if (error instanceof RangeError) {
          return `[Complex Object: ${Object.prototype.toString.call(arg)}]`;
        }
        return `[Unserializable: ${error.message}]`;
      }
      return "[Unknown Error]";
    }
  }
  return String(arg);
}
function curryLog(initialText, level = "log") {
  return (...args3) => {
    if (debugging) {
      const timestamp = new Date().toISOString();
      const stack = new Error().stack;
      const callerInfo = stack ? stack.split("\n")[2].trim() : "";
      const serializedArgs = args3.map(serializeArg).join(" ");
      const logEntry = {
        timestamp,
        level,
        message: `${initialText}: ${serializedArgs}`,
        callerInfo
      };
      if (!logConfig.disableConsole) {
        console[level](formatLogEntry(logEntry));
      }
      logBuffer.push(logEntry);
    }
  };
}
async function getAllLogFiles() {
  const logFiles = [];
  if (await fileAdapter.exists(currentLogFile)) {
    logFiles.push(currentLogFile);
  }
  for (let i2 = 1; i2 <= logConfig.maxBackups; i2++) {
    const backupFile = `${currentLogFile}.${i2}`;
    if (await fileAdapter.exists(backupFile)) {
      logFiles.push(backupFile);
    }
  }
  return logFiles;
}
async function getAllLogs() {
  const logs = [];
  if (await fileAdapter.exists(currentLogFile)) {
    const currentContent = await fileAdapter.read(currentLogFile);
    logs.push(currentContent);
  }
  for (let i2 = 1; i2 <= logConfig.maxBackups; i2++) {
    const backupFile = `${currentLogFile}.${i2}`;
    if (await fileAdapter.exists(backupFile)) {
      const backupContent = await fileAdapter.read(backupFile);
      logs.push(backupContent);
    }
  }
  return logs.reverse().join("\n");
}
var HasLogging = class {
  constructor(context) {
    const logContext = context || this.constructor.name;
    this.debug = curryLog(`[${logContext}]`, "debug");
    this.log = curryLog(`[${logContext}]`, "log");
    this.warn = curryLog(`[${logContext}]`, "warn");
    this.error = curryLog(`[${logContext}]`, "error");
  }
  setLoggers(context) {
    this.debug = curryLog(`[${context}]`, "debug");
    this.log = curryLog(`[${context}]`, "log");
    this.warn = curryLog(`[${context}]`, "warn");
    this.error = curryLog(`[${context}]`, "error");
  }
};
var debug = true;
function createToast(notifier) {
  return createToastFunction(notifier, debug);
}

// src/S3RN.ts
var S3RelayProduct = class {
  constructor() {
    this.platform = "s3rn";
    this.product = "relay";
  }
};
var S3Relay = class {
  constructor(relayId) {
    this.relayId = relayId;
    this.platform = "s3rn";
    this.product = "relay";
  }
};
var S3RemoteFolder = class {
  constructor(relayId, folderId) {
    this.relayId = relayId;
    this.folderId = folderId;
    this.platform = "s3rn";
    this.product = "relay";
  }
};
var S3RemoteDocument = class {
  constructor(relayId, folderId, documentId) {
    this.relayId = relayId;
    this.folderId = folderId;
    this.documentId = documentId;
    this.platform = "s3rn";
    this.product = "relay";
  }
};
var S3Folder = class {
  constructor(folderId) {
    this.folderId = folderId;
    this.platform = "s3rn";
    this.product = "relay";
  }
};
var S3Document = class {
  constructor(folderId, documentId) {
    this.folderId = folderId;
    this.documentId = documentId;
    this.platform = "s3rn";
    this.product = "relay";
  }
};
var S3RN = class {
  static validateUUID(uuid) {
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    return uuidRegex.test(uuid);
  }
  static encode(entity) {
    let s3rn = `${entity.platform}:${entity.product}`;
    if ("relayId" in entity) {
      if (!this.validateUUID(entity.relayId)) {
        throw new Error("Invalid relay UUID");
      }
      s3rn += `:relay:${entity.relayId}`;
    }
    if ("folderId" in entity) {
      if (!this.validateUUID(entity.folderId)) {
        throw new Error("Invalid folder UUID");
      }
      s3rn += `:folder:${entity.folderId}`;
    }
    if ("documentId" in entity) {
      if (!this.validateUUID(entity.documentId)) {
        throw new Error("Invalid document UUID");
      }
      s3rn += `:doc:${entity.documentId}`;
    }
    return s3rn;
  }
  static decode(s3rn) {
    const parts = s3rn.split(":");
    if (parts.length < 3) {
      throw new Error("Invalid s3rn format");
    }
    const [, product, type0, item0, type1, item1, type2, item2] = parts;
    if (!this.validateUUID(item0)) {
      throw new Error("Invalid UUID");
    }
    if (item1 && !this.validateUUID(item1)) {
      throw new Error("Invalid UUID");
    }
    if (item2 && !this.validateUUID(item2)) {
      throw new Error("Invalid UUID");
    }
    if (product === "relay" && type0 === "relay" && type1 === "folder" && type2 === "doc") {
      return new S3RemoteDocument(item0, item1, item2);
    } else if (product === "relay" && type0 === "relay" && type1 == "folder") {
      return new S3RemoteFolder(item0, item1);
    } else if (product === "relay" && type0 === "folder" && type1 === "document") {
      return new S3Document(item0, item1);
    } else if (product === "relay" && type0 === "folder") {
      return new S3Folder(item0);
    } else if (product === "relay" && type0 === "relay") {
      return new S3Relay(item0);
    } else if (type0 === void 0) {
      return new S3RelayProduct();
    }
    throw new Error("Invalid s3rn format for the given product type");
  }
};

// src/y-sweet.ts
function stringToBase64(input) {
  if (typeof window !== "undefined" && window.btoa) {
    return window.btoa(input);
  } else if (typeof Buffer !== "undefined") {
    return Buffer.from(input).toString("base64");
  } else {
    throw new Error("Unable to encode to Base64");
  }
}
function encodeClientToken(token) {
  const jsonString = JSON.stringify(token);
  let base64 = stringToBase64(jsonString);
  base64 = base64.replace("+", "-").replace("/", "_").replace(/=+$/, "");
  return base64;
}

// src/flags.ts
var FeatureFlagDefaults = {
  enableUpdateYDocFromDiskBuffer: false,
  enableDocumentStatus: false,
  enableDebugFileTag: false,
  enableNewLinkFormat: false,
  enableDeltaLogging: false,
  enableHTTPSync: false,
  enableSyncMenu: true,
  enableDocumentServer: false,
  enableDocumentHistory: false,
  enableEditorTweens: false,
  enableSyncModal: false,
  enableDesyncPill: false
};
function createFlagObject() {
  return new Proxy({}, {
    get: (target, prop) => prop
  });
}
var flag = createFlagObject();

// src/TimeProvider.ts
var DefaultTimeProvider = class {
  constructor() {
    this.timeouts = [];
    this.intervals = [];
  }
  getTime() {
    return Date.now();
  }
  setInterval(callback, ms) {
    const timer = window.setInterval(callback, ms);
    this.intervals.push(timer);
    return timer;
  }
  clearInterval(timerId) {
    window.clearInterval(timerId);
  }
  setTimeout(callback, ms) {
    const timer = window.setTimeout(() => {
      this.timeouts.remove(timer);
      callback();
    }, ms);
    this.timeouts.push(timer);
    return timer;
  }
  clearTimeout(timerId) {
    window.clearTimeout(timerId);
  }
  destroy() {
    for (const timer of this.timeouts) {
      this.clearTimeout(timer);
    }
    this.timeouts = [];
    for (const interval of this.intervals) {
      this.clearInterval(interval);
    }
    this.intervals = [];
  }
};

// src/observable/Postie.ts
var _PostOffice = class {
  constructor(timeProvider, deliveryWindow = 20) {
    this.timeProvider = timeProvider;
    this.deliveryWindow = deliveryWindow;
    this.mailboxes = /* @__PURE__ */ new Map();
    this.allMailLog = [];
    this.deliveredMailLog = [];
    this.isDelivering = false;
    this.deliveryInterval = null;
    this.currentTransactionId = 0;
    this.isInTransaction = false;
  }
  static getInstance() {
    if (this._destroyed) {
      throw new Error("tried to access postie during teardown");
    }
    if (!_PostOffice.instance) {
      _PostOffice.instance = new _PostOffice(new DefaultTimeProvider());
      RelayInstances.set(this.instance, "postie");
    }
    return _PostOffice.instance;
  }
  beginTransaction() {
    this.isInTransaction = true;
    this.currentTransactionId++;
  }
  commitTransaction() {
    this.isInTransaction = false;
    if (!this.isDelivering) {
      this.scheduleDelivery();
    }
  }
  send(sender, recipient, immediate = false) {
    const mail = {
      sender,
      recipient,
      transactionId: this.currentTransactionId,
      timestamp: Date.now(),
      recipientOrigin: this.getFunctionOrigin(recipient)
    };
    this.allMailLog.push(mail);
    if (!this.mailboxes.has(recipient)) {
      this.mailboxes.set(recipient, /* @__PURE__ */ new Set());
    }
    this.mailboxes.get(recipient).add(sender);
    if (immediate) {
      this.deliverImmediate(sender, recipient);
    } else if (!this.isInTransaction && !this.isDelivering) {
      this.scheduleDelivery();
    }
  }
  deliverImmediate(sender, recipient) {
    recipient(sender);
    this.deliveredMailLog.push({
      sender,
      recipient,
      transactionId: this.currentTransactionId,
      timestamp: Date.now(),
      recipientOrigin: this.getFunctionOrigin(recipient)
    });
  }
  scheduleDelivery() {
    this.isDelivering = true;
    this.deliveryInterval = this.timeProvider.setTimeout(() => {
      this.deliver();
      this.deliveryInterval = null;
      this.isDelivering = false;
      if (this.mailboxes.size > 0 && !this.isInTransaction) {
        this.scheduleDelivery();
      }
    }, this.deliveryWindow);
  }
  deliver() {
    const log = curryLog("[postie]", "debug");
    for (const [recipient, senders] of this.mailboxes) {
      for (const sender of senders) {
        recipient(sender);
        log("send", sender.constructor.name, recipient);
        this.deliveredMailLog.push({
          sender,
          recipient,
          transactionId: this.currentTransactionId,
          timestamp: Date.now(),
          recipientOrigin: this.getFunctionOrigin(recipient)
        });
      }
      senders.clear();
    }
  }
  getAllMailLog() {
    return [...this.allMailLog];
  }
  getDeliveredMailLog() {
    return [...this.deliveredMailLog];
  }
  prettyPrintAllMailLog() {
    const log = curryLog("[postie]", "warn");
    log("All Mail Log:");
    this.prettyPrintMailLog(this.allMailLog);
  }
  prettyPrintDeliveredMailLog() {
    const log = curryLog("[postie]", "warn");
    log("Delivered Mail Log:");
    this.prettyPrintMailLog(this.deliveredMailLog);
  }
  prettyPrintMailLog(log) {
    const _log = curryLog("[postie]", "warn");
    log.forEach((mail, index) => {
      _log(`Mail #${index + 1}:`);
      _log(`  Timestamp: ${new Date(mail.timestamp).toISOString()}`);
      _log(`  Transaction ID: ${mail.transactionId}`);
      _log(
        `  Sender: ${mail.sender.observableName || mail.sender.constructor.name}`
      );
      _log(`  Recipient: ${mail.recipient.name || "Anonymous function"}`);
      _log(`  Recipient Origin: ${mail.recipientOrigin || "Unknown"}`);
      _log("---");
    });
  }
  getFunctionOrigin(func) {
    if (func.name) {
      return func.name;
    }
    const funcString = func.toString();
    const funcMatch = funcString.match(/^(function|class)?\s*([^\s(]*)/);
    if (funcMatch && funcMatch[2]) {
      return funcMatch[2];
    }
    const maxLength = 200;
    let definition = funcString.replace(/\s+/g, " ").slice(0, maxLength);
    if (definition.length === maxLength) {
      definition += "...";
    }
    return `AnonymousFunction(${definition})`;
  }
  static destroy() {
    if (_PostOffice.instance) {
      _PostOffice.instance.mailboxes = null;
      _PostOffice.instance.allMailLog = [];
      _PostOffice.instance.deliveredMailLog = [];
      _PostOffice.instance.timeProvider.destroy();
      _PostOffice.instance.timeProvider = null;
      _PostOffice.instance.isDelivering = false;
      _PostOffice.instance.isInTransaction = false;
      _PostOffice.instance.currentTransactionId = 0;
      _PostOffice._destroyed = true;
      _PostOffice.instance = void 0;
    }
  }
};
var PostOffice = _PostOffice;
PostOffice._destroyed = false;

// src/observable/Observable.ts
var observables = /* @__PURE__ */ new Map();
function auditTeardown() {
  for (const [, auditTeardown2] of observables) {
    auditTeardown2();
  }
  observables.clear();
}
var Observable3 = class extends HasLogging {
  constructor(observableName) {
    super();
    this.observableName = observableName;
    observables.set(this, () => {
      if (this._listeners && this._listeners.size > 0) {
        this.warn(
          `Missing tear down of ${this._listeners.size} listeners`,
          this,
          this._listeners
        );
      }
    });
    this._listeners = /* @__PURE__ */ new Set();
  }
  notifyListeners() {
    for (const recipient of this._listeners) {
      PostOffice.getInstance().send(
        this,
        recipient
      );
    }
  }
  on(listener) {
    this._listeners.add(listener);
    return () => {
      this.off(listener);
    };
  }
  subscribe(run2) {
    this._listeners.add(run2);
    PostOffice.getInstance().send(
      this,
      run2,
      true
    );
    return () => {
      this.unsubscribe(run2);
    };
  }
  off(listener) {
    this._listeners.delete(listener);
  }
  unsubscribe(run2) {
    this._listeners.delete(run2);
  }
  destroy() {
    this._listeners.clear();
    this._listeners = null;
  }
};

// src/flagManager.ts
function flags() {
  return { ...FeatureFlagManager.getInstance().flags };
}
function withFlag(flag2, fn, otherwise = () => {
}) {
  if (FeatureFlagManager.getInstance().flags[flag2]) {
    fn();
  } else {
    otherwise();
  }
}
function withAnyOf(flags2, fn, otherwise = () => {
}) {
  flags2.forEach((flag2) => {
    if (FeatureFlagManager.getInstance().flags[flag2]) {
      fn();
      return;
    }
  });
  otherwise();
}
var FeatureFlagManager = class extends Observable3 {
  constructor() {
    super();
    this.flags = FeatureFlagDefaults;
  }
  static getInstance() {
    if (!FeatureFlagManager.instance) {
      FeatureFlagManager.instance = new FeatureFlagManager();
    }
    return FeatureFlagManager.instance;
  }
  setSettings(settings) {
    this.settings = settings;
    this.settings.subscribe((newFlags) => {
      this.flags = {
        ...this.flags,
        ...newFlags
      };
      this.notifyListeners();
    });
  }
  getFlag(flagName) {
    return this.flags[flagName];
  }
  setFlag(flagName, value) {
    if (!this.settings)
      return;
    this.settings.update((current) => ({
      ...current,
      [flagName]: value
    }));
  }
  static destroy() {
    FeatureFlagManager.instance = null;
  }
};

// src/HasProvider.ts
var readyStateMap = {
  3: "disconnected",
  2: "disconnected",
  1: "connected",
  0: "connecting"
};
function makeProvider(clientToken, ydoc, user) {
  const params3 = {
    token: clientToken.token
  };
  const provider = new YSweetProvider(
    clientToken.url,
    clientToken.docId,
    ydoc,
    {
      connect: false,
      params: params3,
      disableBc: true
    }
  );
  if (user) {
    provider.awareness.setLocalStateField("user", {
      name: user.name,
      color: user.color.color,
      colorLight: user.color.light
    });
  }
  return provider;
}
var HasProvider = class extends HasLogging {
  constructor(guid, _s3rn, tokenStore, loginManager) {
    var _a2;
    super();
    this.guid = guid;
    this._s3rn = _s3rn;
    this.tokenStore = tokenStore;
    this.loginManager = loginManager;
    this._providerSynced = false;
    this.PROVIDER_MAX_ERRORS = 3;
    this.listeners = /* @__PURE__ */ new Map();
    this.loginManager = loginManager;
    const user = (_a2 = this.loginManager) == null ? void 0 : _a2.user;
    this.ydoc = new Doc();
    if (flags().enableDocumentHistory) {
      this.ydoc.gc = false;
    }
    if (user) {
      const permanentUserData = new PermanentUserData(this.ydoc);
      permanentUserData.setUserMapping(this.ydoc, this.ydoc.clientID, user.id);
    }
    this.tokenStore = tokenStore;
    this.clientToken = this.tokenStore.getTokenSync(S3RN.encode(this.s3rn)) || { token: "", url: "", docId: "-", expiryTime: 0 };
    this._provider = makeProvider(this.clientToken, this.ydoc, user);
    const connectionErrorSub = this.providerConnectionErrorSubscription(
      (event) => {
        this.log(`[${this.path}] disconnection event`, event);
        const shouldConnect = this._provider.url && this._provider.shouldConnect && this._provider.wsUnsuccessfulReconnects < this.PROVIDER_MAX_ERRORS;
        this.disconnect();
        if (shouldConnect) {
          this.connect();
        }
      }
    );
    connectionErrorSub.on();
    this._offConnectionError = connectionErrorSub.off;
    const stateSub = this.providerStateSubscription(
      (state) => {
        this.notifyListeners();
      }
    );
    stateSub.on();
    this._offState = stateSub.off;
  }
  get s3rn() {
    return this._s3rn;
  }
  set s3rn(value) {
    this._s3rn = value;
    this.refreshProvider(this.clientToken);
  }
  get debuggerUrl() {
    const payload = encodeClientToken(this.clientToken);
    return `https://debugger.y-sweet.dev/?payload=${payload}`;
  }
  notifyListeners() {
    this.debug("[Provider State]", this.path, this.state);
    this.listeners.forEach((listener) => {
      listener(this.state);
    });
  }
  subscribe(el, listener) {
    this.listeners.set(el, listener);
    return () => {
      this.unsubscribe(el);
    };
  }
  unsubscribe(el) {
    this.listeners.delete(el);
  }
  async getProviderToken() {
    this.log("get provider token");
    const tokenPromise = this.tokenStore.getToken(
      S3RN.encode(this.s3rn),
      this.path || "unknown",
      this.refreshProvider.bind(this)
    );
    return tokenPromise;
  }
  providerActive() {
    var _a2;
    if (this.clientToken) {
      const tokenIsSet = this._provider.url == this.clientToken.url;
      const expired = Date.now() > (((_a2 = this.clientToken) == null ? void 0 : _a2.expiryTime) || 0);
      return tokenIsSet && !expired;
    }
    return false;
  }
  refreshProvider(clientToken) {
    var _a2;
    this.clientToken = clientToken;
    const tempDoc = new Doc();
    const tempProvider = makeProvider(clientToken, tempDoc);
    const newUrl = tempProvider.url;
    if (!this._provider) {
      throw new Error("missing provider!");
    } else if (this._provider.url !== newUrl) {
      this._provider.url = newUrl;
      this._provider.wsUnsuccessfulReconnects = 0;
      const maskedUrl = this._provider.url.replace(
        /token=[^&]+/,
        "token=[REDACTED]"
      );
      this.log(`Token Refreshed: setting new provider url, ${maskedUrl}`);
      (_a2 = this._provider.ws) == null ? void 0 : _a2.close();
    }
    tempProvider.awareness.destroy();
    tempProvider.destroy();
    tempDoc.destroy();
  }
  get connected() {
    return this.state.status === "connected";
  }
  connect() {
    if (this.connected) {
      return Promise.resolve(true);
    }
    return this.getProviderToken().then((clientToken) => {
      this.refreshProvider(clientToken);
      this._provider.connect();
      this.notifyListeners();
      return true;
    }).catch((e2) => {
      return false;
    });
  }
  get state() {
    var _a2;
    return {
      status: readyStateMap[((_a2 = this._provider.ws) == null ? void 0 : _a2.readyState) || 3 /* CLOSED */],
      intent: this.intent
    };
  }
  get intent() {
    return this._provider.shouldConnect ? "connected" : "disconnected";
  }
  get synced() {
    return this._providerSynced;
  }
  disconnect() {
    var _a2;
    this._provider.shouldConnect = false;
    (_a2 = this._provider.ws) == null ? void 0 : _a2.close();
    this._provider.ws = null;
    this.tokenStore.removeFromRefreshQueue(this.guid);
    this.notifyListeners();
  }
  withActiveProvider() {
    if (this.providerActive()) {
      return new Promise((resolve) => {
        resolve(this);
      });
    }
    return this.getProviderToken().then((clientToken) => {
      return this;
    });
  }
  onceConnected() {
    return new Promise((resolve) => {
      const resolveOnConnect = (state) => {
        if (state.status === "connected") {
          resolve();
        }
      };
      this._provider.on("status", resolveOnConnect);
    });
  }
  onceProviderSynced() {
    if (this.synced) {
      return new Promise((resolve) => {
        resolve();
      });
    }
    return new Promise((resolve) => {
      this._provider.once("synced", () => {
        this._providerSynced = true;
        resolve();
      });
    });
  }
  _injectIntent(f) {
    const inner = (state) => {
      f({ status: state.status, intent: this.intent });
    };
    return inner;
  }
  providerConnectionErrorSubscription(f) {
    const on = () => {
      this._provider.on("connection-error", f);
    };
    const off = () => {
      this._provider.off("connection-error", f);
    };
    return { on, off };
  }
  providerStateSubscription(f) {
    const on = () => {
      this._provider.on("status", this._injectIntent(f));
    };
    const off = () => {
      this._provider.off("status", this._injectIntent(f));
    };
    return { on, off };
  }
  destroy() {
    if (this._offConnectionError) {
      this._offConnectionError();
    }
    if (this._offState) {
      this._offState();
    }
    if (this._provider) {
      this._provider.disconnect();
      this._provider.awareness.destroy();
      this._provider._observers.clear();
      this._provider.destroy();
      window.clearInterval(this._provider.awareness._checkInterval);
    }
    this.loginManager = null;
  }
};

// src/DiskBuffer.ts
var DiskBuffer = class {
  constructor(vault, path, contents) {
    this.vault = vault;
    this.contents = contents;
    this.parent = null;
    this.path = path;
    this.name = path.split("/").pop() || "";
    this.extension = this.name.includes(".") ? this.name.split(".").pop() || "" : "";
    this.basename = this.name.replace(`.${this.extension}`, "");
    this.stat = {
      ctime: Date.now(),
      mtime: Date.now(),
      size: 0
    };
  }
  delete() {
    return Promise.resolve();
  }
  rename(newPath) {
    this.path = newPath;
    this.name = newPath.split("/").pop() || "";
    this.extension = this.name.includes(".") ? this.name.split(".").pop() || "" : "";
    this.basename = this.name.replace(`.${this.extension}`, "");
    return Promise.resolve();
  }
  getBasePath() {
    return this.path.substring(0, this.path.lastIndexOf("/"));
  }
};
var DiskBufferStore = class {
  constructor() {
    this.dbName = "RelayDiskBuffer";
    this.storeName = "diskBuffers";
    this.dbPromise = null;
  }
  async getDB() {
    if (!this.dbPromise) {
      this.dbPromise = this.openDB();
    }
    return this.dbPromise;
  }
  async openDB() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, 1);
      request.onerror = () => reject(request.error);
      request.onsuccess = () => resolve(request.result);
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        db.createObjectStore(this.storeName, { keyPath: "guid" });
      };
    });
  }
  async saveDiskBuffer(guid, contents) {
    const db = await this.getDB();
    return new Promise((resolve, reject) => {
      try {
        const transaction = db.transaction(this.storeName, "readwrite");
        const store = transaction.objectStore(this.storeName);
        const request = store.put({ guid, contents });
        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve();
      } catch (e2) {
        reject(e2);
      }
    });
  }
  async loadDiskBuffer(guid) {
    const db = await this.getDB();
    return new Promise((resolve, reject) => {
      try {
        const transaction = db.transaction(this.storeName, "readonly");
        const store = transaction.objectStore(this.storeName);
        const request = store.get(guid);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve(request.result ? request.result.contents : null);
      } catch (e2) {
        reject(e2);
      }
    });
  }
  async removeDiskBuffer(guid) {
    const db = await this.getDB();
    return new Promise((resolve, reject) => {
      try {
        const transaction = db.transaction(this.storeName, "readwrite");
        const store = transaction.objectStore(this.storeName);
        const request = store.delete(guid);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve();
      } catch (e2) {
        reject(e2);
      }
    });
  }
};

// src/promiseUtils.ts
var Dependency = class {
  constructor(promiseFunction, checkFunction) {
    this.currentPromise = null;
    this.promiseFunction = promiseFunction;
    this.checkFunction = checkFunction;
  }
  getPromise() {
    const [success, result] = this.checkFunction();
    const onSuccess = (result2) => {
      if (this.currentPromise && this.resolver) {
        const resolve = this.resolver;
        resolve(result2);
        if (this.timeoutId) {
          clearTimeout(this.timeoutId);
        }
        this.resolver = void 0;
      }
      return this.currentPromise;
    };
    if (success) {
      const promise = onSuccess(result);
      if (promise)
        return promise;
    }
    if (!this.currentPromise) {
      this.currentPromise = new Promise((resolve, reject) => {
        this.resolver = resolve;
        this.timeoutId = window.setTimeout(() => {
          curryLog("[Promise]", "debug")(
            "Dependency stuck after 3s. Checking.",
            this.promiseFunction.toString()
          );
          const [success2, result2] = this.checkFunction();
          if (success2) {
            onSuccess(result2);
          }
        }, 3e3);
        this.promiseFunction().then(
          (result2) => {
            if (this.timeoutId) {
              clearTimeout(this.timeoutId);
            }
            resolve(result2);
          },
          (error) => {
            if (this.timeoutId) {
              clearTimeout(this.timeoutId);
            }
            this.currentPromise = null;
            reject(error);
          }
        );
      });
    }
    return this.currentPromise;
  }
  destroy() {
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
      this.timeoutId = void 0;
    }
    this.currentPromise = null;
    this.resolver = void 0;
  }
};
var SharedPromise = class {
  constructor(promiseFunction) {
    this.currentPromise = null;
    this.promiseFunction = promiseFunction;
  }
  getPromise() {
    if (!this.currentPromise) {
      this.currentPromise = new Promise((resolve, reject) => {
        this.timeoutId = window.setTimeout(() => {
          curryLog("[Promise]", "error")(
            "SharedPromise stuck after 3s:",
            this.promiseFunction.toString()
          );
        }, 3e3);
        this.promiseFunction().then(
          (result) => {
            if (this.timeoutId) {
              clearTimeout(this.timeoutId);
            }
            this.currentPromise = null;
            resolve(result);
          },
          (error) => {
            if (this.timeoutId) {
              clearTimeout(this.timeoutId);
            }
            this.currentPromise = null;
            reject(error);
          }
        );
      });
    }
    return this.currentPromise;
  }
  destroy() {
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
      this.timeoutId = void 0;
    }
    this.currentPromise = null;
  }
};

// src/Document.ts
var Document = class extends HasProvider {
  constructor(path, guid, loginManager, parent) {
    const s3rn = parent.relayId ? new S3RemoteDocument(parent.relayId, parent.guid, guid) : new S3Document(parent.guid, guid);
    super(guid, s3rn, parent.tokenStore, loginManager);
    this.whenSyncedPromise = null;
    this.persistenceSynced = false;
    this.userLock = false;
    this.unsubscribes = [];
    this._parent = parent;
    this.path = path;
    this.name = "[CRDT] " + path.split("/").pop() || "";
    this.setLoggers(this.name);
    this.extension = this.name.split(".").pop() || "";
    this.basename = this.name.replace(`.${this.extension}`, "");
    this.vault = this._parent.vault;
    this.stat = {
      ctime: Date.now(),
      mtime: Date.now(),
      size: 0
    };
    this._diskBufferStore = this.sharedFolder.diskBufferStore;
    this.unsubscribes.push(
      this._parent.subscribe(this.path, (state) => {
        if (state.intent === "disconnected") {
          this.disconnect();
        }
      })
    );
    this.setLoggers(`[SharedDoc](${this.path})`);
    try {
      const key = `${this.sharedFolder.appId}-relay-doc-${this.guid}`;
      this._persistence = new IndexeddbPersistence(key, this.ydoc);
    } catch (e2) {
      this.warn("Unable to open persistence.", this.guid);
      console.error(e2);
      throw e2;
    }
    this.whenSynced().then(() => {
      const statsObserver = (event) => {
        const origin = event.transaction.origin;
        if (event.changes.keys.size === 0)
          return;
        if (origin == this)
          return;
        this.updateStats();
      };
      this.ytext.observe(statsObserver);
      this.unsubscribes.push(() => {
        var _a2;
        (_a2 = this.ytext) == null ? void 0 : _a2.unobserve(statsObserver);
      });
      this.updateStats();
      try {
        this._persistence.set("path", this.path);
        this._persistence.set("relay", this.sharedFolder.relayId || "");
        this._persistence.set("appId", this.sharedFolder.appId);
        this._persistence.set("s3rn", S3RN.encode(this.s3rn));
      } catch (e2) {
      }
      (async () => {
        const serverSynced = await this.getServerSynced();
        if (!serverSynced) {
          await this.onceProviderSynced();
          await this.markSynced();
        }
        this.sharedFolder.markUploaded(this);
      })();
    });
    withFlag(flag.enableDeltaLogging, () => {
      const logObserver = (event) => {
        var _a2, _b2;
        let log = "";
        log += `Transaction origin: ${event.transaction.origin} ${(_b2 = (_a2 = event.transaction.origin) == null ? void 0 : _a2.constructor) == null ? void 0 : _b2.name}
`;
        for (const delta of event.changes.delta) {
          log += `insert: ${delta.insert}

retain: ${delta.retain}

delete: ${delta.delete}
`;
        }
        this.debug(log);
      };
      this.ytext.observe(logObserver);
      this.unsubscribes.push(() => {
        this.ytext.unobserve(logObserver);
      });
    });
    this._tfile = null;
  }
  setLoggers(context) {
    this.debug = curryLog(context, "debug");
    this.log = curryLog(context, "log");
    this.warn = curryLog(context, "warn");
    this.error = curryLog(context, "error");
  }
  move(newPath) {
    this.path = newPath;
    this.name = newPath.split("/").pop() || "";
    this.extension = this.name.split(".").pop() || "";
    this.basename = this.name.replace(`.${this.extension}`, "");
    this.updateStats();
  }
  get parent() {
    var _a2;
    return ((_a2 = this.tfile) == null ? void 0 : _a2.parent) || null;
  }
  get sharedFolder() {
    return this._parent;
  }
  get tfile() {
    if (!this._tfile) {
      this._tfile = this._parent.getTFile(this);
    }
    return this._tfile;
  }
  get ytext() {
    return this.ydoc.getText("contents");
  }
  get text() {
    if (!this.ytext) {
      return "";
    }
    return this.ytext.toString();
  }
  async diskBuffer(read = false) {
    if (read || this._diskBuffer === void 0) {
      let fileContents;
      try {
        const storedContents = await this._parent.diskBufferStore.loadDiskBuffer(this.guid).catch((e2) => {
          return null;
        });
        if (storedContents !== null && storedContents !== "") {
          fileContents = storedContents;
        } else {
          fileContents = await this._parent.read(this);
        }
        return this.setDiskBuffer(fileContents.replace("\r\n", "\n"));
      } catch (e2) {
        console.error(e2);
        throw e2;
      }
    }
    return this._diskBuffer;
  }
  setDiskBuffer(contents) {
    if (this._diskBuffer) {
      this._diskBuffer.contents = contents;
    } else {
      this._diskBuffer = new DiskBuffer(
        this._parent.vault,
        "local disk",
        contents
      );
    }
    this._parent.diskBufferStore.saveDiskBuffer(this.guid, contents).catch((e2) => {
    });
    return this._diskBuffer;
  }
  async clearDiskBuffer() {
    if (this._diskBuffer) {
      this._diskBuffer.contents = "";
      this._diskBuffer = void 0;
    }
    await this._parent.diskBufferStore.removeDiskBuffer(this.guid).catch((e2) => {
    });
  }
  async checkStale() {
    await this.whenSynced();
    const diskBuffer = await this.diskBuffer(true);
    const contents = diskBuffer.contents;
    const stale = this.text !== contents;
    if (!stale) {
      this.clearDiskBuffer();
    }
    return stale;
  }
  async connect() {
    if (this.sharedFolder.s3rn instanceof S3Folder) {
      return false;
    } else if (this.s3rn instanceof S3Document) {
      if (this.sharedFolder.relayId) {
        this.s3rn = new S3RemoteDocument(
          this.sharedFolder.relayId,
          this.sharedFolder.guid,
          this.guid
        );
      } else {
        this.s3rn = new S3Document(this.sharedFolder.guid, this.guid);
      }
    }
    return this.sharedFolder.shouldConnect && this.sharedFolder.connect().then((connected) => {
      return super.connect();
    });
  }
  get ready() {
    const persistenceSynced = this._persistence.synced;
    return persistenceSynced && (this.synced || !!this._serverSynced || this._origin === "local");
  }
  hasLocalDB() {
    return !!this._serverSynced || this._persistence._dbsize > 3 || !!(this._dbsize && this._dbsize > 3);
  }
  async awaitingUpdates() {
    await this.whenSynced();
    await this.getServerSynced();
    if (!this._awaitingUpdates) {
      return false;
    }
    this._awaitingUpdates = !this.hasLocalDB();
    return this._awaitingUpdates;
  }
  async whenReady() {
    const promiseFn = async () => {
      const awaitingUpdates = await this.awaitingUpdates();
      if (awaitingUpdates) {
        this.log("awaiting updates");
        this.connect();
        await this.onceConnected();
        this.log("connected");
        await this.onceProviderSynced();
        this.log("synced");
        return this;
      }
      return this;
    };
    this.readyPromise = this.readyPromise || new Dependency(promiseFn, () => {
      return [this.ready, this];
    });
    return this.readyPromise.getPromise();
  }
  whenSynced() {
    const promiseFn = async () => {
      await this.sharedFolder.whenSynced();
      if (this._persistence.synced && !this.persistenceSynced) {
        await this.count();
        this.persistenceSynced = true;
        return Promise.resolve();
      }
      return new Promise((resolve) => {
        if (this.persistenceSynced) {
          resolve();
        }
        this._persistence.once("synced", async () => {
          await this.count();
          this.persistenceSynced = true;
          resolve();
        });
      });
    };
    this.whenSyncedPromise = this.whenSyncedPromise || new Dependency(promiseFn, () => {
      return [this.persistenceSynced, void 0];
    });
    return this.whenSyncedPromise.getPromise();
  }
  async hasKnownPeers() {
    await this.whenSynced();
    return this.hasLocalDB();
  }
  async markOrigin(origin) {
    this._origin = origin;
    await this._persistence.set("origin", origin);
  }
  async getOrigin() {
    if (this._origin !== void 0) {
      return this._origin;
    }
    this._origin = await this._persistence.get("origin");
    return this._origin;
  }
  async markSynced() {
    this._serverSynced = true;
    await this._persistence.set("serverSync", 1);
  }
  async getServerSynced() {
    if (this._serverSynced !== void 0) {
      return this._serverSynced;
    }
    const serverSync = await this._persistence.get("serverSync");
    if (serverSync === 1) {
      this._serverSynced = true;
      return this._serverSynced;
    }
    return false;
  }
  async count() {
    if (this._persistence.db === null) {
      throw new Error("database not ready yet");
    }
    if (this._dbsize) {
      return this._dbsize;
    }
    if (this._persistence._dbsize > 3) {
      this._dbsize = this._persistence._dbsize;
      return this._dbsize;
    }
    const [updatesStore] = transact2(
      this._persistence.db,
      ["updates"],
      "readonly"
    );
    const cnt = await count(updatesStore);
    this._dbsize = cnt;
    return this._dbsize;
  }
  get dbsize() {
    if (!this._dbsize) {
      throw new Error("dbsize accessed before count");
    }
    return this._persistence._dbsize === 0 && this._dbsize ? this._dbsize : this._persistence._dbsize;
  }
  destroy() {
    var _a2, _b2;
    this.unsubscribes.forEach((unsubscribe2) => {
      unsubscribe2();
    });
    super.destroy();
    this.ydoc.destroy();
    if (this._diskBuffer) {
      this._diskBuffer.contents = "";
      this._diskBuffer = void 0;
    }
    this._diskBufferStore = null;
    (_a2 = this.whenSyncedPromise) == null ? void 0 : _a2.destroy();
    this.whenSyncedPromise = null;
    (_b2 = this.readyPromise) == null ? void 0 : _b2.destroy();
    this.readyPromise = null;
  }
  async read() {
    return this.text;
  }
  async rename(newPath) {
    this.move(newPath);
  }
  async delete() {
    this.destroy();
  }
  // Helper method to update file stats
  updateStats() {
    this.stat.mtime = Date.now();
    this.stat.size = this.text.length;
  }
  // Additional methods that might be useful
  async write(content) {
    this.ytext.delete(0, this.ytext.length);
    this.ytext.insert(0, content);
    this.updateStats();
  }
  async append(content) {
    this.ytext.insert(this.ytext.length, content);
    this.updateStats();
  }
};

// src/observable/ObservableSet.ts
var ObservableSet = class extends Observable3 {
  constructor() {
    super();
    this._set = /* @__PURE__ */ new Set();
  }
  add(item) {
    this._set.add(item);
    this.notifyListeners();
    return this;
  }
  delete(item) {
    const result = this._set.delete(item);
    if (result) {
      this.notifyListeners();
    }
    return result;
  }
  clear() {
    this._set.clear();
    this.notifyListeners();
  }
  has(item) {
    return this._set.has(item);
  }
  items() {
    return [...this._set];
  }
  get size() {
    return this._set.size;
  }
  map(callbackfn) {
    return this.items().map(callbackfn);
  }
  forEach(callbackfn) {
    this.items().forEach(callbackfn);
  }
  find(predicate) {
    return this.items().find(predicate);
  }
  some(predicate) {
    for (const item of this._set) {
      if (predicate(item)) {
        return true;
      }
    }
    return false;
  }
  filter(predicate) {
    const filtered = [];
    for (const value of this._set) {
      if (predicate(value)) {
        filtered.push(value);
      }
    }
    return filtered;
  }
};

// src/LocalStorage.ts
var LocalStorage = class {
  constructor(namespace) {
    this.seperator = "/";
    this.namespace = namespace;
  }
  fullKey(key) {
    return `${this.namespace}${this.seperator}${key}`;
  }
  get size() {
    return Object.keys(localStorage).filter(
      (key) => key.startsWith(this.namespace + this.seperator)
    ).length;
  }
  clear() {
    Object.keys(localStorage).filter((key) => key.startsWith(this.namespace + this.seperator)).forEach((key) => localStorage.removeItem(key));
  }
  delete(key) {
    const storageKey = this.fullKey(key);
    const exists = localStorage.getItem(storageKey) !== null;
    localStorage.removeItem(storageKey);
    return exists;
  }
  forEach(callbackfn, thisArg) {
    Object.keys(localStorage).filter((key) => key.startsWith(this.namespace + this.seperator)).forEach((key) => {
      const storageKey = key.split(`${this.namespace}${this.seperator}`)[1];
      const value = this.get(storageKey);
      callbackfn.call(thisArg, value, storageKey, this);
    });
  }
  get(key) {
    const storageKey = this.fullKey(key);
    const item = localStorage.getItem(storageKey);
    return item ? JSON.parse(item) : void 0;
  }
  has(key) {
    const storageKey = this.fullKey(key);
    return localStorage.getItem(storageKey) !== null;
  }
  set(key, value) {
    const storageKey = this.fullKey(key);
    localStorage.setItem(storageKey, JSON.stringify(value));
    return this;
  }
  keys() {
    const keys2 = Object.keys(localStorage).filter((key) => key.startsWith(this.namespace + this.seperator)).map((key) => key.split(`${this.namespace}${this.seperator}`)[1]);
    return keys2.values();
  }
  values() {
    const values = Array.from(this.keys()).map((key) => this.get(key));
    return values.values();
  }
  entries() {
    const entries = Array.from(this.keys()).map(
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      (key) => [key, this.get(key)]
    );
    return entries.values();
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  get [Symbol.toStringTag]() {
    return "LocalStorage";
  }
};

// src/SharedFolder.ts
var Documents = class extends ObservableSet {
  constructor() {
    super(...arguments);
    // Startup performance optimization
    this.notifyListeners = (0, import_obsidian.debounce)(super.notifyListeners, 100);
  }
  update() {
    this.notifyListeners();
    return;
  }
  add(item, update2 = true) {
    update2 = update2 && !this._set.has(item);
    this._set.add(item);
    if (update2) {
      this.notifyListeners();
    }
    return this;
  }
};
var SharedFolder = class extends HasProvider {
  constructor(appId, guid, path, loginManager, vault, fileManager, tokenStore, relayManager, backgroundSync, _settings, relayId, awaitingUpdates = true) {
    var _a2;
    const s3rn = relayId ? new S3RemoteFolder(relayId, guid) : new S3Folder(guid);
    super(guid, s3rn, tokenStore, loginManager);
    this.appId = appId;
    this.backgroundSync = backgroundSync;
    this._settings = _settings;
    this.destroyed = false;
    this.readyPromise = null;
    this.whenSyncedPromise = null;
    this.persistenceSynced = false;
    this.syncFileTreePromise = null;
    this.syncRequestedDuringSync = false;
    this.unsubscribes = [];
    this.addLocalDocs = () => {
      const files = this.getFiles();
      const docs = [];
      const vpaths = [];
      files.forEach((file) => {
        if (!this.checkPath(file.path)) {
          return;
        }
        if (!this.ids.has(file.path)) {
          vpaths.push(this.getVirtualPath(file.path));
        }
      });
      const newDocs = this.placeHold(vpaths);
      files.forEach((file) => {
        if (!this.checkPath(file.path)) {
          return;
        }
        if (!this.checkExtension(file.path)) {
          return;
        }
        if (file instanceof import_obsidian.TFolder) {
          return;
        }
        const vpath = this.getVirtualPath(file.path);
        const upload = newDocs.contains(vpath);
        if (upload) {
          const doc2 = this.uploadDoc(vpath, false);
          docs.push(doc2);
        } else {
          const doc2 = this.getDoc(vpath, false);
          docs.push(doc2);
        }
      });
      if (docs.length > 0) {
        this.docset.update();
      }
    };
    this.path = path;
    this.setLoggers(`[SharedFile](${this.path})`);
    this.fileManager = fileManager;
    this.vault = vault;
    this.ids = this.ydoc.getMap("docs");
    this.docs = /* @__PURE__ */ new Map();
    this.docset = new Documents();
    this.pendingUpload = new LocalStorage(
      `${appId}-system3-relay/folders/${this.guid}/pendingUploads`
    );
    this.relayManager = relayManager;
    this.relayId = relayId;
    this.diskBufferStore = new DiskBufferStore();
    this._shouldConnect = (_a2 = this.settings.connect) != null ? _a2 : true;
    this.authoritative = !awaitingUpdates;
    this.unsubscribes.push(
      this.relayManager.remoteFolders.subscribe((folders) => {
        this.remote = folders.find((folder) => folder.guid == this.guid);
      })
    );
    try {
      this._persistence = new IndexeddbPersistence(this.guid, this.ydoc);
    } catch (e2) {
      this.warn("Unable to open persistence.", this.guid);
      console.error(e2);
      throw e2;
    }
    if (loginManager.loggedIn) {
      this.connect();
    }
    this.whenReady().then(async () => {
      if (!this.destroyed) {
        this.addLocalDocs();
        await this.syncFileTree(this.ydoc);
        this.backgroundSync.resume();
      }
    });
    withFlag(flag.enableDeltaLogging, () => {
      const logObserver = (event) => {
        var _a3, _b2;
        let log = "";
        log += `Transaction origin: ${event.transaction.origin}${(_b2 = (_a3 = event.transaction.origin) == null ? void 0 : _a3.constructor) == null ? void 0 : _b2.name}
`;
        event.changes.keys.forEach((change, key) => {
          if (change.action === "add") {
            log += `Added ${key}: ${this.ids.get(key)}
`;
          }
          if (change.action === "update") {
            log += `Updated ${key}: ${this.ids.get(key)}
`;
          }
          if (change.action === "delete") {
            log += `Deleted ${key}
`;
          }
        });
        this.debug(log);
      };
      this.ids.observe(logObserver);
      this.unsubscribes.push(() => {
        this.ids.unobserve(logObserver);
      });
    });
    this.whenSynced().then(async () => {
      const syncFileObserver = async (event) => {
        if (event.changes.keys.size === 0) {
          this.log("no changes detected");
          return;
        }
        const origin = event.transaction.origin;
        if (origin == this)
          return;
        this.log("file tree", this._debugFileTree());
        await this.syncFileTree(this.ydoc);
      };
      this.ids.observe(syncFileObserver);
      this.unsubscribes.push(() => {
        this.ids.unobserve(syncFileObserver);
      });
      try {
        this._persistence.set("path", this.path);
        this._persistence.set("relay", this.relayId || "");
        this._persistence.set("appId", this.appId);
        this._persistence.set("s3rn", S3RN.encode(this.s3rn));
      } catch (e2) {
      }
    });
    (async () => {
      const serverSynced = await this.getServerSynced();
      if (!serverSynced) {
        await this.onceProviderSynced();
        await this.markSynced();
      }
    })();
    RelayInstances.set(this, this.path);
  }
  get shouldConnect() {
    return this._shouldConnect;
  }
  set shouldConnect(connect) {
    this._settings.update((current) => ({
      ...current,
      connect
    }));
    this._shouldConnect = connect;
  }
  async netSync() {
    await this.whenReady();
    this.addLocalDocs();
    await this.syncFileTree(this.ydoc);
    this.backgroundSync.enqueueSharedFolderSync(this);
  }
  get settings() {
    return this._settings.get();
  }
  getFiles() {
    const folder = this.vault.getAbstractFileByPath(this.path);
    if (!(folder instanceof import_obsidian.TFolder)) {
      throw new Error(
        `Could not find shared folders on file system at ${this.path}`
      );
    }
    const files = [];
    import_obsidian.Vault.recurseChildren(folder, (file) => {
      if (file instanceof import_obsidian.TFile) {
        files.push(file);
      }
    });
    return files;
  }
  connect() {
    if (this.s3rn instanceof S3RemoteFolder) {
      if (this.connected || this.shouldConnect) {
        return super.connect();
      }
    }
    return Promise.resolve(false);
  }
  get name() {
    return this.path.split("/").pop() || "";
  }
  get location() {
    return this.path.split("/").slice(0, -1).join("/");
  }
  get remote() {
    var _a2;
    try {
      (_a2 = this._remote) == null ? void 0 : _a2.relay;
    } catch (e2) {
      return void 0;
    }
    return this._remote;
  }
  set remote(value) {
    var _a2;
    if (this._remote === value) {
      return;
    }
    this._remote = value;
    this.relayId = (_a2 = value == null ? void 0 : value.relay) == null ? void 0 : _a2.guid;
    this.s3rn = this.relayId ? new S3RemoteFolder(this.relayId, this.guid) : new S3Folder(this.guid);
    this._settings.update((current) => {
      if (this.relayId) {
        return {
          guid: this.guid,
          path: this.path,
          relay: this.relayId
        };
      }
      return {
        guid: this.guid,
        path: this.path
      };
    });
    this.notifyListeners();
  }
  get ready() {
    return this.persistenceSynced && (this.authoritative || this._serverSynced || this.synced);
  }
  async count() {
    if (this._persistence.db === null) {
      throw new Error("unexpected missing database");
    }
    if (this._dbsize) {
      return this._dbsize;
    }
    if (this._persistence._dbsize > 3) {
      this._dbsize = this._persistence._dbsize;
      return this._dbsize;
    }
    const [updatesStore] = transact2(
      this._persistence.db,
      ["updates"],
      "readonly"
    );
    const cnt = await count(updatesStore);
    this._dbsize = cnt;
    return this._dbsize;
  }
  async markSynced() {
    this._serverSynced = true;
    await this._persistence.set("serverSync", 1);
  }
  async getServerSynced() {
    if (this._serverSynced !== void 0) {
      return this._serverSynced;
    }
    const serverSync = await this._persistence.get("serverSync");
    if (serverSync === 1) {
      this._serverSynced = true;
      return this._serverSynced;
    }
    return false;
  }
  hasLocalDB() {
    return this._persistence._dbsize > 3 || !!(this._dbsize && this._dbsize > 3);
  }
  async awaitingUpdates() {
    await this.whenSynced();
    if (this.authoritative) {
      return false;
    }
    const serverSynced = await this.getServerSynced();
    if (serverSynced) {
      return false;
    }
    return !this.hasLocalDB();
  }
  whenReady() {
    const promiseFn = async () => {
      const awaitingUpdates = await this.awaitingUpdates();
      if (awaitingUpdates) {
        this.connect();
        await this.onceConnected();
        await this.onceProviderSynced();
        return this;
      }
      return this;
    };
    this.readyPromise = this.readyPromise || new Dependency(promiseFn, () => {
      return [this.ready, this];
    });
    return this.readyPromise.getPromise();
  }
  _debugFileTree() {
    const ids = /* @__PURE__ */ new Map();
    this.ydoc.getMap("docs")._map.forEach((item, path) => {
      if (item.content instanceof ContentAny) {
        ids.set(path, item.content.arr[0]);
      } else {
        ids.set(path, item.content);
      }
    });
    return ids;
  }
  whenSynced() {
    const promiseFn = async () => {
      if (this._persistence.synced) {
        await this.count();
        this.persistenceSynced = true;
        return;
      }
      return new Promise((resolve) => {
        this._persistence.once("synced", async () => {
          await this.count();
          this.persistenceSynced = true;
          resolve();
        });
      });
    };
    this.whenSyncedPromise = this.whenSyncedPromise || new Dependency(promiseFn, () => {
      if (this._persistence.synced && this._dbsize) {
        this.persistenceSynced = true;
      }
      return [this.persistenceSynced, void 0];
    });
    return this.whenSyncedPromise.getPromise();
  }
  get intent() {
    return this.shouldConnect ? "connected" : "disconnected";
  }
  async _handleServerRename(doc2, path, file, diffLog) {
    diffLog == null ? void 0 : diffLog.push(`${file.path} was renamed to ${path}`);
    const dir = (0, import_path_browserify.dirname)(path);
    if (!this.existsSync(dir)) {
      await this.mkdir(dir);
      diffLog == null ? void 0 : diffLog.push(`creating directory ${dir}`);
    }
    this.fileManager.renameFile(file, (0, import_obsidian.normalizePath)(this.getPath(path))).then(() => {
      doc2.move(path);
    });
  }
  async _handleServerCreate(vpath, diffLog) {
    const dir = (0, import_path_browserify.dirname)(vpath);
    if (!this.existsSync(dir)) {
      await this.mkdir(dir);
      diffLog == null ? void 0 : diffLog.push(`creating directory ${dir}`);
    }
    const doc2 = await this.downloadDoc(vpath, false);
    diffLog == null ? void 0 : diffLog.push(`created local file for remotely added doc ${vpath}`);
    return doc2;
  }
  _assertNamespacing(path) {
    try {
      this.assertPath(this.path + path);
    } catch (e2) {
      this.error("Deleting doc (somehow moved outside of shared folder)", path);
      this.ids.delete(path);
      return;
    }
  }
  applyRemoteState(guid, path, remoteIds, diffLog) {
    const doc2 = this.docs.get(guid);
    if (this.existsSync(path) || !this.checkExtension(path)) {
      return { op: "noop", path, promise: Promise.resolve() };
    }
    if (remoteIds.has(guid) && doc2) {
      const oldPath = this.getPath(doc2.path);
      const file = this.vault.getAbstractFileByPath(oldPath);
      if (file) {
        const promise2 = this._handleServerRename(doc2, path, file, diffLog);
        return {
          op: "rename",
          path,
          from: oldPath,
          to: path,
          promise: promise2
        };
      }
    }
    const promise = this._handleServerCreate(path, diffLog);
    return { op: "create", path, promise };
  }
  cleanupExtraLocalFiles(remotePaths, diffLog) {
    const files = this.getFiles();
    const deletes = [];
    files.forEach((file) => {
      var _a2, _b2;
      const isMarkdown = this.checkExtension(file.path);
      const fileInFolder = this.checkPath(file.path);
      const fileInMap = remotePaths.contains(file.path.slice(this.path.length));
      const filePending = this.pendingUpload.has(
        this.getVirtualPath(file.path)
      );
      const synced = ((_a2 = this._provider) == null ? void 0 : _a2.synced) && ((_b2 = this._persistence) == null ? void 0 : _b2.synced);
      if (fileInFolder && !fileInMap && !filePending && isMarkdown) {
        if (synced) {
          diffLog.push(
            `deleted local file ${file.path} for remotely deleted doc`
          );
          const promise = this.vault.adapter.trashLocal(file.path);
          deletes.push({ op: "delete", path: file.path, promise });
        }
      }
    });
    return deletes;
  }
  syncFileTree(doc2) {
    if (this.syncFileTreePromise) {
      this.syncRequestedDuringSync = true;
      const promise = this.syncFileTreePromise.getPromise();
      promise.then(() => {
        if (this.syncRequestedDuringSync) {
          this.syncRequestedDuringSync = false;
          return this.syncFileTree(doc2);
        }
      });
      return promise;
    }
    const promiseFn = async () => {
      try {
        const ops = [];
        const map3 = doc2.getMap("docs");
        const diffLog = [];
        this.ydoc.transact(() => {
          map3.forEach((_, path) => {
            this._assertNamespacing(path);
          });
          const remoteIds = new Set(this.ids.values());
          map3.forEach((guid, path) => {
            this._assertNamespacing(path);
            ops.push(this.applyRemoteState(guid, path, remoteIds, diffLog));
          });
        });
        const creates = ops.filter((op) => op.op === "create");
        const renames = ops.filter((op) => op.op === "rename");
        const remotePaths = ops.map((op) => op.path);
        await Promise.all([...creates, ...renames].map((op) => op.promise));
        const deletes = this.cleanupExtraLocalFiles(remotePaths, diffLog);
        if (renames.length > 0 || creates.length > 0 || deletes.length > 0) {
          this.docset.update();
        }
        this.log("syncFileTree diff:\n" + diffLog.join("\n"));
      } finally {
        this.syncFileTreePromise = null;
      }
    };
    this.syncFileTreePromise = new SharedPromise(promiseFn);
    return this.syncFileTreePromise.getPromise();
  }
  move(path) {
    this.path = path;
    this.setLoggers(`[SharedFile](${this.path})`);
    this._settings.update((current) => ({
      ...current,
      path
    }));
  }
  read(doc2) {
    const vaultPath = (0, import_path_browserify.join)(this.path, doc2.path);
    return this.vault.adapter.read((0, import_obsidian.normalizePath)(vaultPath));
  }
  existsSync(path) {
    const vaultPath = (0, import_obsidian.normalizePath)((0, import_path_browserify.join)(this.path, path));
    const pathExists = this.vault.getAbstractFileByPath(vaultPath) !== null;
    return pathExists;
  }
  exists(doc2) {
    const vaultPath = (0, import_path_browserify.join)(this.path, doc2.path);
    return this.vault.adapter.exists((0, import_obsidian.normalizePath)(vaultPath));
  }
  flush(doc2, content) {
    const vaultPath = (0, import_path_browserify.join)(this.path, doc2.path);
    this.log("writing to ", (0, import_obsidian.normalizePath)(vaultPath));
    return this.vault.adapter.write((0, import_obsidian.normalizePath)(vaultPath), content);
  }
  getPath(path) {
    return (0, import_path_browserify.join)(this.path, path);
  }
  assertPath(path) {
    if (!this.checkPath(path)) {
      throw new Error("Path is not in shared folder: " + path);
    }
  }
  mkdir(path) {
    const vaultPath = (0, import_path_browserify.join)(this.path, path);
    return this.vault.adapter.mkdir((0, import_obsidian.normalizePath)(vaultPath));
  }
  checkPath(path) {
    return path.startsWith(this.path + import_path_browserify.sep);
  }
  checkExtension(path, extension = ".md") {
    return path.endsWith(extension);
  }
  getVirtualPath(path) {
    this.assertPath(path);
    const vPath = path.slice(this.path.length);
    return vPath;
  }
  async getFile(path) {
    const vPath = this.getVirtualPath(path);
    if (!this.checkExtension(path)) {
      throw new Error("bad extension!");
    }
    return this.getDoc(vPath, true);
  }
  getTFile(doc2) {
    const maybeTFile = this.vault.getAbstractFileByPath(this.getPath(doc2.path));
    if (maybeTFile instanceof import_obsidian.TFile) {
      return maybeTFile;
    }
    return null;
  }
  getDoc(vpath, update2 = true) {
    const id2 = this.ids.get(vpath);
    if (id2 !== void 0) {
      const doc2 = this.docs.get(id2);
      if (doc2 !== void 0) {
        doc2.move(vpath);
        return doc2;
      } else {
        this.log("[getDoc]: creating doc for shared ID");
        return this.createDoc(vpath, update2);
      }
    } else {
      this.warn("[getDoc]: creating new shared ID for existing file");
      this.placeHold([vpath]);
      return this.createDoc(vpath, update2);
    }
  }
  placeHold(vpaths) {
    const newDocs = [];
    vpaths.forEach((vpath) => {
      if (!this.ids.has(vpath) && !this.pendingUpload.has(vpath)) {
        this.debug("creating entirely new doc for", vpath);
        const guid = v4_default();
        newDocs.push(vpath);
        this.pendingUpload.set(vpath, guid);
      }
    });
    return newDocs;
  }
  viewFile(path) {
    const vPath = this.getVirtualPath(path);
    if (!this.checkExtension(path)) {
      throw new Error("bad extension!");
    }
    return this.viewDoc(vPath);
  }
  viewDoc(vpath) {
    const guid = this.ids.get(vpath) || this.pendingUpload.get(vpath);
    if (!guid)
      return;
    const doc2 = this.docs.get(guid);
    return doc2;
  }
  async downloadDoc(vpath, update2 = true) {
    if (!this.checkExtension(vpath)) {
      throw new Error("unexpected extension");
    }
    if (!this.synced && !this.ids.has(vpath)) {
      throw new Error(`potential for document split at ${vpath}`);
    }
    const guid = this.ids.get(vpath);
    if (!guid) {
      throw new Error(`called download on item that is not in ids ${vpath}`);
    }
    const doc2 = this.docs.get(guid) || new Document(vpath, guid, this.loginManager, this);
    doc2.markOrigin("remote");
    await this.backgroundSync.enqueueDownload(doc2);
    this.docs.set(guid, doc2);
    this.docset.add(doc2, update2);
    return doc2;
  }
  uploadDoc(vpath, update2 = true) {
    if (!this.checkExtension(vpath)) {
      throw new Error("unexpected extension");
    }
    if (!this.synced && !this.ids.has(vpath) && !this.pendingUpload.has(vpath)) {
      throw new Error(`potential for document split at ${vpath}`);
    }
    const guid = this.ids.get(vpath) || this.pendingUpload.get(vpath);
    if (!guid) {
      throw new Error("missing guid");
    }
    const doc2 = this.docs.get(guid) || new Document(vpath, guid, this.loginManager, this);
    const originPromise = doc2.getOrigin();
    const awaitingUpdatesPromise = this.awaitingUpdates();
    (async () => {
      const exists = await this.exists(doc2);
      if (!exists) {
        throw new Error(`Upload failed, doc does not exist at ${vpath}`);
      }
      const [contents, origin, awaitingUpdates] = await Promise.all([
        this.read(doc2),
        originPromise,
        awaitingUpdatesPromise
      ]);
      const text3 = doc2.ydoc.getText("contents");
      if (!awaitingUpdates && origin === void 0) {
        this.log(`[${doc2.path}] No Known Peers: Syncing file into ytext.`);
        this.ydoc.transact(() => {
          text3.insert(0, contents);
        }, this._persistence);
        doc2.markOrigin("local");
        this.log(`[${doc2.path}] Uploading file`);
        await this.backgroundSync.enqueueSync(doc2);
        this.markUploaded(doc2);
      }
    })();
    this.docs.set(guid, doc2);
    this.docset.add(doc2, update2);
    return doc2;
  }
  markUploaded(doc2) {
    if (!this.ids.has(doc2.path)) {
      if (doc2._serverSynced) {
        this.ydoc.transact(() => {
          this.log(`[${doc2.path}] File uploaded: adding to set`);
          this.ids.set(doc2.path, doc2.guid);
          this.pendingUpload.delete(doc2.path);
        }, this);
      }
    }
  }
  createDoc(vpath, update2 = true) {
    if (!this.checkExtension(vpath)) {
      throw new Error("unexpected extension");
    }
    if (!this.synced && !this.ids.has(vpath) && !this.pendingUpload.get(vpath)) {
      throw new Error(`potential for document split at ${vpath}`);
    }
    const guid = this.ids.get(vpath) || this.pendingUpload.get(vpath);
    if (!guid) {
      throw new Error("expected guid");
    }
    const doc2 = this.docs.get(guid) || new Document(vpath, guid, this.loginManager, this);
    this.whenReady().then(async () => {
      var _a2;
      const synced = await doc2.getServerSynced();
      if (((_a2 = doc2.tfile) == null ? void 0 : _a2.stat.size) === 0 && !synced) {
        this.backgroundSync.enqueueDownload(doc2);
      } else if (this.pendingUpload.get(doc2.path)) {
        this.backgroundSync.enqueueSync(doc2);
      }
    });
    this.docs.set(guid, doc2);
    this.docset.add(doc2, update2);
    return doc2;
  }
  deleteFile(path) {
    const vPath = this.getVirtualPath(path);
    return this.deleteDoc(vPath);
  }
  deleteDoc(vPath) {
    const guid = this.ids.get(vPath);
    if (guid) {
      this.ydoc.transact(() => {
        var _a2;
        this.ids.delete(vPath);
        this.pendingUpload.delete(vPath);
        const doc2 = this.docs.get(guid);
        if (doc2) {
          (_a2 = doc2._diskBufferStore) == null ? void 0 : _a2.removeDiskBuffer(guid);
          doc2.destroy();
          this.docset.delete(doc2);
        }
        this.docs.delete(guid);
      }, this);
    }
  }
  renameFile(newPath, oldPath) {
    let newVPath = "";
    let oldVPath = "";
    try {
      newVPath = this.getVirtualPath(newPath);
    } catch (e2) {
      this.log("Moving out of shared folder");
    }
    try {
      oldVPath = this.getVirtualPath(oldPath);
    } catch (e2) {
      this.log("Moving in from outside of shared folder");
    }
    if (!newVPath && !oldVPath) {
      return;
    } else if (!oldVPath) {
      this.assertPath(newPath);
      if (!this.checkExtension(newPath))
        return;
      this.placeHold([newVPath]);
      this.uploadDoc(newVPath);
    } else {
      const guid = this.ids.get(oldVPath);
      if (!guid)
        return;
      const doc2 = this.docs.get(guid);
      if (!newVPath) {
        this.ydoc.transact(() => {
          this.ids.delete(oldVPath);
        }, this);
        this.pendingUpload.delete(oldVPath);
        if (doc2) {
          doc2.destroy();
          this.docset.delete(doc2);
        }
        this.docs.delete(guid);
      } else {
        const guid2 = this.ids.get(oldVPath);
        if (!guid2) {
          return;
        }
        const upload = this.pendingUpload.get(oldVPath);
        if (upload) {
          this.pendingUpload.set(newVPath, upload);
          this.pendingUpload.delete(oldVPath);
        }
        this.ydoc.transact(() => {
          this.ids.set(newVPath, guid2);
          this.ids.delete(oldVPath);
          if (doc2) {
            doc2.move(newVPath);
          }
        }, this);
      }
    }
  }
  destroy() {
    var _a2, _b2, _c;
    this.destroyed = true;
    this.docs.forEach((doc2) => {
      doc2.destroy();
      this.docs.delete(doc2.guid);
    });
    super.destroy();
    this.ydoc.destroy();
    this.docset.clear();
    this.unsubscribes.forEach((unsubscribe2) => {
      unsubscribe2();
    });
    this._settings.destroy();
    this._settings = null;
    this.diskBufferStore = null;
    this.relayManager = null;
    this.backgroundSync = null;
    this.loginManager = null;
    this.tokenStore = null;
    this.fileManager = null;
    this.vault = null;
    (_a2 = this.whenSyncedPromise) == null ? void 0 : _a2.destroy();
    this.whenSyncedPromise = null;
    (_b2 = this.readyPromise) == null ? void 0 : _b2.destroy();
    this.readyPromise = null;
    (_c = this.syncFileTreePromise) == null ? void 0 : _c.destroy();
    this.syncFileTreePromise = null;
  }
};
var SharedFolders = class extends ObservableSet {
  constructor(relayManager, vault, folderBuilder, settings) {
    super();
    this.relayManager = relayManager;
    this.vault = vault;
    this.settings = settings;
    this.unsubscribes = [];
    this.update = (0, import_obsidian.debounce)(this.notifyListeners, 100);
    this.folderBuilder = folderBuilder;
    if (!this._offRemoteUpdates) {
      this._offRemoteUpdates = this.relayManager.remoteFolders.subscribe(
        (remotes) => {
          let updated = false;
          this.items().forEach((folder) => {
            const remote = remotes.find((remote2) => remote2.guid == folder.guid);
            if (folder.remote != remote) {
              updated = true;
            }
            folder.remote = remote;
          });
          if (updated) {
            this.update();
          }
        }
      );
    }
  }
  delete(item) {
    item == null ? void 0 : item.destroy();
    const deleted = super.delete(item);
    this.settings.update((current) => {
      return current.filter((settings) => settings.guid !== item.guid);
    });
    return deleted;
  }
  lookup(path) {
    const folder = this.find((sharedFolder) => {
      return sharedFolder.checkPath(path);
    });
    if (!folder) {
      return null;
    }
    return folder;
  }
  destroy() {
    this.items().forEach((folder) => {
      folder.destroy();
    });
    this.clear();
    if (this._offRemoteUpdates) {
      this._offRemoteUpdates();
    }
    this.unsubscribes.forEach((unsub) => {
      unsub();
    });
    this.relayManager = null;
    this.folderBuilder = null;
  }
  load() {
    this._load(this.settings.get());
  }
  _load(folders) {
    let updated = false;
    folders.forEach((folder) => {
      const tFolder = this.vault.getFolderByPath(folder.path);
      if (!tFolder) {
        this.warn(`Invalid settings, ${folder.path} does not exist`);
        return;
      }
      this._new(folder.path, folder.guid, folder == null ? void 0 : folder.relay);
      updated = true;
    });
    if (updated) {
      this.notifyListeners();
    }
  }
  _new(path, guid, relayId, awaitingUpdates) {
    const existing = this.find(
      (folder2) => folder2.path == path && folder2.guid == guid
    );
    if (existing) {
      return existing;
    }
    const sameGuid = this.find((folder2) => folder2.guid == guid);
    if (sameGuid) {
      throw new Error(`This folder is already mounted at ${sameGuid.path}.`);
    }
    const samePath = this.find((folder2) => folder2.path == path);
    if (samePath) {
      throw new Error("Conflict: Tracked folder exists at this location.");
    }
    const folder = this.folderBuilder(path, guid, relayId, awaitingUpdates);
    this._set.add(folder);
    return folder;
  }
  new(path, guid, relayId, awaitingUpdates) {
    const folder = this._new(path, guid, relayId, awaitingUpdates);
    this.notifyListeners();
    return folder;
  }
};

// src/LiveViews.ts
var import_state4 = require("@codemirror/state");
var import_obsidian4 = require("obsidian");

// node_modules/svelte/src/runtime/internal/utils.js
function noop() {
}
function assign2(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return (
    /** @type {T & S} */
    tar
  );
}
function is_promise(value) {
  return !!value && (typeof value === "object" || typeof value === "function") && typeof /** @type {any} */
  value.then === "function";
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
}
var src_url_equal_anchor;
function src_url_equal(element_src, url) {
  if (element_src === url)
    return true;
  if (!src_url_equal_anchor) {
    src_url_equal_anchor = document.createElement("a");
  }
  src_url_equal_anchor.href = url;
  return element_src === src_url_equal_anchor.href;
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe2(store, ...callbacks) {
  if (store == null) {
    for (const callback of callbacks) {
      callback(void 0);
    }
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe2(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign2($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i2 = 0; i2 < len; i2 += 1) {
        merged[i2] = $$scope.dirty[i2] | lets[i2];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length4 = $$scope.ctx.length / 32;
    for (let i2 = 0; i2 < length4; i2++) {
      dirty[i2] = -1;
    }
    return dirty;
  }
  return -1;
}
function exclude_internal_props(props) {
  const result = {};
  for (const k in props)
    if (k[0] !== "$")
      result[k] = props[k];
  return result;
}
function compute_rest_props(props, keys2) {
  const rest = {};
  keys2 = new Set(keys2);
  for (const k in props)
    if (!keys2.has(k) && k[0] !== "$")
      rest[k] = props[k];
  return rest;
}
function null_to_empty(value) {
  return value == null ? "" : value;
}
function set_store_value(store, ret, value) {
  store.set(value);
  return ret;
}
function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}

// node_modules/svelte/src/runtime/internal/globals.js
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : (
  // @ts-ignore Node typings have this
  global
);

// node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js
var ResizeObserverSingleton = class {
  /** @param {ResizeObserverOptions} options */
  constructor(options) {
    /**
     * @private
     * @readonly
     * @type {WeakMap<Element, import('./private.js').Listener>}
     */
    __publicField(this, "_listeners", "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0);
    /**
     * @private
     * @type {ResizeObserver}
     */
    __publicField(this, "_observer");
    /** @type {ResizeObserverOptions} */
    __publicField(this, "options");
    this.options = options;
  }
  /**
   * @param {Element} element
   * @param {import('./private.js').Listener} listener
   * @returns {() => void}
   */
  observe(element3, listener) {
    this._listeners.set(element3, listener);
    this._getObserver().observe(element3, this.options);
    return () => {
      this._listeners.delete(element3);
      this._observer.unobserve(element3);
    };
  }
  /**
   * @private
   */
  _getObserver() {
    var _a2;
    return (_a2 = this._observer) != null ? _a2 : this._observer = new ResizeObserver((entries) => {
      var _a3;
      for (const entry of entries) {
        ResizeObserverSingleton.entries.set(entry.target, entry);
        (_a3 = this._listeners.get(entry.target)) == null ? void 0 : _a3(entry);
      }
    });
  }
};
ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;

// node_modules/svelte/src/runtime/internal/dom.js
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append2(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element2("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && /** @type {ShadowRoot} */
  root.host) {
    return (
      /** @type {ShadowRoot} */
      root
    );
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append2(
    /** @type {Document} */
    node.head || node,
    style
  );
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i2 = 0; i2 < iterations.length; i2 += 1) {
    if (iterations[i2])
      iterations[i2].d(detaching);
  }
}
function element2(name) {
  return document.createElement(name);
}
function svg_element(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}
function text2(data) {
  return document.createTextNode(data);
}
function space() {
  return text2(" ");
}
function empty() {
  return text2("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function stop_propagation(fn) {
  return function(event) {
    event.stopPropagation();
    return fn.call(this, event);
  };
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function set_svg_attributes(node, attributes) {
  for (const key in attributes) {
    attr(node, key, attributes[key]);
  }
}
function children(element3) {
  return Array.from(element3.childNodes);
}
function set_data(text3, data) {
  data = "" + data;
  if (text3.data === data)
    return;
  text3.data = /** @type {string} */
  data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key, value, important) {
  if (value == null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function toggle_class(element3, name, toggle) {
  element3.classList.toggle(name, !!toggle);
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  return new CustomEvent(type, { detail, bubbles, cancelable });
}
function get_custom_elements_slots(element3) {
  const result = {};
  element3.childNodes.forEach(
    /** @param {Element} node */
    (node) => {
      result[node.slot || "default"] = true;
    }
  );
  return result;
}
function construct_svelte_component(component, props) {
  return new component(props);
}

// node_modules/svelte/src/runtime/internal/lifecycle.js
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail, { cancelable = false } = {}) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(
        /** @type {string} */
        type,
        detail,
        { cancelable }
      );
      callbacks.slice().forEach((fn) => {
        fn.call(component, event);
      });
      return !event.defaultPrevented;
    }
    return true;
  };
}
function bubble(component, event) {
  const callbacks = component.$$.callbacks[event.type];
  if (callbacks) {
    callbacks.slice().forEach((fn) => fn.call(this, event));
  }
}

// node_modules/svelte/src/runtime/internal/scheduler.js
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e2) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e2;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i2 = 0; i2 < render_callbacks.length; i2 += 1) {
      const callback = render_callbacks[i2];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}

// node_modules/svelte/src/runtime/internal/transitions.js
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}

// node_modules/svelte/src/runtime/internal/await_block.js
function handle_promise(promise, info) {
  const token = info.token = {};
  function update2(type, index, key, value) {
    if (info.token !== token)
      return;
    info.resolved = value;
    let child_ctx = info.ctx;
    if (key !== void 0) {
      child_ctx = child_ctx.slice();
      child_ctx[key] = value;
    }
    const block = type && (info.current = type)(child_ctx);
    let needs_flush = false;
    if (info.block) {
      if (info.blocks) {
        info.blocks.forEach((block2, i2) => {
          if (i2 !== index && block2) {
            group_outros();
            transition_out(block2, 1, 1, () => {
              if (info.blocks[i2] === block2) {
                info.blocks[i2] = null;
              }
            });
            check_outros();
          }
        });
      } else {
        info.block.d(1);
      }
      block.c();
      transition_in(block, 1);
      block.m(info.mount(), info.anchor);
      needs_flush = true;
    }
    info.block = block;
    if (info.blocks)
      info.blocks[index] = block;
    if (needs_flush) {
      flush();
    }
  }
  if (is_promise(promise)) {
    const current_component2 = get_current_component();
    promise.then(
      (value) => {
        set_current_component(current_component2);
        update2(info.then, 1, info.value, value);
        set_current_component(null);
      },
      (error) => {
        set_current_component(current_component2);
        update2(info.catch, 2, info.error, error);
        set_current_component(null);
        if (!info.hasCatch) {
          throw error;
        }
      }
    );
    if (info.current !== info.pending) {
      update2(info.pending, 0);
      return true;
    }
  } else {
    if (info.current !== info.then) {
      update2(info.then, 1, info.value, promise);
      return true;
    }
    info.resolved = /** @type {T} */
    promise;
  }
}
function update_await_block_branch(info, ctx, dirty) {
  const child_ctx = ctx.slice();
  const { resolved } = info;
  if (info.current === info.then) {
    child_ctx[info.value] = resolved;
  }
  if (info.current === info.catch) {
    child_ctx[info.error] = resolved;
  }
  info.block.p(child_ctx, dirty);
}

// node_modules/svelte/src/runtime/internal/each.js
function ensure_array_like(array_like_or_iterator) {
  return (array_like_or_iterator == null ? void 0 : array_like_or_iterator.length) !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}
function outro_and_destroy_block(block, lookup) {
  transition_out(block, 1, 1, () => {
    lookup.delete(block.key);
  });
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block11, next, get_context) {
  let o = old_blocks.length;
  let n = list.length;
  let i2 = o;
  const old_indexes = {};
  while (i2--)
    old_indexes[old_blocks[i2].key] = i2;
  const new_blocks = [];
  const new_lookup = /* @__PURE__ */ new Map();
  const deltas = /* @__PURE__ */ new Map();
  const updates = [];
  i2 = n;
  while (i2--) {
    const child_ctx = get_context(ctx, list, i2);
    const key = get_key(child_ctx);
    let block = lookup.get(key);
    if (!block) {
      block = create_each_block11(key, child_ctx);
      block.c();
    } else if (dynamic) {
      updates.push(() => block.p(child_ctx, dirty));
    }
    new_lookup.set(key, new_blocks[i2] = block);
    if (key in old_indexes)
      deltas.set(key, Math.abs(i2 - old_indexes[key]));
  }
  const will_move = /* @__PURE__ */ new Set();
  const did_move = /* @__PURE__ */ new Set();
  function insert2(block) {
    transition_in(block, 1);
    block.m(node, next);
    lookup.set(block.key, block);
    next = block.first;
    n--;
  }
  while (o && n) {
    const new_block = new_blocks[n - 1];
    const old_block = old_blocks[o - 1];
    const new_key = new_block.key;
    const old_key = old_block.key;
    if (new_block === old_block) {
      next = new_block.first;
      o--;
      n--;
    } else if (!new_lookup.has(old_key)) {
      destroy(old_block, lookup);
      o--;
    } else if (!lookup.has(new_key) || will_move.has(new_key)) {
      insert2(new_block);
    } else if (did_move.has(old_key)) {
      o--;
    } else if (deltas.get(new_key) > deltas.get(old_key)) {
      did_move.add(new_key);
      insert2(new_block);
    } else {
      will_move.add(old_key);
      o--;
    }
  }
  while (o--) {
    const old_block = old_blocks[o];
    if (!new_lookup.has(old_block.key))
      destroy(old_block, lookup);
  }
  while (n)
    insert2(new_blocks[n - 1]);
  run_all(updates);
  return new_blocks;
}

// node_modules/svelte/src/runtime/internal/spread.js
function get_spread_update(levels, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = { $$scope: 1 };
  let i2 = levels.length;
  while (i2--) {
    const o = levels[i2];
    const n = updates[i2];
    if (n) {
      for (const key in o) {
        if (!(key in n))
          to_null_out[key] = 1;
      }
      for (const key in n) {
        if (!accounted_for[key]) {
          update2[key] = n[key];
          accounted_for[key] = 1;
        }
      }
      levels[i2] = n;
    } else {
      for (const key in o) {
        accounted_for[key] = 1;
      }
    }
  }
  for (const key in to_null_out) {
    if (!(key in update2))
      update2[key] = void 0;
  }
  return update2;
}
function get_spread_object(spread_props) {
  return typeof spread_props === "object" && spread_props !== null ? spread_props : {};
}

// node_modules/svelte/src/shared/boolean_attributes.js
var _boolean_attributes = (
  /** @type {const} */
  [
    "allowfullscreen",
    "allowpaymentrequest",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "defer",
    "disabled",
    "formnovalidate",
    "hidden",
    "inert",
    "ismap",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "selected"
  ]
);
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);

// node_modules/svelte/src/runtime/internal/Component.js
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor) {
  const { fragment: fragment2, after_update } = component.$$;
  fragment2 && fragment2.m(target, anchor);
  add_render_callback(() => {
    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
    if (component.$$.on_destroy) {
      component.$$.on_destroy.push(...new_on_destroy);
    } else {
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i2) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i2 / 31 | 0] |= 1 << i2 % 31;
}
function init(component, options, instance54, create_fragment55, not_equal, props, append_styles2 = null, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance54 ? instance54(component, options.props || {}, (i2, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i2], $$.ctx[i2] = value)) {
      if (!$$.skip_bound && $$.bound[i2])
        $$.bound[i2](value);
      if (ready)
        make_dirty(component, i2);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment55 ? create_fragment55($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor($$componentCtor, $$slots, use_shadow_dom) {
      super();
      /** The Svelte component constructor */
      __publicField(this, "$$ctor");
      /** Slots */
      __publicField(this, "$$s");
      /** The Svelte component instance */
      __publicField(this, "$$c");
      /** Whether or not the custom element is connected */
      __publicField(this, "$$cn", false);
      /** Component props data */
      __publicField(this, "$$d", {});
      /** `true` if currently in the process of reflecting component props back to attributes */
      __publicField(this, "$$r", false);
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      __publicField(this, "$$p_d", {});
      /** @type {Record<string, Function[]>} Event listeners */
      __publicField(this, "$$l", {});
      /** @type {Map<Function, Function>} Event listener unsubscribe functions */
      __publicField(this, "$$l_u", /* @__PURE__ */ new Map());
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (use_shadow_dom) {
        this.attachShadow({ mode: "open" });
      }
    }
    addEventListener(type, listener, options) {
      this.$$l[type] = this.$$l[type] || [];
      this.$$l[type].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
    }
    async connectedCallback() {
      this.$$cn = true;
      if (!this.$$c) {
        let create_slot2 = function(name) {
          return () => {
            let node;
            const obj = {
              c: function create8() {
                node = element2("slot");
                if (name !== "default") {
                  attr(node, "name", name);
                }
              },
              /**
               * @param {HTMLElement} target
               * @param {HTMLElement} [anchor]
               */
              m: function mount(target, anchor) {
                insert(target, node, anchor);
              },
              d: function destroy(detaching) {
                if (detaching) {
                  detach(node);
                }
              }
            };
            return obj;
          };
        };
        await Promise.resolve();
        if (!this.$$cn || this.$$c) {
          return;
        }
        const $$slots = {};
        const existing_slots = get_custom_elements_slots(this);
        for (const name of this.$$s) {
          if (name in existing_slots) {
            $$slots[name] = [create_slot2(name)];
          }
        }
        for (const attribute of this.attributes) {
          const name = this.$$g_p(attribute.name);
          if (!(name in this.$$d)) {
            this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
          }
        }
        for (const key in this.$$p_d) {
          if (!(key in this.$$d) && this[key] !== void 0) {
            this.$$d[key] = this[key];
            delete this[key];
          }
        }
        this.$$c = new this.$$ctor({
          target: this.shadowRoot || this,
          props: {
            ...this.$$d,
            $$slots,
            $$scope: {
              ctx: []
            }
          }
        });
        const reflect_attributes = () => {
          this.$$r = true;
          for (const key in this.$$p_d) {
            this.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];
            if (this.$$p_d[key].reflect) {
              const attribute_value = get_custom_element_value(
                key,
                this.$$d[key],
                this.$$p_d,
                "toAttribute"
              );
              if (attribute_value == null) {
                this.removeAttribute(this.$$p_d[key].attribute || key);
              } else {
                this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
              }
            }
          }
          this.$$r = false;
        };
        this.$$c.$$.after_update.push(reflect_attributes);
        reflect_attributes();
        for (const type in this.$$l) {
          for (const listener of this.$$l[type]) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
        }
        this.$$l = {};
      }
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    attributeChangedCallback(attr2, _oldValue, newValue) {
      var _a2;
      if (this.$$r)
        return;
      attr2 = this.$$g_p(attr2);
      this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
      (_a2 = this.$$c) == null ? void 0 : _a2.$set({ [attr2]: this.$$d[attr2] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn && this.$$c) {
          this.$$c.$destroy();
          this.$$c = void 0;
        }
      });
    }
    $$g_p(attribute_name) {
      return Object.keys(this.$$p_d).find(
        (key) => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name
      ) || attribute_name;
    }
  };
}
function get_custom_element_value(prop, value, props_definition, transform) {
  var _a2;
  const type = (_a2 = props_definition[prop]) == null ? void 0 : _a2.type;
  value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform || !props_definition[prop]) {
    return value;
  } else if (transform === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
var SvelteComponent = class {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(props) {
    if (this.$$set && !is_empty(props)) {
      this.$$.skip_bound = true;
      this.$$set(props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/src/shared/version.js
var PUBLIC_VERSION = "4";

// node_modules/svelte/src/runtime/internal/disclose-version/index.js
if (typeof window !== "undefined")
  (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);

// node_modules/lucide-svelte/dist/defaultAttributes.js
var defaultAttributes = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": 2,
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
var defaultAttributes_default = defaultAttributes;

// node_modules/lucide-svelte/dist/Icon.svelte
function get_each_context(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i2][0];
  child_ctx[12] = list[i2][1];
  return child_ctx;
}
function create_dynamic_element(ctx) {
  let svelte_element;
  let svelte_element_levels = [
    /*attrs*/
    ctx[12]
  ];
  let svelte_element_data = {};
  for (let i2 = 0; i2 < svelte_element_levels.length; i2 += 1) {
    svelte_element_data = assign2(svelte_element_data, svelte_element_levels[i2]);
  }
  return {
    c() {
      svelte_element = svg_element(
        /*tag*/
        ctx[11]
      );
      set_svg_attributes(svelte_element, svelte_element_data);
    },
    m(target, anchor) {
      insert(target, svelte_element, anchor);
    },
    p(ctx2, dirty) {
      set_svg_attributes(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [dirty & /*iconNode*/
      32 && /*attrs*/
      ctx2[12]]));
    },
    d(detaching) {
      if (detaching) {
        detach(svelte_element);
      }
    }
  };
}
function create_each_block(ctx) {
  let previous_tag = (
    /*tag*/
    ctx[11]
  );
  let svelte_element_anchor;
  let svelte_element = (
    /*tag*/
    ctx[11] && create_dynamic_element(ctx)
  );
  return {
    c() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    m(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert(target, svelte_element_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (
        /*tag*/
        ctx2[11]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*tag*/
          ctx2[11];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*tag*/
          ctx2[11]
        )) {
          svelte_element.d(1);
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*tag*/
          ctx2[11];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
        previous_tag = /*tag*/
        ctx2[11];
      }
    },
    d(detaching) {
      if (detaching) {
        detach(svelte_element_anchor);
      }
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
}
function create_fragment(ctx) {
  let svg;
  let each_1_anchor;
  let svg_stroke_width_value;
  let svg_class_value;
  let current;
  let each_value = ensure_array_like(
    /*iconNode*/
    ctx[5]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block(get_each_context(ctx, each_value, i2));
  }
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  let svg_levels = [
    defaultAttributes_default,
    /*$$restProps*/
    ctx[7],
    { width: (
      /*size*/
      ctx[2]
    ) },
    { height: (
      /*size*/
      ctx[2]
    ) },
    { stroke: (
      /*color*/
      ctx[1]
    ) },
    {
      "stroke-width": svg_stroke_width_value = /*absoluteStrokeWidth*/
      ctx[4] ? Number(
        /*strokeWidth*/
        ctx[3]
      ) * 24 / Number(
        /*size*/
        ctx[2]
      ) : (
        /*strokeWidth*/
        ctx[3]
      )
    },
    {
      class: svg_class_value = /*mergeClasses*/
      ctx[6](
        "lucide-icon",
        "lucide",
        /*name*/
        ctx[0] ? `lucide-${/*name*/
        ctx[0]}` : "",
        /*$$props*/
        ctx[8].class
      )
    }
  ];
  let svg_data = {};
  for (let i2 = 0; i2 < svg_levels.length; i2 += 1) {
    svg_data = assign2(svg_data, svg_levels[i2]);
  }
  return {
    c() {
      svg = svg_element("svg");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
      if (default_slot)
        default_slot.c();
      set_svg_attributes(svg, svg_data);
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(svg, null);
        }
      }
      append2(svg, each_1_anchor);
      if (default_slot) {
        default_slot.m(svg, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*iconNode*/
      32) {
        each_value = ensure_array_like(
          /*iconNode*/
          ctx2[5]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(svg, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        defaultAttributes_default,
        dirty & /*$$restProps*/
        128 && /*$$restProps*/
        ctx2[7],
        (!current || dirty & /*size*/
        4) && { width: (
          /*size*/
          ctx2[2]
        ) },
        (!current || dirty & /*size*/
        4) && { height: (
          /*size*/
          ctx2[2]
        ) },
        (!current || dirty & /*color*/
        2) && { stroke: (
          /*color*/
          ctx2[1]
        ) },
        (!current || dirty & /*absoluteStrokeWidth, strokeWidth, size*/
        28 && svg_stroke_width_value !== (svg_stroke_width_value = /*absoluteStrokeWidth*/
        ctx2[4] ? Number(
          /*strokeWidth*/
          ctx2[3]
        ) * 24 / Number(
          /*size*/
          ctx2[2]
        ) : (
          /*strokeWidth*/
          ctx2[3]
        ))) && { "stroke-width": svg_stroke_width_value },
        (!current || dirty & /*name, $$props*/
        257 && svg_class_value !== (svg_class_value = /*mergeClasses*/
        ctx2[6](
          "lucide-icon",
          "lucide",
          /*name*/
          ctx2[0] ? `lucide-${/*name*/
          ctx2[0]}` : "",
          /*$$props*/
          ctx2[8].class
        ))) && { class: svg_class_value }
      ]));
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
      destroy_each(each_blocks, detaching);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "name",
    "color",
    "size",
    "strokeWidth",
    "absoluteStrokeWidth",
    "iconNode",
    "mergeClasses"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { name = void 0 } = $$props;
  let { color = "currentColor" } = $$props;
  let { size = 24 } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { absoluteStrokeWidth = false } = $$props;
  let { iconNode } = $$props;
  const mergeClasses = (...classes) => classes.filter((className, index, array) => {
    return Boolean(className) && array.indexOf(className) === index;
  }).join(" ");
  $$self.$$set = ($$new_props) => {
    $$invalidate(8, $$props = assign2(assign2({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("name" in $$new_props)
      $$invalidate(0, name = $$new_props.name);
    if ("color" in $$new_props)
      $$invalidate(1, color = $$new_props.color);
    if ("size" in $$new_props)
      $$invalidate(2, size = $$new_props.size);
    if ("strokeWidth" in $$new_props)
      $$invalidate(3, strokeWidth = $$new_props.strokeWidth);
    if ("absoluteStrokeWidth" in $$new_props)
      $$invalidate(4, absoluteStrokeWidth = $$new_props.absoluteStrokeWidth);
    if ("iconNode" in $$new_props)
      $$invalidate(5, iconNode = $$new_props.iconNode);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [
    name,
    color,
    size,
    strokeWidth,
    absoluteStrokeWidth,
    iconNode,
    mergeClasses,
    $$restProps,
    $$props,
    $$scope,
    slots
  ];
}
var Icon = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, {
      name: 0,
      color: 1,
      size: 2,
      strokeWidth: 3,
      absoluteStrokeWidth: 4,
      iconNode: 5,
      mergeClasses: 6
    });
  }
  get mergeClasses() {
    return this.$$.ctx[6];
  }
};
var Icon_default = Icon;

// node_modules/lucide-svelte/dist/icons/arrow-right-left.svelte
function create_default_slot(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment2(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "arrow-right-left" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot] },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < icon_spread_levels.length; i2 += 1) {
    icon_props = assign2(icon_props, icon_spread_levels[i2]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["path", { "d": "m16 3 4 4-4 4" }],
    ["path", { "d": "M20 7H4" }],
    ["path", { "d": "m8 21-4-4 4-4" }],
    ["path", { "d": "M4 17h16" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign2(assign2({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Arrow_right_left = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, {});
  }
};
var arrow_right_left_default = Arrow_right_left;

// node_modules/lucide-svelte/dist/icons/arrow-up-down.svelte
function create_default_slot2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment3(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "arrow-up-down" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot2] },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < icon_spread_levels.length; i2 += 1) {
    icon_props = assign2(icon_props, icon_spread_levels[i2]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["path", { "d": "m21 16-4 4-4-4" }],
    ["path", { "d": "M17 20V4" }],
    ["path", { "d": "m3 8 4-4 4 4" }],
    ["path", { "d": "M7 4v16" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign2(assign2({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Arrow_up_down = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment3, safe_not_equal, {});
  }
};
var arrow_up_down_default = Arrow_up_down;

// node_modules/lucide-svelte/dist/icons/chevron-left.svelte
function create_default_slot3(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment4(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "chevron-left" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot3] },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < icon_spread_levels.length; i2 += 1) {
    icon_props = assign2(icon_props, icon_spread_levels[i2]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [["path", { "d": "m15 18-6-6 6-6" }]];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign2(assign2({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Chevron_left = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance4, create_fragment4, safe_not_equal, {});
  }
};
var chevron_left_default = Chevron_left;

// node_modules/lucide-svelte/dist/icons/chevron-right.svelte
function create_default_slot4(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment5(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "chevron-right" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot4] },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < icon_spread_levels.length; i2 += 1) {
    icon_props = assign2(icon_props, icon_spread_levels[i2]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance5($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [["path", { "d": "m9 18 6-6-6-6" }]];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign2(assign2({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Chevron_right = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance5, create_fragment5, safe_not_equal, {});
  }
};
var chevron_right_default = Chevron_right;

// node_modules/lucide-svelte/dist/icons/circle-check-big.svelte
function create_default_slot5(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment6(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "circle-check-big" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot5] },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < icon_spread_levels.length; i2 += 1) {
    icon_props = assign2(icon_props, icon_spread_levels[i2]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance6($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M22 11.08V12a10 10 0 1 1-5.93-9.14"
      }
    ],
    ["path", { "d": "m9 11 3 3L22 4" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign2(assign2({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Circle_check_big = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance6, create_fragment6, safe_not_equal, {});
  }
};
var circle_check_big_default = Circle_check_big;

// node_modules/lucide-svelte/dist/icons/circle-help.svelte
function create_default_slot6(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment7(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "circle-help" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot6] },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < icon_spread_levels.length; i2 += 1) {
    icon_props = assign2(icon_props, icon_spread_levels[i2]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance7($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["circle", { "cx": "12", "cy": "12", "r": "10" }],
    [
      "path",
      {
        "d": "M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"
      }
    ],
    ["path", { "d": "M12 17h.01" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign2(assign2({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Circle_help = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance7, create_fragment7, safe_not_equal, {});
  }
};
var circle_help_default = Circle_help;

// node_modules/lucide-svelte/dist/icons/clock.svelte
function create_default_slot7(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment8(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "clock" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot7] },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < icon_spread_levels.length; i2 += 1) {
    icon_props = assign2(icon_props, icon_spread_levels[i2]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance8($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["circle", { "cx": "12", "cy": "12", "r": "10" }],
    ["polyline", { "points": "12 6 12 12 16 14" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign2(assign2({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Clock = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance8, create_fragment8, safe_not_equal, {});
  }
};
var clock_default = Clock;

// node_modules/lucide-svelte/dist/icons/download.svelte
function create_default_slot8(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment9(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "download" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot8] },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < icon_spread_levels.length; i2 += 1) {
    icon_props = assign2(icon_props, icon_spread_levels[i2]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance9($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"
      }
    ],
    ["polyline", { "points": "7 10 12 15 17 10" }],
    [
      "line",
      {
        "x1": "12",
        "x2": "12",
        "y1": "15",
        "y2": "3"
      }
    ]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign2(assign2({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Download = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance9, create_fragment9, safe_not_equal, {});
  }
};
var download_default = Download;

// node_modules/lucide-svelte/dist/icons/folder.svelte
function create_default_slot9(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment10(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "folder" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot9] },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < icon_spread_levels.length; i2 += 1) {
    icon_props = assign2(icon_props, icon_spread_levels[i2]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance10($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M20 20a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.9a2 2 0 0 1-1.69-.9L9.6 3.9A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2Z"
      }
    ]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign2(assign2({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Folder = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance10, create_fragment10, safe_not_equal, {});
  }
};
var folder_default = Folder;

// node_modules/lucide-svelte/dist/icons/info.svelte
function create_default_slot10(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment11(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "info" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot10] },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < icon_spread_levels.length; i2 += 1) {
    icon_props = assign2(icon_props, icon_spread_levels[i2]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance11($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["circle", { "cx": "12", "cy": "12", "r": "10" }],
    ["path", { "d": "M12 16v-4" }],
    ["path", { "d": "M12 8h.01" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign2(assign2({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Info = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance11, create_fragment11, safe_not_equal, {});
  }
};
var info_default = Info;

// node_modules/lucide-svelte/dist/icons/layers.svelte
function create_default_slot11(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment12(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "layers" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot11] },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < icon_spread_levels.length; i2 += 1) {
    icon_props = assign2(icon_props, icon_spread_levels[i2]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance12($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "m12.83 2.18a2 2 0 0 0-1.66 0L2.6 6.08a1 1 0 0 0 0 1.83l8.58 3.91a2 2 0 0 0 1.66 0l8.58-3.9a1 1 0 0 0 0-1.83Z"
      }
    ],
    [
      "path",
      {
        "d": "m22 17.65-9.17 4.16a2 2 0 0 1-1.66 0L2 17.65"
      }
    ],
    [
      "path",
      {
        "d": "m22 12.65-9.17 4.16a2 2 0 0 1-1.66 0L2 12.65"
      }
    ]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign2(assign2({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Layers = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance12, create_fragment12, safe_not_equal, {});
  }
};
var layers_default = Layers;

// node_modules/lucide-svelte/dist/icons/message-square-heart.svelte
function create_default_slot12(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment13(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "message-square-heart" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot12] },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < icon_spread_levels.length; i2 += 1) {
    icon_props = assign2(icon_props, icon_spread_levels[i2]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance13($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"
      }
    ],
    [
      "path",
      {
        "d": "M14.8 7.5a1.84 1.84 0 0 0-2.6 0l-.2.3-.3-.3a1.84 1.84 0 1 0-2.4 2.8L12 13l2.7-2.7c.9-.9.8-2.1.1-2.8"
      }
    ]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign2(assign2({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Message_square_heart = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance13, create_fragment13, safe_not_equal, {});
  }
};
var message_square_heart_default = Message_square_heart;

// node_modules/lucide-svelte/dist/icons/pause.svelte
function create_default_slot13(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment14(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "pause" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot13] },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < icon_spread_levels.length; i2 += 1) {
    icon_props = assign2(icon_props, icon_spread_levels[i2]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance14($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "rect",
      {
        "x": "14",
        "y": "4",
        "width": "4",
        "height": "16",
        "rx": "1"
      }
    ],
    [
      "rect",
      {
        "x": "6",
        "y": "4",
        "width": "4",
        "height": "16",
        "rx": "1"
      }
    ]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign2(assign2({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Pause = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance14, create_fragment14, safe_not_equal, {});
  }
};
var pause_default = Pause;

// node_modules/lucide-svelte/dist/icons/play.svelte
function create_default_slot14(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment15(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "play" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot14] },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < icon_spread_levels.length; i2 += 1) {
    icon_props = assign2(icon_props, icon_spread_levels[i2]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance15($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [["polygon", { "points": "6 3 20 12 6 21 6 3" }]];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign2(assign2({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Play = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance15, create_fragment15, safe_not_equal, {});
  }
};
var play_default = Play;

// node_modules/lucide-svelte/dist/icons/refresh-cw.svelte
function create_default_slot15(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment16(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "refresh-cw" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot15] },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < icon_spread_levels.length; i2 += 1) {
    icon_props = assign2(icon_props, icon_spread_levels[i2]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance16($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"
      }
    ],
    ["path", { "d": "M21 3v5h-5" }],
    [
      "path",
      {
        "d": "M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"
      }
    ],
    ["path", { "d": "M8 16H3v5" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign2(assign2({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Refresh_cw = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance16, create_fragment16, safe_not_equal, {});
  }
};
var refresh_cw_default = Refresh_cw;

// node_modules/lucide-svelte/dist/icons/satellite.svelte
function create_default_slot16(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment17(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "satellite" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot16] },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < icon_spread_levels.length; i2 += 1) {
    icon_props = assign2(icon_props, icon_spread_levels[i2]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance17($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["path", { "d": "M13 7 9 3 5 7l4 4" }],
    ["path", { "d": "m17 11 4 4-4 4-4-4" }],
    ["path", { "d": "m8 12 4 4 6-6-4-4Z" }],
    ["path", { "d": "m16 8 3-3" }],
    ["path", { "d": "M9 21a6 6 0 0 0-6-6" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign2(assign2({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Satellite = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance17, create_fragment17, safe_not_equal, {});
  }
};
var satellite_default = Satellite;

// node_modules/lucide-svelte/dist/icons/settings.svelte
function create_default_slot17(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment18(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "settings" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot17] },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < icon_spread_levels.length; i2 += 1) {
    icon_props = assign2(icon_props, icon_spread_levels[i2]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance18($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"
      }
    ],
    ["circle", { "cx": "12", "cy": "12", "r": "3" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign2(assign2({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Settings = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance18, create_fragment18, safe_not_equal, {});
  }
};
var settings_default = Settings;

// node_modules/lucide-svelte/dist/icons/triangle-alert.svelte
function create_default_slot18(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment19(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "triangle-alert" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot18] },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < icon_spread_levels.length; i2 += 1) {
    icon_props = assign2(icon_props, icon_spread_levels[i2]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance19($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3"
      }
    ],
    ["path", { "d": "M12 9v4" }],
    ["path", { "d": "M12 17h.01" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign2(assign2({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Triangle_alert = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance19, create_fragment19, safe_not_equal, {});
  }
};
var triangle_alert_default = Triangle_alert;

// node_modules/lucide-svelte/dist/icons/upload.svelte
function create_default_slot19(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment20(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "upload" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot19] },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < icon_spread_levels.length; i2 += 1) {
    icon_props = assign2(icon_props, icon_spread_levels[i2]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance20($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"
      }
    ],
    ["polyline", { "points": "17 8 12 3 7 8" }],
    [
      "line",
      {
        "x1": "12",
        "x2": "12",
        "y1": "3",
        "y2": "15"
      }
    ]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign2(assign2({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Upload = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance20, create_fragment20, safe_not_equal, {});
  }
};
var upload_default = Upload;

// src/components/ViewActions.svelte
function add_css(target) {
  append_styles(target, "svelte-1gxdage", "button.notebook.svelte-1gxdage{color:var(--color-base-30);background-color:transparent}button.notebook-synced.svelte-1gxdage{color:var(--color-accent)}button.system3-connected.svelte-1gxdage{color:var(--color-accent)}button.system3-disconnected.svelte-1gxdage{color:var(--color-base-40)}");
}
function create_else_block(ctx) {
  let button;
  let layers;
  let button_class_value;
  let button_aria_label_value;
  let button_data_filename_value;
  let current;
  layers = new layers_default({ props: { class: "svg-icon inline-icon" } });
  return {
    c() {
      var _a2;
      button = element2("button");
      create_component(layers.$$.fragment);
      attr(button, "class", button_class_value = "clickable-icon view-action system3-view-action " + /*view*/
      (ctx[0].tracking ? "notebook-synced" : "notebook") + " svelte-1gxdage");
      attr(button, "aria-label", button_aria_label_value = /*view*/
      ctx[0].tracking ? "Tracking changes: local file and update log are in sync" : "Not tracking changes: local file and update log are not in sync");
      attr(button, "tabindex", "0");
      attr(button, "data-filename", button_data_filename_value = /*view*/
      (_a2 = ctx[0].view.file) == null ? void 0 : _a2.name);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      mount_component(layers, button, null);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      if (!current || dirty & /*view*/
      1 && button_class_value !== (button_class_value = "clickable-icon view-action system3-view-action " + /*view*/
      (ctx2[0].tracking ? "notebook-synced" : "notebook") + " svelte-1gxdage")) {
        attr(button, "class", button_class_value);
      }
      if (!current || dirty & /*view*/
      1 && button_aria_label_value !== (button_aria_label_value = /*view*/
      ctx2[0].tracking ? "Tracking changes: local file and update log are in sync" : "Not tracking changes: local file and update log are not in sync")) {
        attr(button, "aria-label", button_aria_label_value);
      }
      if (!current || dirty & /*view*/
      1 && button_data_filename_value !== (button_data_filename_value = /*view*/
      (_a2 = ctx2[0].view.file) == null ? void 0 : _a2.name)) {
        attr(button, "data-filename", button_data_filename_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(layers.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(layers.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      destroy_component(layers);
    }
  };
}
function create_if_block(ctx) {
  let button0;
  let layers;
  let button0_class_value;
  let button0_aria_label_value;
  let button0_data_filename_value;
  let t2;
  let button1;
  let satellite;
  let button1_class_value;
  let button1_aria_label_value;
  let current;
  let mounted;
  let dispose;
  layers = new layers_default({ props: { class: "svg-icon inline-icon" } });
  satellite = new satellite_default({ props: { class: "svg-icon inline-icon" } });
  return {
    c() {
      var _a2;
      button0 = element2("button");
      create_component(layers.$$.fragment);
      t2 = space();
      button1 = element2("button");
      create_component(satellite.$$.fragment);
      attr(button0, "class", button0_class_value = "clickable-icon view-action system3-view-action " + /*view*/
      (ctx[0].tracking ? "notebook-synced" : "notebook") + " svelte-1gxdage");
      attr(button0, "aria-label", button0_aria_label_value = /*view*/
      ctx[0].tracking ? "Tracking changes: local file and update log are in sync" : "Not tracking changes: local file and update log are not in sync");
      attr(button0, "tabindex", "0");
      attr(button0, "data-filename", button0_data_filename_value = /*view*/
      (_a2 = ctx[0].view.file) == null ? void 0 : _a2.name);
      attr(button1, "class", button1_class_value = "system3-" + /*state*/
      ctx[1].status + " clickable-icon view-action system3-view-action svelte-1gxdage");
      attr(button1, "aria-label", button1_aria_label_value = `${/*remote*/
      ctx[2].relay.name} (${/*state*/
      ctx[1].status})`);
      attr(button1, "tabindex", "0");
    },
    m(target, anchor) {
      insert(target, button0, anchor);
      mount_component(layers, button0, null);
      insert(target, t2, anchor);
      insert(target, button1, anchor);
      mount_component(satellite, button1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button1,
            "click",
            /*handleClick*/
            ctx[3]
          ),
          listen(
            button1,
            "keypress",
            /*handleKeyPress*/
            ctx[4]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      var _a2;
      if (!current || dirty & /*view*/
      1 && button0_class_value !== (button0_class_value = "clickable-icon view-action system3-view-action " + /*view*/
      (ctx2[0].tracking ? "notebook-synced" : "notebook") + " svelte-1gxdage")) {
        attr(button0, "class", button0_class_value);
      }
      if (!current || dirty & /*view*/
      1 && button0_aria_label_value !== (button0_aria_label_value = /*view*/
      ctx2[0].tracking ? "Tracking changes: local file and update log are in sync" : "Not tracking changes: local file and update log are not in sync")) {
        attr(button0, "aria-label", button0_aria_label_value);
      }
      if (!current || dirty & /*view*/
      1 && button0_data_filename_value !== (button0_data_filename_value = /*view*/
      (_a2 = ctx2[0].view.file) == null ? void 0 : _a2.name)) {
        attr(button0, "data-filename", button0_data_filename_value);
      }
      if (!current || dirty & /*state*/
      2 && button1_class_value !== (button1_class_value = "system3-" + /*state*/
      ctx2[1].status + " clickable-icon view-action system3-view-action svelte-1gxdage")) {
        attr(button1, "class", button1_class_value);
      }
      if (!current || dirty & /*remote, state*/
      6 && button1_aria_label_value !== (button1_aria_label_value = `${/*remote*/
      ctx2[2].relay.name} (${/*state*/
      ctx2[1].status})`)) {
        attr(button1, "aria-label", button1_aria_label_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(layers.$$.fragment, local);
      transition_in(satellite.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(layers.$$.fragment, local);
      transition_out(satellite.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button0);
        detach(t2);
        detach(button1);
      }
      destroy_component(layers);
      destroy_component(satellite);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment21(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*remote*/
      ctx2[2]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function instance21($$self, $$props, $$invalidate) {
  let { view } = $$props;
  let { state } = $$props;
  let { remote } = $$props;
  const ariaLabels = {
    connected: "connected: click to go offline",
    connecting: "connecting...",
    disconnected: "disconnected: click to go online",
    unknown: "unknown status"
  };
  const handleClick = () => {
    view.toggleConnection();
  };
  const handleKeyPress = (event) => {
    if (event.key === "Enter") {
      handleClick();
    }
  };
  $$self.$$set = ($$props2) => {
    if ("view" in $$props2)
      $$invalidate(0, view = $$props2.view);
    if ("state" in $$props2)
      $$invalidate(1, state = $$props2.state);
    if ("remote" in $$props2)
      $$invalidate(2, remote = $$props2.remote);
  };
  return [view, state, remote, handleClick, handleKeyPress];
}
var ViewActions = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance21, create_fragment21, safe_not_equal, { view: 0, state: 1, remote: 2 }, add_css);
  }
};
var ViewActions_default = ViewActions;

// src/ui/Banner.ts
var Banner = class {
  constructor(view, text3, onClick) {
    this.view = view;
    this.text = text3;
    this.onClick = onClick;
    this.display();
  }
  display() {
    const leafContentEl = this.view.containerEl;
    const contentEl = this.view.containerEl.querySelector(".view-content");
    if (!leafContentEl) {
      return;
    }
    let bannerBox = leafContentEl.querySelector(".system3-banner-box");
    if (!bannerBox) {
      bannerBox = document.createElement("div");
      bannerBox.classList.add("system3-banner-box");
      leafContentEl.insertBefore(bannerBox, contentEl);
    }
    let banner = leafContentEl.querySelector(".system3-banner");
    if (!banner) {
      banner = document.createElement("div");
      banner.classList.add("system3-banner");
      const span = banner.createSpan();
      span.setText(this.text);
      banner.appendChild(span);
      bannerBox.appendChild(banner);
      const onClick = async () => {
        const destroy = await this.onClick();
        if (destroy) {
          this.destroy();
        }
      };
      banner.addEventListener("click", onClick);
    }
    return true;
  }
  destroy() {
    const leafContentEl = this.view.containerEl;
    if (!leafContentEl) {
      return;
    }
    const bannerBox = leafContentEl.querySelector(".system3-banner-box");
    if (bannerBox) {
      bannerBox.replaceChildren();
    }
    return true;
  }
};

// src/y-codemirror.next/LiveEditPlugin.ts
var import_state = require("@codemirror/state");
var import_view = require("@codemirror/view");

// node_modules/monkey-around/dist/index.mjs
function around(obj, factories) {
  const removers = Object.keys(factories).map((key) => around1(obj, key, factories[key]));
  return removers.length === 1 ? removers[0] : function() {
    removers.forEach((r) => r());
  };
}
function around1(obj, method, createWrapper) {
  const inherited = obj[method], hadOwn = obj.hasOwnProperty(method), original = hadOwn ? inherited : function() {
    return Object.getPrototypeOf(obj)[method].apply(this, arguments);
  };
  let current = createWrapper(original);
  if (inherited)
    Object.setPrototypeOf(current, inherited);
  Object.setPrototypeOf(wrapper, current);
  obj[method] = wrapper;
  return remove;
  function wrapper(...args3) {
    if (current === original && obj[method] === wrapper)
      remove();
    return current.apply(this, args3);
  }
  function remove() {
    if (obj[method] === wrapper) {
      if (hadOwn)
        obj[method] = original;
      else
        delete obj[method];
    }
    if (current === original)
      return;
    current = original;
    Object.setPrototypeOf(wrapper, inherited || Function);
  }
}

// src/y-codemirror.next/LiveEditPlugin.ts
var import_diff_match_patch = __toESM(require_diff_match_patch());
var TWEENS = 25;
var connectionManagerFacet = import_state.Facet.define({
  combine(inputs) {
    return inputs[inputs.length - 1];
  }
});
var ySyncAnnotation = import_state.Annotation.define();
var LiveCMPluginValue = class {
  constructor(editor) {
    this.initialSet = false;
    this.destroyed = false;
    this.keyFrameCounter = 0;
    this.debug = (...args3) => {
    };
    this.log = (...args3) => {
    };
    this.warn = (...args3) => {
    };
    var _a2, _b2, _c, _d;
    this.editor = editor;
    this.connectionManager = this.editor.state.field(
      ConnectionManagerStateField
    );
    this.view = (_a2 = this.connectionManager) == null ? void 0 : _a2.findView(editor);
    if (!this.view) {
      return;
    }
    this.log = curryLog(
      `[LiveCMPluginValue][${(_b2 = this.view.view.file) == null ? void 0 : _b2.path}]`,
      "log"
    );
    this.warn = curryLog(
      `[LiveCMPluginValue][${(_c = this.view.view.file) == null ? void 0 : _c.path}]`,
      "warn"
    );
    this.debug = curryLog(
      `[LiveCMPluginValue][${(_d = this.view.view.file) == null ? void 0 : _d.path}]`,
      "debug"
    );
    this.debug("created");
    if (!this.view.document) {
      return;
    }
    const liveEditPlugin = this;
    this.uninstallMonkeyPatch = around(this.view.view, {
      setViewData(old) {
        return function(data, clear) {
          if (clear) {
            if (isLive(liveEditPlugin.view)) {
              if (liveEditPlugin.view.document.text === data) {
                liveEditPlugin.view.tracking = true;
              }
            }
            liveEditPlugin.resync();
          }
          return old.call(this, data, clear);
        };
      }
    });
    if (this.view.document.connected) {
      this.resync();
    } else {
      this.view.document.onceConnected().then(() => {
        this.resync();
      });
    }
    this._observer = async (event, tr) => {
      if (!isLive(this.view)) {
        this.debug("Recived yjs event against a non-live view");
        return;
      }
      if (this.destroyed) {
        this.debug("Recived yjs event but editor was destroyed");
        return;
      }
      if (tr.origin !== this) {
        const delta = event.delta;
        let changes = [];
        let pos = 0;
        for (let i2 = 0; i2 < delta.length; i2++) {
          const d = delta[i2];
          if (d.insert != null) {
            changes.push({
              from: pos,
              to: pos,
              insert: d.insert
            });
          } else if (d.delete != null) {
            changes.push({
              from: pos,
              to: pos + d.delete,
              insert: ""
            });
            pos += d.delete;
          } else if (d.retain != null) {
            pos += d.retain;
          }
        }
        if (!this.view.tracking || flags().enableEditorTweens && this.keyFrameCounter > TWEENS) {
          this.keyFrameCounter = 0;
          changes = await this.getKeyFrame(true);
          this.debug(`dispatch (full)`);
        } else {
          this.keyFrameCounter += 1;
          this.debug(`dispatch (incremental + ${this.keyFrameCounter})`);
        }
        if (isLive(this.view)) {
          editor.dispatch({
            changes,
            annotations: [ySyncAnnotation.of(this.editor)]
          });
          this.view.tracking = true;
        }
      }
    };
    this.observer = (event, tr) => {
      var _a3;
      try {
        (_a3 = this._observer) == null ? void 0 : _a3.call(this, event, tr);
      } catch (e2) {
        if (e2 instanceof RangeError) {
          if (isLive(this.view)) {
            this.view.tracking = false;
          }
        }
      }
    };
    this._ytext = this.view.document.ytext;
    this._ytext.observe(this.observer);
  }
  incrementalBufferChange(newBuffer) {
    const currentBuffer = this.editor.state.doc.toString();
    const dmp = new import_diff_match_patch.default();
    const diffs = dmp.diff_main(currentBuffer, newBuffer);
    dmp.diff_cleanupSemantic(diffs);
    const changes = [];
    let currentPos = 0;
    for (const [type, text3] of diffs) {
      switch (type) {
        case 0:
          currentPos += text3.length;
          break;
        case 1:
          changes.push({
            from: currentPos,
            to: currentPos,
            insert: text3
          });
          currentPos += text3.length;
          break;
        case -1:
          changes.push({
            from: currentPos,
            to: currentPos + text3.length,
            insert: ""
          });
          break;
      }
    }
    return changes;
  }
  getBufferChange(newBuffer, incremental = false) {
    if (incremental) {
      return this.incrementalBufferChange(newBuffer);
    }
    return [
      {
        from: 0,
        to: this.editor.state.doc.length,
        insert: newBuffer
      }
    ];
  }
  async resync() {
    if (isLive(this.view) && !this.view.tracking && !this.destroyed) {
      await this.view.document.whenSynced();
      const keyFrame = await this.getKeyFrame();
      if (isLive(this.view) && !this.view.tracking && !this.destroyed) {
        this.editor.dispatch({
          changes: keyFrame,
          annotations: [ySyncAnnotation.of(this.editor)]
        });
      }
    }
  }
  async getKeyFrame(incremental = false) {
    if (!isLive(this.view) || this.destroyed) {
      return [];
    }
    if (this.view.document.text === this.view.view.getViewData()) {
      this.view.tracking = true;
      return [];
    } else {
      this.warn(
        `|${this.view.document.text}|
|${this.view.view.getViewData()}|`
      );
    }
    this.warn(`ytext and editor buffer need syncing`);
    if (!this.view.document.hasLocalDB() && this.view.document.text === "") {
      this.warn("local db missing, not setting buffer");
      return [];
    }
    if (!this.view.tracking) {
      this.view.checkStale();
    }
    if (isLive(this.view) && !this.destroyed) {
      return [this.getBufferChange(this.view.document.text, incremental)];
    }
    return [];
  }
  update(update2) {
    var _a2, _b2, _c, _d;
    if (!update2.docChanged || update2.transactions.length > 0 && update2.transactions[0].annotation(ySyncAnnotation) === this.editor) {
      return;
    }
    const editor = update2.view;
    this.view = (_a2 = this.connectionManager) == null ? void 0 : _a2.findView(editor);
    const ytext = (_c = (_b2 = this.view) == null ? void 0 : _b2.document) == null ? void 0 : _c.ytext;
    if (!ytext) {
      return;
    }
    (_d = ytext.doc) == null ? void 0 : _d.transact(() => {
      let adj = 0;
      update2.changes.iterChanges((fromA, toA, fromB, toB, insert2) => {
        const insertText2 = insert2.sliceString(0, insert2.length, "\n");
        if (fromA !== toA) {
          ytext.delete(fromA + adj, toA - fromA);
        }
        if (insertText2.length > 0) {
          ytext.insert(fromA + adj, insertText2);
        }
        adj += insertText2.length - (toA - fromA);
      });
    }, this);
  }
  destroy() {
    var _a2;
    this.destroyed = true;
    if (this.observer) {
      (_a2 = this._ytext) == null ? void 0 : _a2.unobserve(this.observer);
    }
    if (this.uninstallMonkeyPatch) {
      this.uninstallMonkeyPatch();
      this.uninstallMonkeyPatch = void 0;
    }
    this.connectionManager = null;
    this.view = void 0;
    this._ytext = void 0;
    this.editor = null;
  }
};
var LiveEdit = import_view.ViewPlugin.fromClass(LiveCMPluginValue);

// src/y-codemirror.next/RemoteSelections.ts
var import_state2 = require("@codemirror/state");
var import_view2 = require("@codemirror/view");
var yRemoteSelectionsTheme = import_view2.EditorView.baseTheme({
  ".cm-ySelection": {},
  ".cm-yLineSelection": {
    padding: 0,
    margin: "0px 2px 0px 4px"
  },
  ".cm-ySelectionCaret": {
    position: "relative",
    borderLeft: "1px solid black",
    borderRight: "1px solid black",
    marginLeft: "-1px",
    marginRight: "-1px",
    boxSizing: "border-box",
    display: "inline"
  },
  ".cm-ySelectionCaretDot": {
    borderRadius: "50%",
    position: "absolute",
    width: ".4em",
    height: ".4em",
    top: "-.2em",
    left: "-.2em",
    backgroundColor: "inherit",
    transition: "transform .3s ease-in-out",
    boxSizing: "border-box"
  },
  ".cm-ySelectionCaret:hover > .cm-ySelectionCaretDot": {
    transformOrigin: "bottom center",
    transform: "scale(0)"
  },
  ".cm-ySelectionInfo": {
    position: "absolute",
    top: "-1.05em",
    left: "-1px",
    fontSize: ".75em",
    fontFamily: "serif",
    fontStyle: "normal",
    fontWeight: "normal",
    lineHeight: "normal",
    userSelect: "none",
    color: "white",
    paddingLeft: "2px",
    paddingRight: "2px",
    zIndex: 101,
    transition: "opacity .3s ease-in-out",
    backgroundColor: "inherit",
    // these should be separate
    opacity: 0,
    transitionDelay: "0s",
    whiteSpace: "nowrap"
  },
  ".cm-ySelectionCaret:hover > .cm-ySelectionInfo": {
    opacity: 1,
    transitionDelay: "0s"
  }
});
var yRemoteSelectionsAnnotation = import_state2.Annotation.define();
var YRemoteCaretWidget = class extends import_view2.WidgetType {
  constructor(color, name) {
    super();
    this.color = color;
    this.name = name;
  }
  toDOM(editor) {
    return element(
      "span",
      [
        create5("class", "cm-ySelectionCaret"),
        create5(
          "style",
          `background-color: ${this.color}; border-color: ${this.color}`
        )
      ],
      [
        text("\u2060"),
        element("div", [create5("class", "cm-ySelectionCaretDot")]),
        text("\u2060"),
        element(
          "div",
          [create5("class", "cm-ySelectionInfo")],
          [text(this.name)]
        ),
        text("\u2060")
      ]
    );
  }
  eq(widget) {
    return widget.color === this.color;
  }
  compare(widget) {
    return widget.color === this.color;
  }
  updateDOM() {
    return false;
  }
  get estimatedHeight() {
    return -1;
  }
  ignoreEvent() {
    return true;
  }
};
var YRemoteSelectionsPluginValue = class {
  constructor(editor) {
    var _a2, _b2;
    this.editor = editor;
    this.decorations = import_state2.RangeSet.of([]);
    this.connectionManager = this.editor.state.field(
      ConnectionManagerStateField
    );
    const view = (_a2 = this.connectionManager) == null ? void 0 : _a2.findView(editor);
    if (view && view instanceof LiveView) {
      this.view = view;
      const provider = (_b2 = this.view.document) == null ? void 0 : _b2._provider;
      this._listener = ({ added, updated, removed }, s2, t2) => {
        const clients = added.concat(updated).concat(removed);
        if (clients.findIndex((id2) => {
          var _a3;
          return id2 !== ((_a3 = this._awareness) == null ? void 0 : _a3.doc.clientID);
        }) >= 0) {
          editor.dispatch({
            annotations: [yRemoteSelectionsAnnotation.of([])]
          });
        }
      };
      if (provider) {
        this._awareness = provider.awareness;
        this._awareness.on("change", this._listener);
      }
    }
  }
  destroy() {
    var _a2;
    if (this._listener) {
      (_a2 = this._awareness) == null ? void 0 : _a2.off("change", this._listener);
      this._listener = void 0;
    }
    this.connectionManager = null;
    this.view = null;
    this.editor = null;
  }
  update(update2) {
    var _a2, _b2, _c, _d;
    const editor = update2.view;
    this.view = (_a2 = this.connectionManager) == null ? void 0 : _a2.findView(editor);
    const ytext = (_c = (_b2 = this.view) == null ? void 0 : _b2.document) == null ? void 0 : _c.ytext;
    if (!(this.view && ytext && ytext.doc)) {
      return;
    }
    const provider = (_d = this.view.document) == null ? void 0 : _d._provider;
    if (!provider) {
      return;
    }
    this._awareness = provider.awareness;
    const awareness = this._awareness;
    const ydoc = ytext.doc;
    const decorations = [];
    const localAwarenessState = this._awareness.getLocalState();
    if (localAwarenessState != null) {
      const hasFocus = update2.view.hasFocus && update2.view.dom.ownerDocument.hasFocus();
      const sel = hasFocus ? update2.state.selection.main : null;
      const currentAnchor = localAwarenessState.cursor == null ? null : createRelativePositionFromJSON(
        localAwarenessState.cursor.anchor
        // eslint-disable-next-line no-mixed-spaces-and-tabs
      );
      const currentHead = localAwarenessState.cursor == null ? null : createRelativePositionFromJSON(
        localAwarenessState.cursor.head
        // eslint-disable-next-line no-mixed-spaces-and-tabs
      );
      if (sel != null) {
        const anchor = createRelativePositionFromTypeIndex(ytext, sel.anchor);
        const head = createRelativePositionFromTypeIndex(ytext, sel.head);
        if (localAwarenessState.cursor == null || !compareRelativePositions(currentAnchor, anchor) || !compareRelativePositions(currentHead, head)) {
          awareness.setLocalStateField("cursor", {
            anchor,
            head
          });
        }
      } else if (localAwarenessState.cursor != null && hasFocus) {
        awareness.setLocalStateField("cursor", null);
      }
    }
    awareness.getStates().forEach((state, clientid) => {
      if (clientid === awareness.doc.clientID) {
        return;
      }
      const cursor = state.cursor;
      if (cursor == null || cursor.anchor == null || cursor.head == null) {
        return;
      }
      const anchor = createAbsolutePositionFromRelativePosition(
        cursor.anchor,
        ydoc
      );
      const head = createAbsolutePositionFromRelativePosition(
        cursor.head,
        ydoc
      );
      if (anchor == null || head == null || anchor.type !== ytext || head.type !== ytext) {
        return;
      }
      if (anchor.index > update2.state.doc.length || head.index > update2.state.doc.length) {
        curryLog(
          "[RemoteSelections]",
          "warn"
        )(
          `cursor positions (${anchor.index}, ${head.index}) out of range of document length: ${update2.state.doc.length}`
        );
        this.decorations = import_view2.Decoration.none;
        return;
      }
      const { color = "#30bced", name = "Anonymous" } = state.user || {};
      const colorLight = state.user && state.user.colorLight || color + "33";
      const start = min(anchor.index, head.index);
      const end = max(anchor.index, head.index);
      const startLine = update2.view.state.doc.lineAt(start);
      const endLine = update2.view.state.doc.lineAt(end);
      if (startLine.number === endLine.number) {
        decorations.push({
          from: start,
          to: end,
          value: import_view2.Decoration.mark({
            attributes: {
              style: `background-color: ${colorLight}`
            },
            class: "cm-ySelection"
          })
        });
      } else {
        decorations.push({
          from: start,
          to: startLine.from + startLine.length,
          value: import_view2.Decoration.mark({
            attributes: {
              style: `background-color: ${colorLight}`
            },
            class: "cm-ySelection"
          })
        });
        decorations.push({
          from: endLine.from,
          to: end,
          value: import_view2.Decoration.mark({
            attributes: {
              style: `background-color: ${colorLight}`
            },
            class: "cm-ySelection"
          })
        });
        for (let i2 = startLine.number + 1; i2 < endLine.number; i2++) {
          const linePos = update2.view.state.doc.line(i2).from;
          decorations.push({
            from: linePos,
            to: linePos,
            value: import_view2.Decoration.line({
              attributes: {
                style: `background-color: ${colorLight}`,
                class: "cm-yLineSelection"
              }
            })
          });
        }
      }
      decorations.push({
        from: head.index,
        to: head.index,
        value: import_view2.Decoration.widget({
          side: head.index - anchor.index > 0 ? -1 : 1,
          // the local cursor should be rendered outside the remote selection
          block: false,
          widget: new YRemoteCaretWidget(color, name)
        })
      });
    });
    this.decorations = import_view2.Decoration.set(decorations, true);
  }
};
var yRemoteSelections = import_view2.ViewPlugin.fromClass(
  YRemoteSelectionsPluginValue,
  {
    decorations: (v) => v.decorations
  }
);

// src/markdownView/InvalidLinkExtension.ts
var import_state3 = require("@codemirror/state");
var import_view3 = require("@codemirror/view");
var import_view4 = require("@codemirror/view");
var invalidLinkSyncAnnotation = import_state3.Annotation.define();
var FileWarningWidget = class extends import_view4.WidgetType {
  toDOM() {
    const span = document.createElement("span");
    span.style.display = "inline-flex";
    span.addClass("invalid-link");
    span.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-file-warning"><path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"/><path d="M12 9v4"/><path d="M12 17h.01"/></svg>';
    span.title = "This link points outside the shared folder and may not be accessible to other users.";
    return span;
  }
};
var metadataChangeEffect = import_state3.StateEffect.define();
var InvalidLinkPluginValue = class {
  constructor(editor) {
    this.log = (message) => {
    };
    var _a2;
    this.editor = editor;
    this.connectionManager = this.editor.state.field(
      ConnectionManagerStateField
    );
    this.decorations = import_view3.Decoration.none;
    this.decorationAnchors = [];
    this.metadata = /* @__PURE__ */ new Map();
    this.cb = (data, cache) => {
      this.updateFromMetadata(cache);
      this.editor.dispatch({
        effects: metadataChangeEffect.of(null)
      });
    };
    if (!this.connectionManager) {
      curryLog(
        "[InvalidLinkPluginValue]",
        "warn"
      )("ConnectionManager not found in InvalidLinkPlugin");
      return;
    }
    this.app = this.connectionManager.app;
    this.view = this.connectionManager.findView(editor);
    if (!this.view) {
      return;
    }
    this.log = curryLog(
      `[InvalidLinkPluginValue][${(_a2 = this.view.view.file) == null ? void 0 : _a2.path}]`,
      "debug"
    );
    this.log("created");
    if (this.view.document) {
      this.view.document.whenSynced().then(() => {
        var _a3, _b2;
        if (this.connectionManager && this.app && ((_b2 = (_a3 = this.view) == null ? void 0 : _a3.document) == null ? void 0 : _b2.tfile)) {
          this.connectionManager.onMeta(this.view.document.tfile, this.cb);
          const fileCache = this.app.metadataCache.getFileCache(
            this.view.document.tfile
          );
          if (fileCache) {
            this.updateFromMetadata(fileCache);
            this.editor.dispatch({
              effects: metadataChangeEffect.of(null)
            });
          }
        } else {
          this.log("unable to subscribe to metadata updates");
        }
      });
    }
  }
  findInternalLinks(view) {
    const links = [];
    const decorationSets = view.state.facet(import_view3.EditorView.decorations);
    decorationSets.forEach(
      (decoSetOrFunc) => {
        const decoSet = typeof decoSetOrFunc === "function" ? decoSetOrFunc(view) : decoSetOrFunc;
        decoSet.between(
          0,
          view.state.doc.length,
          (from3, to, deco) => {
            var _a2;
            const classes = ((_a2 = deco.spec) == null ? void 0 : _a2.class) || "";
            const linkEnd = classes.contains("cm-formatting-link-end");
            if (linkEnd) {
              links.push({
                from: from3,
                to
              });
            }
          }
        );
      }
    );
    return links;
  }
  updateFromMetadata(cache) {
    var _a2, _b2, _c, _d;
    if (this.connectionManager) {
      this.view = this.connectionManager.findView(this.editor);
    }
    if (!this.view || !this.view.document || !this.app)
      return;
    if (!((_b2 = (_a2 = this.view) == null ? void 0 : _a2.document) == null ? void 0 : _b2.sharedFolder)) {
      return;
    }
    if (!((_d = (_c = this.view) == null ? void 0 : _c.document) == null ? void 0 : _d.tfile)) {
      return;
    }
    const cacheLinks = /* @__PURE__ */ new Map();
    for (const link of (cache == null ? void 0 : cache.links) || []) {
      const linkedFile = this.app.metadataCache.getFirstLinkpathDest(
        link.link,
        this.view.document.path
      );
      if (linkedFile && !this.view.document.sharedFolder.checkPath(linkedFile.path)) {
        cacheLinks.set(link.position.start.offset, {
          from: link.position.start.offset,
          to: link.position.end.offset,
          link: link.link,
          original: link.original
        });
      }
    }
    for (const embed of (cache == null ? void 0 : cache.embeds) || []) {
      const linkedFile = this.app.metadataCache.getFirstLinkpathDest(
        embed.link,
        this.view.document.path
      );
      if (linkedFile && !this.view.document.sharedFolder.checkPath(linkedFile.path)) {
        cacheLinks.set(embed.position.start.offset, {
          from: embed.position.start.offset,
          to: embed.position.end.offset,
          link: embed.link,
          original: embed.original
        });
      }
    }
    this.metadata = cacheLinks;
  }
  updateMetadataPositions(update2) {
    for (const [cacheFrom, cacheLink] of this.metadata) {
      try {
        this.metadata.set(cacheFrom, {
          from: update2.changes.mapPos(cacheLink.from),
          to: update2.changes.mapPos(cacheLink.to),
          link: cacheLink.link,
          original: cacheLink.original
        });
      } catch (e2) {
        this.metadata.delete(cacheFrom);
      }
    }
  }
  updateFromEditor(update2) {
    var _a2, _b2, _c, _d;
    if (this.connectionManager) {
      this.view = this.connectionManager.findView(this.editor);
    }
    if (!this.view || !this.view.document || !this.app)
      return;
    if (!((_b2 = (_a2 = this.view) == null ? void 0 : _a2.document) == null ? void 0 : _b2.sharedFolder)) {
      return;
    }
    if (!((_d = (_c = this.view) == null ? void 0 : _c.document) == null ? void 0 : _d.tfile)) {
      return;
    }
    const invalidAnchors = [];
    const cacheLinks = new Map(this.metadata);
    const editorLinks = this.findInternalLinks(this.editor);
    for (const link of editorLinks) {
      let _cacheLink = null;
      for (const [cacheFrom, cacheLink] of cacheLinks) {
        if (link.from <= cacheLink.to && link.to >= cacheLink.from) {
          _cacheLink = cacheLink;
          cacheLinks.delete(cacheFrom);
          break;
        }
      }
      if (!_cacheLink) {
        continue;
      }
      const linkedFile = this.app.metadataCache.getFirstLinkpathDest(
        _cacheLink.link,
        this.view.document.path
      );
      const isInvalid = linkedFile && !this.view.document.sharedFolder.checkPath(linkedFile.path);
      if (isInvalid) {
        invalidAnchors.push(link.from);
      }
    }
    invalidAnchors.filter((a) => a <= update2.state.doc.length);
    this.decorationAnchors = invalidAnchors;
  }
  updateDecorations() {
    this.decorationAnchors.sort();
    const decorations = this.decorationAnchors.map(
      (anchor) => import_view3.Decoration.widget({
        widget: new FileWarningWidget(),
        side: 1
      }).range(anchor)
    );
    if (decorations.length > 0) {
      this.decorations = import_view3.Decoration.set(decorations, true);
    } else {
      this.decorations = import_view3.Decoration.none;
    }
  }
  update(update2) {
    let metadataUpdate = false;
    update2.transactions.forEach((tr) => {
      if (tr.effects.some((e2) => e2.is(metadataChangeEffect))) {
        metadataUpdate = true;
      }
    });
    if (update2.docChanged || update2.viewportChanged || metadataUpdate) {
      if (!metadataUpdate) {
        this.updateMetadataPositions(update2);
      }
      this.updateFromEditor(update2);
      this.updateDecorations();
    }
    return this.decorations;
  }
  destroy() {
    var _a2, _b2;
    if (this.connectionManager && ((_b2 = (_a2 = this.view) == null ? void 0 : _a2.document) == null ? void 0 : _b2.tfile)) {
      this.connectionManager.offMeta(this.view.document.tfile);
    }
    this.connectionManager = null;
    this.view = void 0;
    this.metadata.clear();
    this.metadata = null;
    this.editor = null;
  }
};
var InvalidLinkPlugin = import_view3.ViewPlugin.fromClass(InvalidLinkPluginValue, {
  decorations: (v) => v.decorations
});

// node_modules/diff/lib/index.mjs
function Diff() {
}
Diff.prototype = {
  diff: function diff(oldString, newString) {
    var _options$timeout;
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var callback = options.callback;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    this.options = options;
    var self = this;
    function done(value) {
      if (callback) {
        setTimeout(function() {
          callback(void 0, value);
        }, 0);
        return true;
      } else {
        return value;
      }
    }
    oldString = this.castInput(oldString);
    newString = this.castInput(newString);
    oldString = this.removeEmpty(this.tokenize(oldString));
    newString = this.removeEmpty(this.tokenize(newString));
    var newLen = newString.length, oldLen = oldString.length;
    var editLength = 1;
    var maxEditLength = newLen + oldLen;
    if (options.maxEditLength) {
      maxEditLength = Math.min(maxEditLength, options.maxEditLength);
    }
    var maxExecutionTime = (_options$timeout = options.timeout) !== null && _options$timeout !== void 0 ? _options$timeout : Infinity;
    var abortAfterTimestamp = Date.now() + maxExecutionTime;
    var bestPath = [{
      oldPos: -1,
      lastComponent: void 0
    }];
    var newPos = this.extractCommon(bestPath[0], newString, oldString, 0);
    if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
      return done([{
        value: this.join(newString),
        count: newString.length
      }]);
    }
    var minDiagonalToConsider = -Infinity, maxDiagonalToConsider = Infinity;
    function execEditLength() {
      for (var diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2) {
        var basePath = void 0;
        var removePath = bestPath[diagonalPath - 1], addPath = bestPath[diagonalPath + 1];
        if (removePath) {
          bestPath[diagonalPath - 1] = void 0;
        }
        var canAdd = false;
        if (addPath) {
          var addPathNewPos = addPath.oldPos - diagonalPath;
          canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;
        }
        var canRemove = removePath && removePath.oldPos + 1 < oldLen;
        if (!canAdd && !canRemove) {
          bestPath[diagonalPath] = void 0;
          continue;
        }
        if (!canRemove || canAdd && removePath.oldPos + 1 < addPath.oldPos) {
          basePath = self.addToPath(addPath, true, void 0, 0);
        } else {
          basePath = self.addToPath(removePath, void 0, true, 1);
        }
        newPos = self.extractCommon(basePath, newString, oldString, diagonalPath);
        if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
          return done(buildValues(self, basePath.lastComponent, newString, oldString, self.useLongestToken));
        } else {
          bestPath[diagonalPath] = basePath;
          if (basePath.oldPos + 1 >= oldLen) {
            maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);
          }
          if (newPos + 1 >= newLen) {
            minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);
          }
        }
      }
      editLength++;
    }
    if (callback) {
      (function exec() {
        setTimeout(function() {
          if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {
            return callback();
          }
          if (!execEditLength()) {
            exec();
          }
        }, 0);
      })();
    } else {
      while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {
        var ret = execEditLength();
        if (ret) {
          return ret;
        }
      }
    }
  },
  addToPath: function addToPath(path, added, removed, oldPosInc) {
    var last2 = path.lastComponent;
    if (last2 && last2.added === added && last2.removed === removed) {
      return {
        oldPos: path.oldPos + oldPosInc,
        lastComponent: {
          count: last2.count + 1,
          added,
          removed,
          previousComponent: last2.previousComponent
        }
      };
    } else {
      return {
        oldPos: path.oldPos + oldPosInc,
        lastComponent: {
          count: 1,
          added,
          removed,
          previousComponent: last2
        }
      };
    }
  },
  extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
    var newLen = newString.length, oldLen = oldString.length, oldPos = basePath.oldPos, newPos = oldPos - diagonalPath, commonCount = 0;
    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
      newPos++;
      oldPos++;
      commonCount++;
    }
    if (commonCount) {
      basePath.lastComponent = {
        count: commonCount,
        previousComponent: basePath.lastComponent
      };
    }
    basePath.oldPos = oldPos;
    return newPos;
  },
  equals: function equals(left, right) {
    if (this.options.comparator) {
      return this.options.comparator(left, right);
    } else {
      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
    }
  },
  removeEmpty: function removeEmpty(array) {
    var ret = [];
    for (var i2 = 0; i2 < array.length; i2++) {
      if (array[i2]) {
        ret.push(array[i2]);
      }
    }
    return ret;
  },
  castInput: function castInput(value) {
    return value;
  },
  tokenize: function tokenize(value) {
    return value.split("");
  },
  join: function join2(chars) {
    return chars.join("");
  }
};
function buildValues(diff2, lastComponent, newString, oldString, useLongestToken) {
  var components = [];
  var nextComponent;
  while (lastComponent) {
    components.push(lastComponent);
    nextComponent = lastComponent.previousComponent;
    delete lastComponent.previousComponent;
    lastComponent = nextComponent;
  }
  components.reverse();
  var componentPos = 0, componentLen = components.length, newPos = 0, oldPos = 0;
  for (; componentPos < componentLen; componentPos++) {
    var component = components[componentPos];
    if (!component.removed) {
      if (!component.added && useLongestToken) {
        var value = newString.slice(newPos, newPos + component.count);
        value = value.map(function(value2, i2) {
          var oldValue = oldString[oldPos + i2];
          return oldValue.length > value2.length ? oldValue : value2;
        });
        component.value = diff2.join(value);
      } else {
        component.value = diff2.join(newString.slice(newPos, newPos + component.count));
      }
      newPos += component.count;
      if (!component.added) {
        oldPos += component.count;
      }
    } else {
      component.value = diff2.join(oldString.slice(oldPos, oldPos + component.count));
      oldPos += component.count;
      if (componentPos && components[componentPos - 1].added) {
        var tmp = components[componentPos - 1];
        components[componentPos - 1] = components[componentPos];
        components[componentPos] = tmp;
      }
    }
  }
  var finalComponent = components[componentLen - 1];
  if (componentLen > 1 && typeof finalComponent.value === "string" && (finalComponent.added || finalComponent.removed) && diff2.equals("", finalComponent.value)) {
    components[componentLen - 2].value += finalComponent.value;
    components.pop();
  }
  return components;
}
var characterDiff = new Diff();
function generateOptions(options, defaults) {
  if (typeof options === "function") {
    defaults.callback = options;
  } else if (options) {
    for (var name in options) {
      if (options.hasOwnProperty(name)) {
        defaults[name] = options[name];
      }
    }
  }
  return defaults;
}
var extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;
var reWhitespace = /\S/;
var wordDiff = new Diff();
wordDiff.equals = function(left, right) {
  if (this.options.ignoreCase) {
    left = left.toLowerCase();
    right = right.toLowerCase();
  }
  return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
};
wordDiff.tokenize = function(value) {
  var tokens = value.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/);
  for (var i2 = 0; i2 < tokens.length - 1; i2++) {
    if (!tokens[i2 + 1] && tokens[i2 + 2] && extendedWordChars.test(tokens[i2]) && extendedWordChars.test(tokens[i2 + 2])) {
      tokens[i2] += tokens[i2 + 2];
      tokens.splice(i2 + 1, 2);
      i2--;
    }
  }
  return tokens;
};
function diffWords(oldStr, newStr, options) {
  options = generateOptions(options, {
    ignoreWhitespace: true
  });
  return wordDiff.diff(oldStr, newStr, options);
}
var lineDiff = new Diff();
lineDiff.tokenize = function(value) {
  if (this.options.stripTrailingCr) {
    value = value.replace(/\r\n/g, "\n");
  }
  var retLines = [], linesAndNewlines = value.split(/(\n|\r\n)/);
  if (!linesAndNewlines[linesAndNewlines.length - 1]) {
    linesAndNewlines.pop();
  }
  for (var i2 = 0; i2 < linesAndNewlines.length; i2++) {
    var line = linesAndNewlines[i2];
    if (i2 % 2 && !this.options.newlineIsToken) {
      retLines[retLines.length - 1] += line;
    } else {
      if (this.options.ignoreWhitespace) {
        line = line.trim();
      }
      retLines.push(line);
    }
  }
  return retLines;
};
function diffLines(oldStr, newStr, callback) {
  return lineDiff.diff(oldStr, newStr, callback);
}
var sentenceDiff = new Diff();
sentenceDiff.tokenize = function(value) {
  return value.split(/(\S.+?[.!?])(?=\s+|$)/);
};
var cssDiff = new Diff();
cssDiff.tokenize = function(value) {
  return value.split(/([{}:;,]|\s+)/);
};
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
    return Array.from(iter);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
    arr2[i2] = arr[i2];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var objectPrototypeToString = Object.prototype.toString;
var jsonDiff = new Diff();
jsonDiff.useLongestToken = true;
jsonDiff.tokenize = lineDiff.tokenize;
jsonDiff.castInput = function(value) {
  var _this$options = this.options, undefinedReplacement = _this$options.undefinedReplacement, _this$options$stringi = _this$options.stringifyReplacer, stringifyReplacer = _this$options$stringi === void 0 ? function(k, v) {
    return typeof v === "undefined" ? undefinedReplacement : v;
  } : _this$options$stringi;
  return typeof value === "string" ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, "  ");
};
jsonDiff.equals = function(left, right) {
  return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, "$1"), right.replace(/,([\r\n])/g, "$1"));
};
function canonicalize(obj, stack, replacementStack, replacer, key) {
  stack = stack || [];
  replacementStack = replacementStack || [];
  if (replacer) {
    obj = replacer(key, obj);
  }
  var i2;
  for (i2 = 0; i2 < stack.length; i2 += 1) {
    if (stack[i2] === obj) {
      return replacementStack[i2];
    }
  }
  var canonicalizedObj;
  if ("[object Array]" === objectPrototypeToString.call(obj)) {
    stack.push(obj);
    canonicalizedObj = new Array(obj.length);
    replacementStack.push(canonicalizedObj);
    for (i2 = 0; i2 < obj.length; i2 += 1) {
      canonicalizedObj[i2] = canonicalize(obj[i2], stack, replacementStack, replacer, key);
    }
    stack.pop();
    replacementStack.pop();
    return canonicalizedObj;
  }
  if (obj && obj.toJSON) {
    obj = obj.toJSON();
  }
  if (_typeof(obj) === "object" && obj !== null) {
    stack.push(obj);
    canonicalizedObj = {};
    replacementStack.push(canonicalizedObj);
    var sortedKeys = [], _key;
    for (_key in obj) {
      if (obj.hasOwnProperty(_key)) {
        sortedKeys.push(_key);
      }
    }
    sortedKeys.sort();
    for (i2 = 0; i2 < sortedKeys.length; i2 += 1) {
      _key = sortedKeys[i2];
      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
    }
    stack.pop();
    replacementStack.pop();
  } else {
    canonicalizedObj = obj;
  }
  return canonicalizedObj;
}
var arrayDiff = new Diff();
arrayDiff.tokenize = function(value) {
  return value.slice();
};
arrayDiff.join = arrayDiff.removeEmpty = function(value) {
  return value;
};
function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
  if (!options) {
    options = {};
  }
  if (typeof options.context === "undefined") {
    options.context = 4;
  }
  var diff2 = diffLines(oldStr, newStr, options);
  if (!diff2) {
    return;
  }
  diff2.push({
    value: "",
    lines: []
  });
  function contextLines(lines) {
    return lines.map(function(entry) {
      return " " + entry;
    });
  }
  var hunks = [];
  var oldRangeStart = 0, newRangeStart = 0, curRange = [], oldLine = 1, newLine = 1;
  var _loop = function _loop2(i3) {
    var current = diff2[i3], lines = current.lines || current.value.replace(/\n$/, "").split("\n");
    current.lines = lines;
    if (current.added || current.removed) {
      var _curRange;
      if (!oldRangeStart) {
        var prev = diff2[i3 - 1];
        oldRangeStart = oldLine;
        newRangeStart = newLine;
        if (prev) {
          curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];
          oldRangeStart -= curRange.length;
          newRangeStart -= curRange.length;
        }
      }
      (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function(entry) {
        return (current.added ? "+" : "-") + entry;
      })));
      if (current.added) {
        newLine += lines.length;
      } else {
        oldLine += lines.length;
      }
    } else {
      if (oldRangeStart) {
        if (lines.length <= options.context * 2 && i3 < diff2.length - 2) {
          var _curRange2;
          (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));
        } else {
          var _curRange3;
          var contextSize = Math.min(lines.length, options.context);
          (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));
          var hunk = {
            oldStart: oldRangeStart,
            oldLines: oldLine - oldRangeStart + contextSize,
            newStart: newRangeStart,
            newLines: newLine - newRangeStart + contextSize,
            lines: curRange
          };
          if (i3 >= diff2.length - 2 && lines.length <= options.context) {
            var oldEOFNewline = /\n$/.test(oldStr);
            var newEOFNewline = /\n$/.test(newStr);
            var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;
            if (!oldEOFNewline && noNlBeforeAdds && oldStr.length > 0) {
              curRange.splice(hunk.oldLines, 0, "\\ No newline at end of file");
            }
            if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {
              curRange.push("\\ No newline at end of file");
            }
          }
          hunks.push(hunk);
          oldRangeStart = 0;
          newRangeStart = 0;
          curRange = [];
        }
      }
      oldLine += lines.length;
      newLine += lines.length;
    }
  };
  for (var i2 = 0; i2 < diff2.length; i2++) {
    _loop(i2);
  }
  return {
    oldFileName,
    newFileName,
    oldHeader,
    newHeader,
    hunks
  };
}

// src/differ/differencesView.ts
var import_obsidian3 = require("obsidian");

// src/differ/difference.ts
var Difference = class {
  constructor(args3) {
    this.file1Start = args3.file1Start;
    this.file2Start = args3.file2Start;
    this.file1Lines = args3.file1Lines;
    this.file2Lines = args3.file2Lines;
  }
};

// src/differ/fileDifferences.ts
var FileDifferences = class {
  constructor(args3) {
    this.file1Name = args3.file1Name;
    this.file2Name = args3.file2Name;
    this.differences = args3.differences;
  }
  /**
   * Returns a FileDifferences object from the given ParsedDiff instance.
   *
   * Why create a new data structure if parsedDiff already exists?
   *
   * The FileDifferences class was created because there was a limitation in
   * the existing ParsedDiff class from the diff library for my use case. The
   * hunk object in the ParsedDiff class can contain multiple separated line
   * differences, which is problematic because I wanted to display a separate
   * action line for each contiguous change and thus allow for more precise
   * selection of changes. Additionally, the user needs to be able to apply
   * the changes one by one and so I have to keep a state where only one
   * contiguous change but is applied. To solve this, I considered two
   * options: removing the contiguous change directly in the hunk object or
   * introducing a new data structure with a finer granularity. I ultimately
   * chose the latter option as it seemed simpler.
   */
  static fromParsedDiff(parsedDiff) {
    const differences = [];
    parsedDiff.hunks.forEach((hunk) => {
      let line1Count = 0;
      let line2Count = 0;
      for (let i2 = 0; i2 < hunk.lines.length; i2 += 1) {
        const line = hunk.lines[i2];
        if (line.startsWith("+") || line.startsWith("-")) {
          const start = i2;
          let end = start;
          while (end < hunk.lines.length - 1 && (hunk.lines[end + 1].startsWith("+") || hunk.lines[end + 1].startsWith("-"))) {
            end += 1;
          }
          const file1Lines = hunk.lines.slice(start, end + 1).filter((l) => l.startsWith("-")).map((l) => l.slice(1));
          const file2Lines = hunk.lines.slice(start, end + 1).filter((l) => l.startsWith("+")).map((l) => l.slice(1));
          differences.push(
            new Difference({
              file1Start: hunk.oldStart + start - line2Count - 1,
              file2Start: hunk.newStart + start - line1Count - 1,
              file1Lines,
              file2Lines
            })
          );
          line1Count += file1Lines.length;
          line2Count += file2Lines.length;
          i2 += end - start;
        }
      }
    });
    return new this({
      file1Name: parsedDiff.oldFileName,
      file2Name: parsedDiff.newFileName,
      differences
    });
  }
};

// src/differ/stringUtils.ts
function insertLine(args3) {
  const lines = args3.fullText.split("\n");
  lines.splice(args3.position, 0, args3.newLine);
  return lines.join("\n");
}
function replaceLine(args3) {
  const lines = args3.fullText.split("\n");
  if (args3.newLine === "") {
    lines.splice(args3.position, args3.linesToReplace);
  } else {
    lines.splice(args3.position, args3.linesToReplace, args3.newLine);
  }
  return lines.join("\n");
}
function deleteLines(args3) {
  const lines = args3.fullText.split("\n");
  lines.splice(args3.position, args3.count);
  return lines.join("\n");
}
function preventEmptyString(text3) {
  return text3 !== "" ? text3 : "\u200E";
}

// src/differ/actionLineButton.ts
var ActionLineButton = class {
  constructor(args3) {
    this.text = args3.text;
    this.onClick = args3.onClick;
  }
  build(actionLine) {
    actionLine.createEl("a", {
      text: this.text,
      cls: "no-decoration text-xxs file-diff__action-line"
    }).onClickEvent(this.onClick);
  }
};

// src/differ/actionLineDivider.ts
var ActionLineDivider = class {
  static build(actionLine) {
    actionLine.createEl("span", {
      text: "|",
      cls: "text-xxs file-diff__action-line"
    });
  }
};

// src/BackgroundSync.ts
var import_obsidian2 = require("obsidian");
var import_diff_match_patch2 = __toESM(require_diff_match_patch());

// src/observable/ObservableMap.ts
var ObservableMap = class extends Observable3 {
  constructor(observableName) {
    super();
    this.observableName = observableName;
    this._map = /* @__PURE__ */ new Map();
    this._derivedMaps = /* @__PURE__ */ new WeakMap();
  }
  set(key, value) {
    this._map.set(key, value);
    this.notifyListeners();
    return this;
  }
  delete(key) {
    const result = this._map.delete(key);
    if (result) {
      this.notifyListeners();
    }
    return result;
  }
  clear() {
    this._map.clear();
    this.notifyListeners();
  }
  has(key) {
    return this._map.has(key);
  }
  get(key) {
    return this._map.get(key);
  }
  keys() {
    return [...this._map.keys()];
  }
  values() {
    return [...this._map.values()];
  }
  entries() {
    return [...this._map.entries()];
  }
  get size() {
    return this._map.size;
  }
  forEach(callbackfn) {
    this._map.forEach(callbackfn);
  }
  find(predicate) {
    for (const [key, value] of this._map) {
      if (predicate(value, key)) {
        return value;
      }
    }
    return void 0;
  }
  some(predicate) {
    for (const [key, value] of this._map) {
      if (predicate(value, key)) {
        return true;
      }
    }
    return false;
  }
  filter(predicate) {
    const existing = this._derivedMaps.get(predicate);
    if (existing) {
      return existing;
    }
    const derivedMap = new DerivedMap(this, predicate);
    this._derivedMaps.set(predicate, derivedMap);
    return derivedMap;
  }
};
var DerivedMap = class extends ObservableMap {
  constructor(parentMap, predicate) {
    super();
    this.parentMap = parentMap;
    this.predicate = predicate;
    this.sub();
    this.observableName = parentMap.observableName + "(filter: " + predicate.toString() + ")";
  }
  sub() {
    if (this.unsub) {
      return;
    }
    this.unsub = this.parentMap.subscribe(() => {
      const newMap = /* @__PURE__ */ new Map();
      this.parentMap.forEach((value, key) => {
        if (this.predicate(value, key)) {
          newMap.set(key, value);
        }
      });
      this._map = newMap;
      this.notifyListeners();
    });
  }
  subscribe(run2) {
    this.sub();
    super.subscribe(run2);
    return () => {
      this.unsubscribe(run2);
    };
  }
  unsubscribe(run2) {
    super.unsubscribe(run2);
    if (this._listeners.size === 0 && this.unsub) {
      this.unsub();
      this.unsub = void 0;
    }
  }
  destroy() {
    if (this.unsub) {
      this.unsub();
    }
  }
};

// src/FolderSort.ts
function compareFilePaths(a, b) {
  const aParts = a.path.split("/");
  const bParts = b.path.split("/");
  if (aParts.length === 2 && bParts.length > 2)
    return 1;
  if (bParts.length === 2 && aParts.length > 2)
    return -1;
  const minLength = Math.min(aParts.length, bParts.length);
  for (let i2 = 0; i2 < minLength; i2++) {
    if (aParts[i2] !== bParts[i2]) {
      if (i2 === aParts.length - 1) {
        const aMatches = aParts[i2].match(/\d+/g);
        const bMatches = bParts[i2].match(/\d+/g);
        if (aMatches && bMatches) {
          const aNum = parseInt(aMatches[0]);
          const bNum = parseInt(bMatches[0]);
          if (aNum !== bNum) {
            return aNum - bNum;
          }
        }
      }
      return aParts[i2].localeCompare(bParts[i2]);
    }
  }
  return aParts.length - bParts.length;
}

// src/BackgroundSync.ts
function updateYDocFromDiskBuffer(ydoc, diskBuffer) {
  const ytext = ydoc.getText("contents");
  const currentContent = ytext.toString();
  const dmp = new import_diff_match_patch2.diff_match_patch();
  const diffs = dmp.diff_main(currentContent, diskBuffer);
  dmp.diff_cleanupSemantic(diffs);
  let cursor = 0;
  const log = curryLog("[updateYDocFromDiskBuffer]", "debug");
  log("Updating YDoc:");
  log("Current content length:", currentContent.length);
  log("Disk buffer length:", diskBuffer.length);
  if (diffs.length == 0) {
    return;
  }
  ydoc.transact(() => {
    for (const [operation, text3] of diffs) {
      switch (operation) {
        case 1:
          log(`Inserting "${text3}" at position ${cursor}`);
          ytext.insert(cursor, text3);
          cursor += text3.length;
          break;
        case 0:
          log(`Keeping "${text3}" (length: ${text3.length})`);
          cursor += text3.length;
          break;
        case -1:
          log(`Deleting "${text3}" at position ${cursor}`);
          ytext.delete(cursor, text3.length);
          break;
      }
    }
  });
  log("Update complete. New content length:", ytext.toString().length);
}
var BackgroundSync = class {
  constructor(loginManager, timeProvider, sharedFolders, concurrency = 1) {
    this.loginManager = loginManager;
    this.timeProvider = timeProvider;
    this.sharedFolders = sharedFolders;
    this.concurrency = concurrency;
    this.activeSync = new ObservableSet();
    this.activeDownloads = new ObservableSet();
    this.syncGroups = new ObservableMap();
    this.syncLog = new ObservableSet();
    this.syncQueue = [];
    this.downloadQueue = [];
    this.isProcessingSync = false;
    this.isProcessingDownloads = false;
    this.isPaused = true;
    this.inProgressSyncs = /* @__PURE__ */ new Set();
    this.inProgressDownloads = /* @__PURE__ */ new Set();
    this.syncCompletionCallbacks = /* @__PURE__ */ new Map();
    this.downloadCompletionCallbacks = /* @__PURE__ */ new Map();
    // A map to track items we've already logged to avoid duplicates
    this.loggedItems = /* @__PURE__ */ new Map();
    // Maximum number of log entries to keep
    this.maxLogEntries = 100;
    this.subscriptions = [];
    this.log = curryLog("[BackgroundSync]", "log");
    this.debug = curryLog("[BackgroundSync]", "debug");
    this.error = curryLog("[BackgroundSync]", "error");
    RelayInstances.set(this, "BackgroundSync");
  }
  /**
   * Returns items currently in the sync queue
   */
  get pendingSyncs() {
    return this.syncQueue;
  }
  /**
   * Returns items currently in the download queue
   */
  get pendingDownloads() {
    return this.downloadQueue;
  }
  getOverallProgress() {
    let totalItems = 0;
    let completedItems = 0;
    let syncItems = 0;
    let completedSyncs = 0;
    let downloadItems = 0;
    let completedDownloads = 0;
    this.syncGroups.forEach((group) => {
      totalItems += group.total;
      completedItems += group.completed;
      syncItems += group.syncs;
      completedSyncs += group.completedSyncs;
      downloadItems += group.downloads;
      completedDownloads += group.completedDownloads;
    });
    const totalPercent = totalItems > 0 ? completedItems / totalItems * 100 : 0;
    const syncPercent = syncItems > 0 ? completedSyncs / syncItems * 100 : 0;
    const downloadPercent = downloadItems > 0 ? completedDownloads / downloadItems * 100 : 0;
    return {
      totalPercent: Math.round(totalPercent),
      syncPercent: Math.round(syncPercent),
      downloadPercent: Math.round(downloadPercent),
      totalItems,
      completedItems,
      syncItems,
      completedSyncs,
      downloadItems,
      completedDownloads
    };
  }
  getGroupProgress(sharedFolder) {
    const group = this.syncGroups.get(sharedFolder);
    if (!group)
      return null;
    const percent = group.total > 0 ? group.completed / group.total * 100 : 0;
    const syncPercent = group.syncs > 0 ? group.completedSyncs / group.syncs * 100 : 0;
    const downloadPercent = group.downloads > 0 ? group.completedDownloads / group.downloads * 100 : 0;
    return {
      percent: Math.round(percent),
      syncPercent: Math.round(syncPercent),
      downloadPercent: Math.round(downloadPercent),
      sharedFolder,
      status: group.status
    };
  }
  getAllGroupsProgress() {
    const progress = [];
    this.syncGroups.forEach((group, sharedFolder) => {
      const groupProgress = this.getGroupProgress(sharedFolder);
      if (groupProgress) {
        progress.push(groupProgress);
      }
    });
    return progress;
  }
  async processSyncQueue() {
    if (this.isPaused || this.isProcessingSync)
      return;
    this.isProcessingSync = true;
    const connectableItems = this.syncQueue.filter(
      (item) => item.sharedFolder.connected
    );
    while (connectableItems.length > 0 && this.activeSync.size < this.concurrency) {
      const item = connectableItems.shift();
      if (!item)
        break;
      this.syncQueue = this.syncQueue.filter((i2) => i2.guid !== item.guid);
      item.status = "running";
      this.activeSync.add(item);
      this.addToLog({
        guid: item.guid,
        path: item.path,
        type: "sync",
        status: "running",
        sharedFolderGuid: item.sharedFolder.guid
      });
      try {
        const doc2 = item.doc;
        await this.syncDocument(doc2);
        item.status = "completed";
        this.addToLog({
          guid: item.guid,
          path: item.path,
          type: "sync",
          status: "completed",
          sharedFolderGuid: item.sharedFolder.guid
        });
        const callback = this.syncCompletionCallbacks.get(item.guid);
        if (callback) {
          callback.resolve();
          this.syncCompletionCallbacks.delete(item.guid);
        }
        const group = this.syncGroups.get(item.sharedFolder);
        if (group) {
          this.debug(
            `[Sync Progress] Before: completed=${group.completed}, total=${group.total}, syncs=${group.syncs}, completedSyncs=${group.completedSyncs}`
          );
          group.completedSyncs++;
          group.completed++;
          this.debug(
            `[Sync Progress] After: completed=${group.completed}, total=${group.total}, syncs=${group.syncs}, completedSyncs=${group.completedSyncs}`
          );
          if (group.completed === group.total) {
            group.status = "completed";
            this.debug("[Sync Progress] Group completed!");
            this.addToLog({
              guid: group.sharedFolder.guid,
              path: `${group.sharedFolder.path} (group)`,
              type: "sync",
              status: "completed",
              sharedFolderGuid: group.sharedFolder.guid
            });
          }
          this.syncGroups.set(item.sharedFolder, group);
        }
      } catch (error) {
        item.status = "failed";
        this.addToLog({
          guid: item.guid,
          path: item.path,
          type: "sync",
          status: "failed",
          sharedFolderGuid: item.sharedFolder.guid,
          error: error instanceof Error ? error.message : String(error)
        });
        const callback = this.syncCompletionCallbacks.get(item.guid);
        if (callback) {
          callback.reject(
            error instanceof Error ? error : new Error(String(error))
          );
          this.syncCompletionCallbacks.delete(item.guid);
        }
        const group = this.syncGroups.get(item.sharedFolder);
        if (group) {
          this.error("[Sync Failed]", error);
          group.status = "failed";
          this.syncGroups.set(item.sharedFolder, group);
          this.addToLog({
            guid: group.sharedFolder.guid,
            path: `${group.sharedFolder.path} (group)`,
            type: "sync",
            status: "failed",
            sharedFolderGuid: group.sharedFolder.guid,
            error: error instanceof Error ? error.message : String(error)
          });
        }
      } finally {
        this.activeSync.delete(item);
        this.inProgressSyncs.delete(item.guid);
      }
    }
    this.isProcessingSync = false;
    if (this.syncQueue.length > 0 && !this.isPaused) {
      const hasConnectedItems = this.syncQueue.some(
        (item) => item.sharedFolder.connected
      );
      if (hasConnectedItems) {
        this.processSyncQueue();
      }
    }
  }
  async processDownloadQueue() {
    if (this.isPaused || this.isProcessingDownloads)
      return;
    this.isProcessingDownloads = true;
    const connectableItems = this.downloadQueue.filter(
      (item) => item.sharedFolder.connected
    );
    while (connectableItems.length > 0 && this.activeDownloads.size < this.concurrency) {
      const item = connectableItems.shift();
      if (!item)
        break;
      this.downloadQueue = this.downloadQueue.filter(
        (i2) => i2.guid !== item.guid
      );
      item.status = "running";
      this.activeDownloads.add(item);
      this.addToLog({
        guid: item.guid,
        path: item.path,
        type: "download",
        status: "running",
        sharedFolderGuid: item.sharedFolder.guid
      });
      try {
        await this.getDocument(item.doc);
        item.status = "completed";
        this.addToLog({
          guid: item.guid,
          path: item.path,
          type: "download",
          status: "completed",
          sharedFolderGuid: item.sharedFolder.guid
        });
        const callback = this.downloadCompletionCallbacks.get(item.guid);
        if (callback) {
          callback.resolve();
          this.downloadCompletionCallbacks.delete(item.guid);
        }
        const group = this.syncGroups.get(item.sharedFolder);
        if (group) {
          group.completedDownloads++;
          group.completed++;
          if (group.completed === group.total) {
            group.status = "completed";
            this.addToLog({
              guid: group.sharedFolder.guid,
              path: `${group.sharedFolder.path} (group)`,
              type: "download",
              status: "completed",
              sharedFolderGuid: group.sharedFolder.guid
            });
          }
          this.syncGroups.set(item.sharedFolder, group);
        }
      } catch (error) {
        item.status = "failed";
        this.addToLog({
          guid: item.guid,
          path: item.path,
          type: "download",
          status: "failed",
          sharedFolderGuid: item.sharedFolder.guid,
          error: error instanceof Error ? error.message : String(error)
        });
        const callback = this.downloadCompletionCallbacks.get(item.guid);
        if (callback) {
          callback.reject(
            error instanceof Error ? error : new Error(String(error))
          );
          this.downloadCompletionCallbacks.delete(item.guid);
        }
        const group = this.syncGroups.get(item.sharedFolder);
        if (group) {
          group.status = "failed";
          this.syncGroups.set(item.sharedFolder, group);
          this.addToLog({
            guid: group.sharedFolder.guid,
            path: `${group.sharedFolder.path} (group)`,
            type: "download",
            status: "failed",
            sharedFolderGuid: group.sharedFolder.guid,
            error: error instanceof Error ? error.message : String(error)
          });
        }
        this.error("[processDownloadQueue]", error);
      } finally {
        this.activeDownloads.delete(item);
        this.inProgressDownloads.delete(item.guid);
      }
    }
    this.isProcessingDownloads = false;
    if (this.downloadQueue.length > 0 && !this.isPaused) {
      const hasConnectedItems = this.downloadQueue.some(
        (item) => item.sharedFolder.connected
      );
      if (hasConnectedItems) {
        this.processDownloadQueue();
      }
    }
  }
  /**
   * Enqueues a document for synchronization
   *
   * This method adds a document to the sync queue and creates/updates
   * the associated sync group to track progress.
   *
   * @param item The document to synchronize
   * @returns A promise that resolves when the sync completes
   */
  async enqueueSync(item) {
    if (this.inProgressSyncs.has(item.guid)) {
      this.debug(
        `[enqueueSync] Item ${item.guid} already in progress, skipping`
      );
      const existingCallback = this.syncCompletionCallbacks.get(item.guid);
      if (existingCallback) {
        return new Promise((resolve, reject) => {
          existingCallback.resolve = resolve;
          existingCallback.reject = reject;
        });
      }
      return Promise.resolve();
    }
    const sharedFolder = item.sharedFolder;
    const queueItem = {
      guid: item.guid,
      path: sharedFolder.getPath(item.path),
      doc: item,
      status: "pending",
      sharedFolder
    };
    let group = this.syncGroups.get(sharedFolder);
    if (!group) {
      group = {
        sharedFolder,
        total: 1,
        completed: 0,
        status: "pending",
        downloads: 0,
        syncs: 1,
        completedDownloads: 0,
        completedSyncs: 0
      };
    } else {
      group.total++;
      group.syncs++;
    }
    this.syncGroups.set(sharedFolder, group);
    this.addToLog({
      guid: item.guid,
      path: queueItem.path,
      type: "sync",
      status: "pending",
      sharedFolderGuid: sharedFolder.guid
    });
    this.inProgressSyncs.add(item.guid);
    const syncPromise = new Promise((resolve, reject) => {
      this.syncCompletionCallbacks.set(item.guid, {
        resolve,
        reject
      });
    });
    this.syncQueue.push(queueItem);
    this.syncQueue.sort(compareFilePaths);
    this.processSyncQueue();
    return syncPromise;
  }
  /**
   * Enqueues a document for download
   *
   * This method adds a document to the download queue and creates/updates
   * the associated sync group to track progress.
   *
   * @param item The document to download
   * @returns A promise that resolves when the download completes
   */
  enqueueDownload(item) {
    if (this.inProgressDownloads.has(item.guid)) {
      this.debug(
        `[enqueueDownload] Item ${item.guid} already in progress, skipping`
      );
      const existingCallback = this.downloadCompletionCallbacks.get(item.guid);
      if (existingCallback) {
        return new Promise((resolve, reject) => {
          existingCallback.resolve = resolve;
          existingCallback.reject = reject;
        });
      }
      return Promise.resolve();
    }
    const sharedFolder = item.sharedFolder;
    let group = this.syncGroups.get(sharedFolder);
    if (!group) {
      group = {
        sharedFolder,
        total: 0,
        completed: 0,
        status: "pending",
        downloads: 0,
        syncs: 0,
        completedDownloads: 0,
        completedSyncs: 0
      };
    }
    group.downloads++;
    group.total++;
    this.syncGroups.set(sharedFolder, group);
    const queueItem = {
      guid: item.guid,
      path: sharedFolder.getPath(item.path),
      doc: item,
      status: "pending",
      sharedFolder
    };
    this.addToLog({
      guid: item.guid,
      path: queueItem.path,
      type: "download",
      status: "pending",
      sharedFolderGuid: sharedFolder.guid
    });
    this.inProgressDownloads.add(item.guid);
    const downloadPromise = new Promise((resolve, reject) => {
      this.downloadCompletionCallbacks.set(item.guid, { resolve, reject });
    });
    this.downloadQueue.push(queueItem);
    this.downloadQueue.sort(compareFilePaths);
    this.processDownloadQueue();
    return downloadPromise;
  }
  /**
   * Enqueues all documents in a shared folder for synchronization
   *
   * This method creates a sync group to track the progress of synchronizing
   * all documents in a shared folder, then enqueues each document for sync.
   * It handles counter initialization correctly to avoid double-counting.
   *
   * @param sharedFolder The shared folder to synchronize
   */
  enqueueSharedFolderSync(sharedFolder) {
    const docs = [...sharedFolder.docs.values()];
    const group = {
      sharedFolder,
      total: docs.length,
      completed: 0,
      status: "pending",
      downloads: 0,
      syncs: docs.length,
      completedDownloads: 0,
      completedSyncs: 0
    };
    this.syncGroups.set(sharedFolder, group);
    this.addToLog({
      guid: sharedFolder.guid,
      path: `${sharedFolder.path} (group sync started)`,
      type: "sync",
      status: "pending",
      sharedFolderGuid: sharedFolder.guid
    });
    const sortedDocs = [...docs].sort(compareFilePaths);
    for (const doc2 of sortedDocs) {
      this.enqueueDocumentForGroupSync(doc2);
    }
    group.status = "running";
    this.syncGroups.set(sharedFolder, group);
    this.addToLog({
      guid: sharedFolder.guid,
      path: `${sharedFolder.path} (group sync running)`,
      type: "sync",
      status: "running",
      sharedFolderGuid: sharedFolder.guid
    });
  }
  /**
   * Enqueues a document for synchronization as part of a group sync operation
   *
   * This method is similar to enqueueSync() but doesn't increment any counters
   * since they're already properly initialized in enqueueSharedFolderSync().
   * This prevents double-counting of operations in progress tracking.
   *
   * @param item The document to synchronize
   * @returns A promise that resolves when the sync completes
   * @private Used internally by enqueueSharedFolderSync
   */
  async enqueueDocumentForGroupSync(item) {
    if (this.inProgressSyncs.has(item.guid)) {
      this.debug(
        `[enqueueDocumentForGroupSync] Item ${item.guid} already in progress, skipping`
      );
      const existingCallback = this.syncCompletionCallbacks.get(item.guid);
      if (existingCallback) {
        return new Promise((resolve, reject) => {
          existingCallback.resolve = resolve;
          existingCallback.reject = reject;
        });
      }
      return Promise.resolve();
    }
    const sharedFolder = item.sharedFolder;
    const queueItem = {
      guid: item.guid,
      path: sharedFolder.getPath(item.path),
      doc: item,
      status: "pending",
      sharedFolder
    };
    this.addToLog({
      guid: item.guid,
      path: queueItem.path,
      type: "sync",
      status: "pending",
      sharedFolderGuid: sharedFolder.guid
    });
    this.inProgressSyncs.add(item.guid);
    const syncPromise = new Promise((resolve, reject) => {
      this.syncCompletionCallbacks.set(item.guid, {
        resolve,
        reject
      });
    });
    this.syncQueue.push(queueItem);
    this.syncQueue.sort(compareFilePaths);
    this.processSyncQueue();
    return syncPromise;
  }
  getAuthHeader(clientToken) {
    var _a2;
    return {
      Authorization: flags().enableDocumentServer ? `Bearer ${clientToken.token}` : `Bearer ${(_a2 = this.loginManager.user) == null ? void 0 : _a2.token}`
    };
  }
  getBaseUrl(clientToken, entity) {
    var _a2;
    const urlObj = new URL(clientToken.url);
    urlObj.protocol = "https:";
    const parts = urlObj.pathname.split("/");
    parts.pop();
    parts.push(clientToken.docId);
    urlObj.pathname = parts.join("/");
    const baseUrl = ((_a2 = clientToken.baseUrl) == null ? void 0 : _a2.replace(/\/$/, "")) || urlObj.toString();
    if (flags().enableDocumentServer) {
      return baseUrl;
    } else {
      return `${"https://api.system3.md"}/relay/${entity.relayId}/doc/${entity.documentId}`;
    }
  }
  async downloadItem(item) {
    const entity = item.s3rn;
    this.log("[downloadItem]", item.path, `${S3RN.encode(entity)}`);
    if (!(entity instanceof S3RemoteDocument)) {
      throw new Error("Unable to decode S3RN");
    }
    const clientToken = await item.getProviderToken();
    const headers = this.getAuthHeader(clientToken);
    const baseUrl = this.getBaseUrl(clientToken, entity);
    const url = `${baseUrl}/as-update`;
    const response = await (0, import_obsidian2.requestUrl)({
      url,
      method: "GET",
      headers
    });
    if (response.status === 200) {
      this.debug("[downloadItem]", entity.documentId, response.status);
    } else {
      this.error(
        "[downloadItem]",
        entity.documentId,
        baseUrl,
        response.status,
        response.text
      );
    }
    return response;
  }
  async syncDocumentWebsocket(doc2) {
    const currentText = doc2.text;
    let currentFileContents = "";
    try {
      currentFileContents = await doc2.sharedFolder.read(doc2);
    } catch (e2) {
    }
    const contentsMatch = currentText === currentFileContents;
    if (!contentsMatch) {
      this.log(
        "file is not tracking local disk. resolve merge conflicts before syncing."
      );
      return false;
    }
    const promise = doc2.onceProviderSynced();
    const intent = doc2.intent;
    doc2.connect();
    if (intent === "disconnected" && !doc2.userLock) {
      await promise;
    }
    if (intent === "disconnected" && !doc2.userLock) {
      doc2.disconnect();
      doc2.sharedFolder.tokenStore.removeFromRefreshQueue(S3RN.encode(doc2.s3rn));
    }
    return true;
  }
  async uploadItem(item) {
    const entity = item.s3rn;
    this.log("[uploadItem]", `${S3RN.encode(entity)}`);
    if (!(entity instanceof S3RemoteDocument)) {
      throw new Error("Unable to decode S3RN");
    }
    if (!this.loginManager.loggedIn) {
      throw new Error("Not logged in");
    }
    const clientToken = await item.getProviderToken();
    const headers = {
      "Content-Type": "application/octet-stream",
      ...this.getAuthHeader(clientToken)
    };
    const update2 = encodeStateAsUpdate(item.ydoc);
    const baseUrl = this.getBaseUrl(clientToken, entity);
    const updateUrl = `${baseUrl}/update`;
    const response = await (0, import_obsidian2.requestUrl)({
      url: updateUrl,
      method: "POST",
      headers,
      body: update2.buffer,
      throw: false
    });
    if (response.status === 200) {
      this.debug(
        "[uploadItem]",
        entity.documentId,
        response.status,
        response.text
      );
    } else {
      this.error(
        "[uploadItem]",
        entity.documentId,
        updateUrl,
        response.status,
        response.text
      );
    }
    return response;
  }
  async getDocument(doc2, retry = 3, wait = 3e3) {
    try {
      const currentText = doc2.text;
      let currentFileContents = "";
      try {
        currentFileContents = await doc2.sharedFolder.read(doc2);
      } catch (e2) {
      }
      const contentsMatch = currentText === currentFileContents;
      const hasContents = currentFileContents !== "";
      const response = await this.downloadItem(doc2);
      const rawUpdate = response.arrayBuffer;
      const updateBytes = new Uint8Array(rawUpdate);
      const newDoc = new Doc();
      applyUpdate(newDoc, updateBytes);
      const users = newDoc.getMap("users");
      const contents = newDoc.getText("contents").toString();
      if (contents === "") {
        if (users.size === 0) {
          this.log(
            "[getDocument] Server contains uninitialized document. Waiting for peer to upload.",
            users.size,
            retry,
            wait
          );
          if (retry > 0) {
            this.timeProvider.setTimeout(() => {
              this.getDocument(doc2, retry - 1, wait * 2);
            }, wait);
          }
          return;
        }
        if (currentFileContents === "") {
          this.log("[getDocument] empty document");
          return;
        }
        if (doc2.text) {
          this.log(
            "[getDocument] local crdt has contents, but remote is empty"
          );
          this.enqueueSync(doc2);
          return;
        }
      }
      this.log("[getDocument] applying content from server");
      applyUpdate(doc2.ydoc, updateBytes);
      if (hasContents && !contentsMatch) {
        this.log("Skipping flush - file requires merge conflict resolution.");
        return;
      }
      if (doc2.sharedFolder.ids.has(doc2.path)) {
        doc2.sharedFolder.flush(doc2, doc2.text);
        this.log("[getDocument] flushed");
      }
    } catch (e2) {
      this.error(e2);
      throw e2;
    }
  }
  async syncItem(doc2) {
    const currentText = doc2.text;
    let currentFileContents = "";
    try {
      currentFileContents = await doc2.sharedFolder.read(doc2);
    } catch (e2) {
    }
    const contentsMatch = currentText === currentFileContents;
    if (!contentsMatch) {
      this.log(
        "file is not tracking local disk. resolve merge conflicts before syncing."
      );
      return false;
    }
    const response = await this.downloadItem(doc2);
    if (response.status !== 200) {
      this.log("server returned an error.");
      return false;
    }
    const rawUpdate = response.arrayBuffer;
    const updateBytes = new Uint8Array(rawUpdate);
    const newDoc = new Doc();
    applyUpdate(newDoc, updateBytes);
    const contents = newDoc.getText("contents").toString();
    const users = newDoc.getMap("users");
    if (users.size > 0 && contents === currentText) {
      return true;
    }
    applyUpdate(doc2.ydoc, updateBytes);
    doc2.sharedFolder.flush(doc2, doc2.text);
    this.uploadItem(doc2);
    return true;
  }
  async syncDocument(doc2) {
    var _a2;
    try {
      if (flags().enableHTTPSync && ((_a2 = doc2.sharedFolder.remote) == null ? void 0 : _a2.relay.provider)) {
        await this.syncItem(doc2);
      } else {
        this.debug("fallback to websocket sync");
        await this.syncDocumentWebsocket(doc2);
      }
    } catch (e2) {
      console.error(e2);
      return;
    }
  }
  subscribeToSync(callback) {
    return this.activeSync.subscribe(callback);
  }
  subscribeToDownloads(callback) {
    return this.activeDownloads.subscribe(callback);
  }
  subscribeToSyncGroups(callback) {
    return this.syncGroups.subscribe(callback);
  }
  subscribeToProgress(callback) {
    const handler = () => {
      callback(this.getOverallProgress());
    };
    const unsub1 = this.activeSync.subscribe(() => handler());
    const unsub2 = this.activeDownloads.subscribe(() => handler());
    const unsub3 = this.syncGroups.subscribe(() => handler());
    return () => {
      unsub1();
      unsub2();
      unsub3();
    };
  }
  /**
   * Adds an entry to the sync operation log
   *
   * This method adds a new entry to the sync log with the current timestamp.
   * It prevents duplicate entries for the same item+status combination and
   * automatically trims the log if it exceeds the maximum size.
   *
   * @param entry The partial log entry to add
   */
  addToLog(entry) {
    const timestamp = Date.now();
    const id2 = entry.id || `log-${entry.type}-${entry.guid}-${entry.status}-${timestamp}`;
    const logKey = `${entry.type}-${entry.guid}-${entry.status}`;
    if (!this.loggedItems.has(logKey)) {
      this.loggedItems.set(logKey, true);
      const logEntry = {
        id: id2,
        timestamp,
        path: entry.path || "",
        type: entry.type || "sync",
        status: entry.status || "pending",
        guid: entry.guid || id2,
        sharedFolderGuid: entry.sharedFolderGuid || "",
        error: entry.error
      };
      this.syncLog.add(logEntry);
      this.trimLog();
    }
  }
  /**
   * Gets all sync log entries, sorted by timestamp (newest first)
   *
   * @returns Array of log entries sorted by timestamp (newest first)
   */
  getSyncLog() {
    const entries = [];
    this.syncLog.forEach((entry) => entries.push(entry));
    return entries.sort((a, b) => b.timestamp - a.timestamp);
  }
  /**
   * Clears the sync log
   *
   * This method removes all entries from the sync log and resets
   * the logged items tracking.
   */
  clearSyncLog() {
    this.syncLog.clear();
    this.loggedItems.clear();
  }
  /**
   * Trims the log to the maximum number of entries
   *
   * This method keeps only the most recent entries up to the maximum
   * number configured in maxLogEntries.
   *
   * @private Used internally by addToLog
   */
  trimLog() {
    const entries = this.getSyncLog();
    if (entries.length > this.maxLogEntries) {
      const entriesToKeep = entries.slice(0, this.maxLogEntries);
      this.syncLog.clear();
      entriesToKeep.forEach((entry) => {
        this.syncLog.add(entry);
      });
    }
  }
  /**
   * Retries a failed sync or download operation
   *
   * This method attempts to retry a previously failed operation by
   * re-enqueueing the document for sync or download.
   *
   * @param logEntry The log entry to retry
   * @returns A promise that resolves to true if retry was successful, false otherwise
   */
  async retryLogItem(logEntry) {
    try {
      const foldersArray = [];
      this.sharedFolders.forEach((folder) => foldersArray.push(folder));
      const sharedFolder = foldersArray.find(
        (folder) => folder.guid === logEntry.sharedFolderGuid
      );
      if (!sharedFolder) {
        this.log("Retry failed: Shared folder not found");
        return false;
      }
      const doc2 = sharedFolder.docs.get(logEntry.guid);
      if (!doc2) {
        this.log("Retry failed: Document not found");
        return false;
      }
      this.addToLog({
        guid: logEntry.guid,
        path: logEntry.path,
        type: logEntry.type,
        status: "pending",
        sharedFolderGuid: logEntry.sharedFolderGuid
      });
      if (logEntry.type === "sync") {
        await this.enqueueSync(doc2);
        this.log(`Retrying sync for ${logEntry.path}`);
      } else {
        await this.enqueueDownload(doc2);
        this.log(`Retrying download for ${logEntry.path}`);
      }
      return true;
    } catch (error) {
      this.error("Error retrying item:", error);
      this.addToLog({
        guid: logEntry.guid,
        path: logEntry.path,
        type: logEntry.type,
        status: "failed",
        sharedFolderGuid: logEntry.sharedFolderGuid,
        error: error instanceof Error ? error.message : String(error)
      });
      return false;
    }
  }
  /**
   * Subscribes to sync log updates
   *
   * @param callback The function to call when the sync log changes
   * @returns A function to unsubscribe
   */
  subscribeToSyncLog(callback) {
    return this.syncLog.subscribe(callback);
  }
  /**
   * Subscribes to progress updates for a specific shared folder
   *
   * @param sharedFolder The shared folder to monitor
   * @param callback The function to call when progress changes
   * @returns A function to unsubscribe
   */
  subscribeToGroupProgress(sharedFolder, callback) {
    return this.syncGroups.subscribe(() => {
      callback(this.getGroupProgress(sharedFolder));
    });
  }
  /**
   * Pauses all sync and download queue processing
   *
   * This method temporarily halts processing of sync and download queues.
   * The queues can be resumed by calling resume().
   */
  pause() {
    this.isPaused = true;
  }
  /**
   * Resumes sync and download queue processing
   *
   * This method resumes processing of sync and download queues after
   * they have been paused.
   */
  resume() {
    this.isPaused = false;
    this.processSyncQueue();
    this.processDownloadQueue();
  }
  /**
   * Gets the current status of sync and download queues
   *
   * @returns An object with queue statistics
   */
  getQueueStatus() {
    return {
      syncsQueued: this.syncQueue.length,
      syncsActive: this.activeSync.size,
      downloadsQueued: this.downloadQueue.length,
      downloadsActive: this.activeDownloads.size,
      isPaused: this.isPaused
    };
  }
  /**
   * Destroys this instance and cleans up all resources
   *
   * This method cleans up all resources used by this instance,
   * including rejecting pending promises, destroying observable
   * collections, and clearing queues.
   */
  destroy() {
    for (const [guid, callback] of this.syncCompletionCallbacks) {
      callback.reject(new Error("BackgroundSync destroyed"));
      this.syncCompletionCallbacks.delete(guid);
    }
    for (const [guid, callback] of this.downloadCompletionCallbacks) {
      callback.reject(new Error("BackgroundSync destroyed"));
      this.downloadCompletionCallbacks.delete(guid);
    }
    this.activeSync.destroy();
    this.activeDownloads.destroy();
    this.syncGroups.destroy();
    this.syncLog.destroy();
    this.syncQueue = [];
    this.downloadQueue = [];
    this.inProgressSyncs.clear();
    this.inProgressDownloads.clear();
    this.loggedItems.clear();
    this.loginManager = null;
    this.sharedFolders = null;
    this.timeProvider = null;
    this.subscriptions.forEach((off) => off());
  }
};

// src/differ/actionLine.ts
var ActionLine = class {
  constructor(app, args3) {
    this.app = app;
    this.difference = args3.difference;
    this.file1 = args3.file1;
    this.file2 = args3.file2;
    this.file1Content = args3.file1Content;
    this.file2Content = args3.file2Content;
    this.triggerRebuild = args3.triggerRebuild;
  }
  async modify(file, newContent) {
    if (file instanceof Document) {
      updateYDocFromDiskBuffer(file.ydoc, newContent);
      return;
    } else if (file instanceof DiskBuffer) {
      file.contents = newContent;
      return;
    }
    await this.app.vault.modify(file, newContent);
  }
  build(container) {
    const actionLine = container.createDiv({
      cls: "flex flex-row gap-1 py-0-5"
    });
    const hasMinusLines = this.difference.file1Lines.length > 0;
    const hasPlusLines = this.difference.file2Lines.length > 0;
    if (hasPlusLines && hasMinusLines) {
      new ActionLineButton({
        text: "Accept Top (Editor)",
        onClick: (e2) => this.acceptTopClick(e2, this.difference)
      }).build(actionLine);
      ActionLineDivider.build(actionLine);
      new ActionLineButton({
        text: "Accept Bottom (Local Disk)",
        onClick: (e2) => this.acceptBottomClick(e2, this.difference)
      }).build(actionLine);
      ActionLineDivider.build(actionLine);
      new ActionLineButton({
        text: "Accept All",
        onClick: (e2) => this.acceptAllClick(e2, this.difference)
      }).build(actionLine);
      ActionLineDivider.build(actionLine);
      new ActionLineButton({
        text: "Accept None",
        onClick: (e2) => this.acceptNoneClick(e2, this.difference)
      }).build(actionLine);
    } else if (hasMinusLines) {
      new ActionLineButton({
        text: `Keep in Editor`,
        onClick: (e2) => this.insertFile1Difference(e2, this.difference)
      }).build(actionLine);
      ActionLineDivider.build(actionLine);
      new ActionLineButton({
        text: "Discard in Editor",
        onClick: (e2) => this.discardFile1Difference(e2, this.difference)
      }).build(actionLine);
    } else if (hasPlusLines) {
      new ActionLineButton({
        text: `Accept from Local Disk`,
        onClick: (e2) => this.insertFile2Difference(e2, this.difference)
      }).build(actionLine);
      ActionLineDivider.build(actionLine);
      new ActionLineButton({
        text: "Discard on Disk",
        onClick: (e2) => this.discardFile2Difference(e2, this.difference)
      }).build(actionLine);
    }
  }
  async acceptTopClick(event, difference) {
    event.preventDefault();
    const changedLines = difference.file1Lines.join("\n");
    const newContent = replaceLine({
      fullText: this.file2Content,
      newLine: changedLines,
      position: difference.file2Start,
      linesToReplace: difference.file2Lines.length
    });
    await this.modify(this.file2, newContent);
    this.triggerRebuild();
  }
  async acceptBottomClick(event, difference) {
    event.preventDefault();
    const changedLines = difference.file2Lines.join("\n");
    const newContent = replaceLine({
      fullText: this.file1Content,
      newLine: changedLines,
      position: difference.file1Start,
      linesToReplace: difference.file1Lines.length
    });
    await this.modify(this.file1, newContent);
    this.triggerRebuild();
  }
  async acceptAllClick(event, difference) {
    event.preventDefault();
    const changedLines = [
      ...difference.file1Lines,
      ...difference.file2Lines
    ].join("\n");
    const newFile1Content = replaceLine({
      fullText: this.file1Content,
      newLine: changedLines,
      position: difference.file1Start,
      linesToReplace: difference.file1Lines.length
    });
    await this.modify(this.file1, newFile1Content);
    const newFile2Content = replaceLine({
      fullText: this.file2Content,
      newLine: changedLines,
      position: difference.file2Start,
      linesToReplace: difference.file2Lines.length
    });
    await this.modify(this.file2, newFile2Content);
    this.triggerRebuild();
  }
  async acceptNoneClick(event, difference) {
    event.preventDefault();
    const newFile1Content = deleteLines({
      fullText: this.file1Content,
      position: difference.file1Start,
      count: difference.file1Lines.length
    });
    await this.modify(this.file1, newFile1Content);
    const newFile2Content = deleteLines({
      fullText: this.file2Content,
      position: difference.file2Start,
      count: difference.file2Lines.length
    });
    await this.modify(this.file2, newFile2Content);
    this.triggerRebuild();
  }
  async insertFile1Difference(event, difference) {
    event.preventDefault();
    const changedLines = difference.file1Lines.join("\n");
    const newContent = insertLine({
      fullText: this.file2Content,
      newLine: changedLines,
      position: difference.file2Start
    });
    await this.modify(this.file2, newContent);
    this.triggerRebuild();
  }
  async insertFile2Difference(event, difference) {
    event.preventDefault();
    const changedLines = difference.file2Lines.join("\n");
    const newContent = insertLine({
      fullText: this.file1Content,
      newLine: changedLines,
      position: difference.file1Start
    });
    await this.modify(this.file1, newContent);
    this.triggerRebuild();
  }
  async discardFile1Difference(event, difference) {
    event.preventDefault();
    const newContent = deleteLines({
      fullText: this.file1Content,
      position: difference.file1Start,
      count: difference.file1Lines.length
    });
    await this.modify(this.file1, newContent);
    this.triggerRebuild();
  }
  async discardFile2Difference(event, difference) {
    event.preventDefault();
    const newContent = deleteLines({
      fullText: this.file2Content,
      position: difference.file2Start,
      count: difference.file2Lines.length
    });
    await this.modify(this.file2, newContent);
    this.triggerRebuild();
  }
};

// src/differ/differencesView.ts
var VIEW_TYPE_DIFFERENCES = "system3-differences-view";
async function openDiffView(workspace, state) {
  workspace.detachLeavesOfType(VIEW_TYPE_DIFFERENCES);
  const leaf = workspace.getLeaf(true);
  leaf.setViewState({
    type: VIEW_TYPE_DIFFERENCES,
    active: true,
    state
  });
  workspace.revealLeaf(leaf);
}
var DifferencesView = class extends import_obsidian3.ItemView {
  constructor(leaf) {
    super(leaf);
    this.file1Lines = [];
    this.file2Lines = [];
  }
  async getContent(file) {
    if (file instanceof Document) {
      return file.text;
    } else if (file instanceof DiskBuffer) {
      return file.contents;
    }
    return await this.app.vault.cachedRead(file);
  }
  getViewType() {
    return VIEW_TYPE_DIFFERENCES;
  }
  getDisplayText() {
    var _a2, _b2;
    if (((_a2 = this.state) == null ? void 0 : _a2.file1) && ((_b2 = this.state) == null ? void 0 : _b2.file2)) {
      return `File Diff: ${this.state.file1.name} and ${this.state.file2.name}`;
    }
    return `File Diff`;
  }
  async setState(state, result) {
    super.setState(state, result);
    this.state = state;
    await this.updateState();
    this.build();
  }
  async onunload() {
    var _a2, _b2;
    (_b2 = (_a2 = this.state) == null ? void 0 : _a2.onResolve) == null ? void 0 : _b2.call(_a2);
  }
  async updateState() {
    var _a2, _b2;
    if (((_a2 = this.state) == null ? void 0 : _a2.file1) == null || ((_b2 = this.state) == null ? void 0 : _b2.file2) == null) {
      return;
    }
    this.file1Content = await this.getContent(this.state.file1);
    this.file2Content = await this.getContent(this.state.file2);
    this.file1Lines = this.file1Content.concat("\n").split("\n").map((line) => line.trimEnd());
    this.file2Lines = this.file2Content.concat("\n").split("\n").map((line) => line.trimEnd());
    const parsedDiff = structuredPatch(
      this.state.file1.path,
      this.state.file2.path,
      this.file1Lines.join("\n"),
      this.file2Lines.join("\n")
    );
    this.fileDifferences = FileDifferences.fromParsedDiff(parsedDiff);
    if (this.fileDifferences.differences.length === 0) {
      this.leaf.detach();
    }
  }
  build() {
    this.contentEl.empty();
    const container = this.contentEl.createDiv({
      cls: "file-diff__container"
    });
    this.buildHeader(container);
    this.buildLines(container);
    this.scrollToFirstDifference();
  }
  update() {
    const scrollTop = this.contentEl.scrollTop;
    this.contentEl.empty();
    const container = this.contentEl.createDiv({
      cls: "file-diff__container"
    });
    this.buildHeader(container);
    this.buildLines(container);
    this.contentEl.scrollTop = scrollTop;
  }
  buildHeader(container) {
    const actionLine = container.createDiv({
      cls: "flex flex-row gap-1 py-0-5"
    });
    new ActionLineButton({
      text: `Keep Editor Contents`,
      onClick: async (e2) => {
        e2.preventDefault();
        await this.acceptAllFromLeft();
      }
    }).build(actionLine);
    ActionLineDivider.build(actionLine);
    new ActionLineButton({
      text: `Accept All from Local Disk`,
      onClick: async (e2) => {
        e2.preventDefault();
        await this.acceptAllFromRight();
      }
    }).build(actionLine);
  }
  async acceptAllFromLeft() {
    if (!this.state || !this.fileDifferences)
      return;
    await this.app.vault.modify(this.state.file2, this.file1Content || "");
    this.leaf.detach();
  }
  async acceptAllFromRight() {
    if (!this.state || !this.fileDifferences)
      return;
    await this.app.vault.modify(this.state.file1, this.file2Content || "");
    this.leaf.detach();
  }
  buildLines(container) {
    var _a2, _b2, _c;
    let lineCount1 = 0;
    let lineCount2 = 0;
    const maxLineCount = Math.max(
      ((_a2 = this.file1Lines) == null ? void 0 : _a2.length) || 0,
      ((_b2 = this.file2Lines) == null ? void 0 : _b2.length) || 0
    );
    while (lineCount1 <= maxLineCount || lineCount2 <= maxLineCount) {
      const difference = (_c = this.fileDifferences) == null ? void 0 : _c.differences.find(
        // eslint-disable-next-line no-loop-func
        (d) => d.file1Start === lineCount1 && d.file2Start === lineCount2
      );
      if (difference != null) {
        const differenceContainer = container.createDiv({
          cls: "difference"
        });
        this.buildDifferenceVisualizer(differenceContainer, difference);
        lineCount1 += difference.file1Lines.length;
        lineCount2 += difference.file2Lines.length;
      } else {
        const line = lineCount1 <= lineCount2 ? this.file1Lines[lineCount1] : this.file2Lines[lineCount2];
        container.createDiv({
          // Necessary to give the line a height when it's empty.
          text: preventEmptyString(line),
          cls: "file-diff__line"
        });
        lineCount1 += 1;
        lineCount2 += 1;
      }
    }
  }
  buildDifferenceVisualizer(container, difference) {
    var _a2;
    if ((_a2 = this.state) == null ? void 0 : _a2.showMergeOption) {
      new ActionLine(this.app, {
        difference,
        file1: this.state.file1,
        file2: this.state.file2,
        file1Content: this.file1Content || "",
        file2Content: this.file2Content || "",
        triggerRebuild: async () => {
          await this.updateState();
          this.update();
        }
      }).build(container);
    }
    for (let i2 = 0; i2 < difference.file1Lines.length; i2 += 1) {
      const line1 = difference.file1Lines[i2];
      const line2 = difference.file2Lines[i2];
      const lineDiv = container.createDiv({
        cls: "file-diff__line file-diff__top-line__bg"
      });
      const diffSpans = this.buildDiffLine(
        line1,
        line2,
        "file-diff_top-line__character"
      );
      if (i2 < difference.file1Lines.length - 1 || difference.file2Lines.length !== 0) {
        lineDiv.classList.add("file-diff__no-bottom-border");
      }
      if (i2 !== 0) {
        lineDiv.classList.add("file-diff__no-top-border");
      }
      lineDiv.appendChild(diffSpans);
    }
    for (let i2 = 0; i2 < difference.file2Lines.length; i2 += 1) {
      const line1 = difference.file1Lines[i2];
      const line2 = difference.file2Lines[i2];
      const lineDiv = container.createDiv({
        cls: "file-diff__line file-diff__bottom-line__bg"
      });
      const diffSpans = this.buildDiffLine(
        line2,
        line1,
        "file-diff_bottom-line__character"
      );
      if (i2 == 0 && difference.file1Lines.length > 0 || i2 > 0) {
        lineDiv.classList.add("file-diff__no-top-border");
      }
      if (i2 < difference.file2Lines.length - 1) {
        lineDiv.classList.add("file-diff__no-bottom-border");
      }
      lineDiv.appendChild(diffSpans);
    }
  }
  buildDiffLine(line1, line2, charClass) {
    const fragment2 = document.createElement("div");
    if (line1 != void 0 && line1.length === 0) {
      fragment2.textContent = preventEmptyString(line1);
    } else if (line1 != void 0 && line2 != void 0) {
      const differences = diffWords(line2, line1);
      for (const difference of differences) {
        if (difference.removed) {
          continue;
        }
        const span = document.createElement("span");
        span.textContent = preventEmptyString(difference.value);
        if (difference.added) {
          span.classList.add(charClass);
        }
        fragment2.appendChild(span);
      }
    } else if (line1 != void 0 && line2 == void 0) {
      const span = document.createElement("span");
      span.textContent = preventEmptyString(line1);
      span.classList.add(charClass);
      fragment2.appendChild(span);
    } else {
      fragment2.textContent = preventEmptyString(line1);
    }
    return fragment2;
  }
  scrollToFirstDifference() {
    var _a2;
    if (((_a2 = this.fileDifferences) == null ? void 0 : _a2.differences.length) === 0) {
      return;
    }
    const containerRect = this.contentEl.getElementsByClassName("file-diff__container")[0].getBoundingClientRect();
    const elementRect = this.contentEl.getElementsByClassName("difference")[0].getBoundingClientRect();
    this.contentEl.scrollTo({
      top: elementRect.top - containerRect.top - 100,
      behavior: "smooth"
    });
  }
};

// src/LiveViews.ts
var BACKGROUND_CONNECTIONS = 3;
function iterateMarkdownViews(workspace, fn) {
  workspace.iterateAllLeaves((leaf) => {
    if (leaf.view instanceof import_obsidian4.MarkdownView) {
      fn(leaf.view);
    }
  });
}
function ViewsetsEqual(vs1, vs2) {
  var _a2, _b2, _c, _d;
  if (vs1.length !== vs2.length) {
    return false;
  }
  for (let i2 = 0; i2 < vs1.length; i2++) {
    if (((_a2 = vs1[i2].view.file) == null ? void 0 : _a2.path) !== ((_b2 = vs2[i2].view.file) == null ? void 0 : _b2.path)) {
      return false;
    }
    if (((_c = vs1[i2].document) == null ? void 0 : _c.path) !== ((_d = vs2[i2].document) == null ? void 0 : _d.path)) {
      return false;
    }
  }
  return true;
}
var LoggedOutView = class {
  constructor(connectionManager, view, login) {
    this.document = null;
    this.canConnect = false;
    this._parent = connectionManager;
    this.view = view;
    this.login = login;
  }
  attach() {
    this.banner = new Banner(
      this.view,
      "Login to enable Live edits",
      async () => {
        return await this.login();
      }
    );
    return Promise.resolve(this);
  }
  release() {
    var _a2;
    (_a2 = this.banner) == null ? void 0 : _a2.destroy();
  }
  destroy() {
    this.release();
    this.banner = void 0;
    this.view = null;
  }
};
function isLive(view) {
  return view instanceof LiveView && view.document !== void 0 && view.document.text !== void 0;
}
var LiveView = class {
  constructor(connectionManager, view, document2, shouldConnect = true, canConnect = true) {
    this._parent = connectionManager;
    this.view = view;
    this.document = document2;
    this._tracking = false;
    this.shouldConnect = shouldConnect;
    this.canConnect = canConnect;
    if (!connectionManager.networkStatus.online) {
      this.offlineBanner();
    }
  }
  toggleConnection() {
    this.shouldConnect = !this.shouldConnect;
    if (this.shouldConnect) {
      this.document.connect().then((connected) => {
        if (!connected) {
          this.shouldConnect = false;
        }
      });
    } else {
      this.document.disconnect();
    }
  }
  get tracking() {
    return this._tracking;
  }
  set tracking(value) {
    const old = this._tracking;
    this._tracking = value;
    if (this._tracking !== old) {
      this.attach();
    }
  }
  get ytext() {
    return this.document.ytext;
  }
  mergeBanner() {
    this._banner = new Banner(
      this.view,
      "Merge conflict -- click to resolve",
      async () => {
        const diskBuffer = await this.document.diskBuffer();
        const stale = await this.document.checkStale();
        if (!stale) {
          return true;
        }
        this._parent.openDiffView({
          file1: this.document,
          file2: diskBuffer,
          showMergeOption: true,
          onResolve: async () => {
            this.document.clearDiskBuffer();
          }
        });
        return true;
      }
    );
    return () => {
    };
  }
  offlineBanner() {
    if (this.shouldConnect) {
      const banner = new Banner(
        this.view,
        "You're offline -- click to reconnect",
        async () => {
          this._parent.networkStatus.checkStatus();
          this.connect();
          return this._parent.networkStatus.online;
        }
      );
      this._parent.networkStatus.onceOnline(() => {
        this.connect();
        banner.destroy();
      });
    }
    return () => {
    };
  }
  setConnectionDot() {
    const viewActionsElement = this.view.containerEl.querySelector(".view-actions");
    if (viewActionsElement && viewActionsElement.firstChild) {
      if (!this._viewActions) {
        this.clearViewActions();
        if (this.offConnectionStatusSubscription) {
          this.offConnectionStatusSubscription();
        }
        this._viewActions = new ViewActions_default({
          target: viewActionsElement,
          anchor: viewActionsElement.firstChild,
          props: {
            view: this,
            state: this.document.state,
            remote: this.document.sharedFolder.remote
          }
        });
        this.offConnectionStatusSubscription = this.document.subscribe(
          viewActionsElement,
          (state) => {
            var _a2;
            (_a2 = this._viewActions) == null ? void 0 : _a2.$set({
              view: this,
              state,
              remote: this.document.sharedFolder.remote
            });
          }
        );
      }
      this._viewActions.$set({
        view: this,
        state: this.document.state,
        remote: this.document.sharedFolder.remote
      });
    }
  }
  clearViewActions() {
    const viewActionsElement = this.view.containerEl.querySelector(".view-actions");
    if (viewActionsElement && viewActionsElement.firstChild) {
      const viewActions = this.view.containerEl.querySelectorAll(
        ".system3-view-action"
      );
      if (viewActions.length > 0) {
        viewActions.forEach((viewAction) => {
          viewAction.remove();
        });
      }
    }
  }
  async checkStale() {
    var _a2, _b2;
    const stale = await this.document.checkStale();
    if (stale && ((_a2 = this.document._diskBuffer) == null ? void 0 : _a2.contents)) {
      this.mergeBanner();
    } else {
      (_b2 = this._banner) == null ? void 0 : _b2.destroy();
      this._banner = void 0;
    }
    return stale;
  }
  attach() {
    this.document.userLock = true;
    this.setConnectionDot();
    return new Promise((resolve) => {
      return this.document.whenReady().then((doc2) => {
        if (this._parent.networkStatus.online && this.document.sharedFolder.shouldConnect && this.shouldConnect && this.canConnect) {
          this.connect();
        } else {
          this.document.disconnect();
        }
        resolve(this);
      }).catch(() => {
        this.offlineBanner();
      });
    });
  }
  connect() {
    this.document.connect();
  }
  release() {
    var _a2, _b2;
    (_a2 = this._viewActions) == null ? void 0 : _a2.$destroy();
    this._viewActions = void 0;
    (_b2 = this._banner) == null ? void 0 : _b2.destroy();
    this._banner = void 0;
    if (this.offConnectionStatusSubscription) {
      this.offConnectionStatusSubscription();
      this.offConnectionStatusSubscription = void 0;
    }
    this.document.disconnect();
    this.document.userLock = false;
  }
  destroy() {
    this.release();
    this.clearViewActions();
    this.view.leaf.rebuildView();
    this._parent = null;
    this.view = null;
    this.document = null;
  }
};
var LiveViewManager4 = class {
  constructor(app, sharedFolders, loginManager, networkStatus) {
    this.app = app;
    this.destroyed = false;
    this.offListeners = [];
    this.folderListeners = /* @__PURE__ */ new Map();
    this.workspace = app.workspace;
    this.sharedFolders = sharedFolders;
    this.views = [];
    this.extensions = [];
    this._activePromise = null;
    this.loginManager = loginManager;
    this.networkStatus = networkStatus;
    this.refreshQueue = [];
    this._compartment = new import_state4.Compartment();
    this.log = curryLog("[LiveViews]", "log");
    this.warn = curryLog("[LiveViews]", "warn");
    this.metadataListeners = /* @__PURE__ */ new Map();
    const cb = (tfile, data, cache) => {
      const sub = this.metadataListeners.get(tfile);
      sub == null ? void 0 : sub(data, cache);
    };
    const offRef = this.app.metadataCache.on("changed", cb);
    this.offListeners.push(() => {
      this.app.metadataCache.offref(offRef);
    });
    this.offListeners.push(
      this.loginManager.on(() => {
        this.refresh("[LoginManager]");
      })
    );
    const folderSub = (folder) => {
      if (!folder.ready) {
        (async () => {
          folder.whenReady().then(() => {
            this.refresh("[Shared Folder Ready]");
          }).catch((_) => {
            this.views.forEach((view) => {
              var _a2;
              if (((_a2 = view.document) == null ? void 0 : _a2.sharedFolder) === folder) {
                view.offlineBanner();
              }
            });
          });
        })();
      }
      return folder.docset.on(() => {
        this.refresh("[Docset]");
      });
    };
    this.offListeners.push(
      this.sharedFolders.subscribe(() => {
        this.refresh("[Shared Folders]");
        this.folderListeners.forEach((off, folder) => {
          if (!this.sharedFolders.has(folder)) {
            off();
            this.folderListeners.delete(folder);
          }
        });
        this.sharedFolders.forEach((folder) => {
          if (!this.folderListeners.has(folder)) {
            this.folderListeners.set(folder, folderSub(folder));
          }
        });
      })
    );
    RelayInstances.set(this, "LiveViewManager");
  }
  reconfigure(editorView) {
    editorView.dispatch({
      effects: this._compartment.reconfigure([
        ConnectionManagerStateField.init(() => {
          return this;
        })
      ])
    });
  }
  onMeta(tfile, cb) {
    this.metadataListeners.set(tfile, cb);
  }
  offMeta(tfile) {
    this.metadataListeners.delete(tfile);
  }
  openDiffView(state) {
    openDiffView(this.workspace, state);
  }
  goOffline() {
    this.log("[System 3][Relay][Live Views] going offline");
    this.views.forEach((view) => {
      var _a2;
      return (_a2 = view.document) == null ? void 0 : _a2.disconnect();
    });
    this.refresh("[NetworkStatus]");
  }
  goOnline() {
    this.log("[System 3][Relay][Live Views] going online");
    this.refresh("[NetworkStatus]");
    this.sharedFolders.items().forEach((folder) => {
      folder.connect();
    });
    this.viewsAttachedWithConnectionPool(this.views);
  }
  docIsOpen(doc2) {
    return this.views.some((view) => view.document === doc2);
  }
  releaseViews(views) {
    views.forEach((view) => {
      view.release();
    });
  }
  findFolders() {
    const folders = /* @__PURE__ */ new Set();
    iterateMarkdownViews(this.workspace, (markdownView) => {
      var _a2;
      const viewFilePath = (_a2 = markdownView.file) == null ? void 0 : _a2.path;
      if (!viewFilePath) {
        return;
      }
      const folder = this.sharedFolders.lookup(viewFilePath);
      if (folder) {
        folders.add(folder);
      }
    });
    if (folders.size == 0) {
      return [];
    }
    return [...folders];
  }
  async foldersReady() {
    const folders = /* @__PURE__ */ new Set();
    iterateMarkdownViews(this.workspace, (markdownView) => {
      var _a2;
      const viewFilePath = (_a2 = markdownView.file) == null ? void 0 : _a2.path;
      if (!viewFilePath) {
        return;
      }
      const folder = this.sharedFolders.lookup(viewFilePath);
      if (folder) {
        folders.add(folder);
      }
    });
    if (folders.size === 0) {
      return [];
    }
    const readyFolders = [...folders].map((folder) => folder.whenReady());
    return Promise.all(readyFolders);
  }
  async getViews() {
    const views = [];
    iterateMarkdownViews(this.workspace, async (markdownView) => {
      var _a2;
      const viewFilePath = (_a2 = markdownView.file) == null ? void 0 : _a2.path;
      if (!viewFilePath) {
        return;
      }
      const folder = this.sharedFolders.lookup(viewFilePath);
      if (folder) {
        if (!this.loginManager.loggedIn) {
          const view = new LoggedOutView(this, markdownView, () => {
            return this.loginManager.openLoginPage();
          });
          views.push(view);
        } else if (folder.ready) {
          const doc2 = await folder.getFile(viewFilePath);
          const view = new LiveView(this, markdownView, doc2);
          views.push(view);
        } else {
          this.log(`Folder not ready, skipping views. folder=${folder.path}`);
        }
      }
    });
    return views;
  }
  findView(cmEditor) {
    return this.views.find((view) => {
      const editor = view.view.editor;
      const cm = editor.cm;
      return cm === cmEditor;
    });
  }
  async viewsReady(views) {
    return await Promise.all(
      views.filter((view) => view instanceof LiveView).map(
        async (view) => view.document.whenReady().then((_) => view)
      )
    );
  }
  async viewsAttachedWithConnectionPool(views, backgroundConnections = BACKGROUND_CONNECTIONS) {
    const activeView = this.workspace.getActiveViewOfType(import_obsidian4.MarkdownView);
    let attemptedConnections = 0;
    const viewHistory = views.sort(
      (a, b) => b.view.leaf.activeTime - a.view.leaf.activeTime
    );
    const connectedDocuments = /* @__PURE__ */ new Set();
    for (const view of viewHistory) {
      if (view instanceof LiveView) {
        if (view.view === activeView || connectedDocuments.has(view.document)) {
          view.canConnect = true;
          connectedDocuments.add(view.document);
        } else if (attemptedConnections < backgroundConnections) {
          view.canConnect = true;
          connectedDocuments.add(view.document);
          attemptedConnections++;
        } else {
          view.canConnect = false;
        }
      }
    }
    if (attemptedConnections > backgroundConnections) {
      this.warn(
        `[System 3][Relay][Live Views] connection pool (max ${backgroundConnections}): rejected connections for ${attemptedConnections - backgroundConnections} views`
      );
    }
    return this.viewsAttached(views);
  }
  async viewsAttached(views) {
    return await Promise.all(
      views.map(async (view) => {
        return view.attach();
      })
    );
  }
  deduplicate(views) {
    const stale = [];
    const matching = [];
    this.views.forEach((oldView) => {
      const found = views.find((newView) => {
        if (oldView.document == newView.document && oldView.view == newView.view) {
          return true;
        }
      });
      if (found) {
        matching.push(oldView);
        views.remove(found);
      } else {
        stale.push(oldView);
      }
    });
    views.forEach((view) => {
      matching.push(view);
    });
    return [matching, stale];
  }
  async _refreshViews(context, queuedAt) {
    const ctx = `[LiveViews][${context}]`;
    const log = curryLog(ctx, "debug");
    const logViews = (message, views2) => {
      log(
        message,
        views2.map((view) => {
          var _a2;
          return {
            type: view.constructor.name,
            file: (_a2 = view.document) == null ? void 0 : _a2.path,
            canConnect: view.canConnect
          };
        })
      );
    };
    log("Refresh");
    if (this.destroyed)
      return false;
    await this.foldersReady();
    let views = [];
    try {
      views = await this.getViews();
    } catch (e2) {
      this.warn("[System 3][Relay][Live Views] error getting views", e2);
      return false;
    }
    const activeDocumentFolders = this.findFolders();
    if (activeDocumentFolders.length === 0 && views.length === 0) {
      if (this.extensions.length !== 0) {
        log("Unexpected plugins loaded.");
        this.wipe();
      }
      logViews("Releasing Views", this.views);
      this.releaseViews(this.views);
      this.views = [];
      return true;
    }
    if (this.loginManager.loggedIn && this.networkStatus.online) {
      activeDocumentFolders.forEach((folder) => {
        folder.connect();
      });
    } else {
      this.sharedFolders.forEach((folder) => {
        folder.disconnect();
      });
    }
    const [matching, stale] = this.deduplicate(views);
    logViews("Releasing Views", stale);
    this.releaseViews(stale);
    if (stale.length === 0 && ViewsetsEqual(matching, this.views)) {
      const attachedViews = await this.viewsAttachedWithConnectionPool(
        this.views
      );
      logViews("Attached Views", attachedViews);
    } else {
      const readyViews = await this.viewsReady(matching);
      logViews("Ready Views", readyViews);
      const attachedViews = await this.viewsAttachedWithConnectionPool(readyViews);
      logViews("Attached Views", attachedViews);
      this.views = matching;
    }
    log("loading plugins");
    this.load();
    const now2 = import_obsidian4.moment.utc();
    log(`refresh completed in ${now2.diff(queuedAt)}ms`, ctx);
    return true;
  }
  async refresh(context) {
    if (this.destroyed)
      return false;
    const log = curryLog(context, "warn");
    const queuedAt = import_obsidian4.moment.utc();
    this.refreshQueue.push(() => {
      return this._refreshViews(context, queuedAt);
    });
    if (this._activePromise !== null) {
      return false;
    }
    while (this.refreshQueue.length > 0) {
      if (this.destroyed)
        return false;
      if (this.refreshQueue.length > 2) {
        log("refreshQueue size:", this.refreshQueue.length);
      }
      const job = this.refreshQueue.pop();
      this.refreshQueue.length = 0;
      this._activePromise = job().finally(() => {
        this._activePromise = null;
      });
      await this._activePromise;
    }
    return true;
  }
  wipe() {
    this.extensions.length = 0;
    this.workspace.updateOptions();
  }
  load() {
    this.wipe();
    if (this.views.length > 0) {
      this.extensions.push([
        this._compartment.of(
          ConnectionManagerStateField.init(() => {
            return this;
          })
        ),
        LiveEdit,
        yRemoteSelectionsTheme,
        yRemoteSelections,
        InvalidLinkPlugin
      ]);
      this.workspace.updateOptions();
    }
  }
  destroy() {
    this.destroyed = true;
    this.releaseViews(this.views);
    this.offListeners.forEach((off) => off());
    this.offListeners.length = 0;
    this.metadataListeners.clear();
    this.metadataListeners = null;
    this.folderListeners.forEach((off) => off());
    this.folderListeners.clear();
    this.folderListeners = null;
    this.views.forEach((view) => view.destroy());
    this.views = [];
    this.wipe();
    this.sharedFolders = null;
    this.refreshQueue = null;
    this.networkStatus = null;
    this._activePromise = null;
    this.loginManager = null;
    this.app = null;
    this.workspace = null;
  }
};
var ConnectionManagerStateField = import_state4.StateField.define({
  create(state) {
    return void 0;
  },
  update(currentManager, transaction) {
    return currentManager;
  }
});

// src/ui/FolderNav.ts
var import_obsidian5 = require("obsidian");

// src/components/Pill.svelte
function add_css2(target) {
  append_styles(target, "svelte-1vj9882", ".folder-icons.svelte-1vj9882{display:inline-flex;align-items:center;vertical-align:middle;border-radius:var(--radius-m);transition:width 0.3s ease;margin-right:0.6em;padding-left:0.2em;padding-right:0.2em;background-color:var(--color-base-05);position:relative}.icon.svelte-1vj9882{margin-right:0.2em;margin-left:0.2em;width:1em;display:flex;transition:display 0.3s ease}span.system3-connected.svelte-1vj9882{color:var(--color-accent)}span.system3-disconnected.svelte-1vj9882{color:var(--color-base-40)}span.notebook.svelte-1vj9882{color:var(--color-accent)}span.hidden.svelte-1vj9882{display:none}.system3-progress-text.svelte-1vj9882{margin-right:0.4em;font-size:0.8em;color:var(--color-accent);opacity:1;transition:opacity 0.3s ease}.system3-progress-text.completed.svelte-1vj9882{animation:svelte-1vj9882-fadeOutDelay 0.3s ease forwards}.system3-progress-text.failed.svelte-1vj9882{color:var(--color-red)}@keyframes svelte-1vj9882-fadeOutDelay{0%,50%{opacity:1}100%{opacity:0;display:none}}");
}
function create_if_block_1(ctx) {
  let span;
  let t0;
  let t1;
  let span_class_value;
  return {
    c() {
      span = element2("span");
      t0 = text2(
        /*progress*/
        ctx[3]
      );
      t1 = text2("%");
      attr(span, "class", span_class_value = "system3-progress-text system3-" + /*syncStatus*/
      ctx[4] + " svelte-1vj9882");
      set_style(span, "opacity", "1");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append2(span, t0);
      append2(span, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*progress*/
      8)
        set_data(
          t0,
          /*progress*/
          ctx2[3]
        );
      if (dirty & /*syncStatus*/
      16 && span_class_value !== (span_class_value = "system3-progress-text system3-" + /*syncStatus*/
      ctx2[4] + " svelte-1vj9882")) {
        attr(span, "class", span_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_else_block2(ctx) {
  let span;
  let layers;
  let current;
  layers = new layers_default({
    props: {
      class: "inline-icon",
      style: "width: 0.8em"
    }
  });
  return {
    c() {
      span = element2("span");
      create_component(layers.$$.fragment);
      attr(span, "class", "notebook icon svelte-1vj9882");
      attr(span, "aria-label", "Tracking Changes");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      mount_component(layers, span, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(layers.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(layers.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      destroy_component(layers);
    }
  };
}
function create_if_block2(ctx) {
  let span0;
  let layers;
  let t2;
  let span1;
  let satellite;
  let span1_class_value;
  let span1_aria_label_value;
  let current;
  layers = new layers_default({
    props: {
      class: "inline-icon",
      style: "width: 0.8em"
    }
  });
  satellite = new satellite_default({ props: { class: "inline-icon" } });
  return {
    c() {
      var _a2;
      span0 = element2("span");
      create_component(layers.$$.fragment);
      t2 = space();
      span1 = element2("span");
      create_component(satellite.$$.fragment);
      attr(span0, "class", "notebook icon hidden svelte-1vj9882");
      attr(span0, "aria-label", "Tracking Changes");
      attr(span1, "class", span1_class_value = "satellite icon system3-" + /*status*/
      ctx[0] + " svelte-1vj9882");
      attr(span1, "aria-label", span1_aria_label_value = `${/*remote*/
      ((_a2 = ctx[2]) == null ? void 0 : _a2.relay.name) || "Relay Server"} (${/*status*/
      ctx[0]})`);
    },
    m(target, anchor) {
      insert(target, span0, anchor);
      mount_component(layers, span0, null);
      insert(target, t2, anchor);
      insert(target, span1, anchor);
      mount_component(satellite, span1, null);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      if (!current || dirty & /*status*/
      1 && span1_class_value !== (span1_class_value = "satellite icon system3-" + /*status*/
      ctx2[0] + " svelte-1vj9882")) {
        attr(span1, "class", span1_class_value);
      }
      if (!current || dirty & /*remote, status*/
      5 && span1_aria_label_value !== (span1_aria_label_value = `${/*remote*/
      ((_a2 = ctx2[2]) == null ? void 0 : _a2.relay.name) || "Relay Server"} (${/*status*/
      ctx2[0]})`)) {
        attr(span1, "aria-label", span1_aria_label_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(layers.$$.fragment, local);
      transition_in(satellite.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(layers.$$.fragment, local);
      transition_out(satellite.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span0);
        detach(t2);
        detach(span1);
      }
      destroy_component(layers);
      destroy_component(satellite);
    }
  };
}
function create_fragment22(ctx) {
  let div;
  let t2;
  let current_block_type_index;
  let if_block1;
  let current;
  let if_block0 = (
    /*showProgress*/
    ctx[5] && create_if_block_1(ctx)
  );
  const if_block_creators = [create_if_block2, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*relayId*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element2("div");
      if (if_block0)
        if_block0.c();
      t2 = space();
      if_block1.c();
      attr(div, "class", "folder-icons svelte-1vj9882");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append2(div, t2);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*showProgress*/
        ctx2[5]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1(ctx2);
          if_block0.c();
          if_block0.m(div, t2);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block0)
        if_block0.d();
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance22($$self, $$props, $$invalidate) {
  let showProgress;
  let { status = "disconnected" } = $$props;
  let { relayId } = $$props;
  let { remote } = $$props;
  let { progress = 0 } = $$props;
  let { syncStatus = "pending" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("status" in $$props2)
      $$invalidate(0, status = $$props2.status);
    if ("relayId" in $$props2)
      $$invalidate(1, relayId = $$props2.relayId);
    if ("remote" in $$props2)
      $$invalidate(2, remote = $$props2.remote);
    if ("progress" in $$props2)
      $$invalidate(3, progress = $$props2.progress);
    if ("syncStatus" in $$props2)
      $$invalidate(4, syncStatus = $$props2.syncStatus);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*syncStatus, progress*/
    24) {
      $:
        $$invalidate(5, showProgress = (syncStatus !== "completed" || progress < 100) && progress > 0);
    }
  };
  return [status, relayId, remote, progress, syncStatus, showProgress];
}
var Pill = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance22,
      create_fragment22,
      safe_not_equal,
      {
        status: 0,
        relayId: 1,
        remote: 2,
        progress: 3,
        syncStatus: 4
      },
      add_css2
    );
  }
};
var Pill_default = Pill;

// src/components/TextPill.svelte
function add_css3(target) {
  append_styles(target, "svelte-1swndfj", ".system3-filepill.svelte-1swndfj{text-wrap:nowrap}");
}
function create_fragment23(ctx) {
  let div;
  let span;
  let t2;
  return {
    c() {
      div = element2("div");
      span = element2("span");
      t2 = text2(
        /*text*/
        ctx[0]
      );
      attr(div, "class", "nav-file-tag system3-filepill svelte-1swndfj");
      attr(
        div,
        "aria-label",
        /*label*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append2(div, span);
      append2(span, t2);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*text*/
      1)
        set_data(
          t2,
          /*text*/
          ctx2[0]
        );
      if (dirty & /*label*/
      2) {
        attr(
          div,
          "aria-label",
          /*label*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function instance23($$self, $$props, $$invalidate) {
  let { text: text3 } = $$props;
  let { label } = $$props;
  $$self.$$set = ($$props2) => {
    if ("text" in $$props2)
      $$invalidate(0, text3 = $$props2.text);
    if ("label" in $$props2)
      $$invalidate(1, label = $$props2.label);
  };
  return [text3, label];
}
var TextPill = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance23, create_fragment23, safe_not_equal, { text: 0, label: 1 }, add_css3);
  }
};
var TextPill_default = TextPill;

// src/ui/FolderNav.ts
var SiblingWatcher = class {
  constructor(el, onceSibling) {
    this.el = el;
    this.mutationObserver = new MutationObserver((mutationsList, observer) => {
      for (const mutation of mutationsList) {
        if (mutation.type === "childList") {
          if (el.nextSibling) {
            onceSibling(el);
            observer.disconnect();
          }
        }
      }
    });
    this.mutationObserver.observe(el.parentElement, {
      childList: true,
      subtree: true
    });
  }
  destroy() {
    var _a2;
    (_a2 = this.mutationObserver) == null ? void 0 : _a2.disconnect();
    this.mutationObserver = null;
  }
};
var BaseVisitor = class {
  visitFolder(folder, item, storage, sharedFolder) {
    return null;
  }
  visitFile(file, item, storage, sharedFolder) {
    return null;
  }
};
var FolderBar = class {
  constructor(el, sharedFolder) {
    this.el = el;
    this.sharedFolder = sharedFolder;
    this.siblingWatcher = new SiblingWatcher(this.el, (el2) => {
      this.add();
    });
    this.add();
  }
  add() {
    var _a2;
    (_a2 = this.el.nextSibling) == null ? void 0 : _a2.addClass("system3-live");
  }
  remove() {
    var _a2;
    (_a2 = this.el.nextSibling) == null ? void 0 : _a2.removeClass("system3-live");
  }
  destroy() {
    this.siblingWatcher.destroy();
    this.remove();
  }
};
var FolderBarVisitor = class extends BaseVisitor {
  visitFolder(folder, item, storage, sharedFolder) {
    if (sharedFolder && sharedFolder.path === folder.path) {
      return storage || new FolderBar(item.selfEl, sharedFolder);
    }
    if (storage) {
      storage.destroy();
    }
    return null;
  }
};
var PillDecoration = class {
  constructor(el, sharedFolder) {
    this.el = el;
    this.sharedFolder = sharedFolder;
    this.el.addClass("system3-pill");
    this.pill = new Pill_default({
      target: this.el,
      props: {
        status: this.sharedFolder.state.status,
        relayId: this.sharedFolder.relayId,
        remote: this.sharedFolder.remote,
        progress: 0,
        syncStatus: "pending"
      }
    });
    const unsubs = [];
    unsubs.push(
      this.sharedFolder.subscribe(this.el, (state) => {
        this.pill.$set({
          status: state.status,
          relayId: this.sharedFolder.relayId,
          remote: this.sharedFolder.remote
        });
      })
    );
    unsubs.push(
      this.sharedFolder.backgroundSync.subscribeToGroupProgress(
        this.sharedFolder,
        (progress) => {
          if (progress) {
            this.pill.$set({
              progress: progress.percent,
              syncStatus: progress.status
            });
          }
        }
      )
    );
    this.unsubscribe = () => unsubs.forEach((u) => u());
  }
  destroy() {
    this.pill.$destroy();
    this.unsubscribe();
    this.el.removeClass("system3-pill");
  }
};
var FolderPillVisitor = class extends BaseVisitor {
  visitFolder(folder, item, storage, sharedFolder) {
    if (sharedFolder && sharedFolder.path === folder.path) {
      return storage || new PillDecoration(item.selfEl, sharedFolder);
    }
    if (storage) {
      storage.destroy();
    }
    return null;
  }
};
var QueueWatcher = class {
  constructor(el, path, activeSync, activeDownloads) {
    this.el = el;
    this.path = path;
    this.activeSync = activeSync;
    this.activeDownloads = activeDownloads;
    this.unsubscribers = [];
    this.titleEl = el.querySelector(".nav-file-title") || el;
    this.unsubscribers.push(
      this.activeSync.subscribe(() => this.checkStatus()),
      this.activeDownloads.subscribe(() => this.checkStatus())
    );
    this.checkStatus();
  }
  checkStatus() {
    const isSyncing = this.activeSync.some((item) => item.path === this.path);
    const isDownloading = this.activeDownloads.some(
      (item) => item.path === this.path
    );
    if (isSyncing) {
      this.titleEl.addClass("system3-syncing");
    } else {
      this.titleEl.removeClass("system3-syncing");
    }
    if (isDownloading) {
      this.titleEl.addClass("system3-downloading");
    } else {
      this.titleEl.removeClass("system3-downloading");
    }
  }
  destroy() {
    this.titleEl.removeClass("system3-uploading");
    this.titleEl.removeClass("system3-downloading");
    this.unsubscribers.forEach((unsub) => unsub());
  }
};
var QueueWatcherVisitor = class extends BaseVisitor {
  constructor(activeSync, activeDownloads) {
    super();
    this.activeSync = activeSync;
    this.activeDownloads = activeDownloads;
  }
  visitFile(file, item, storage, sharedFolder) {
    if (sharedFolder && sharedFolder.ready && sharedFolder.checkExtension(file.path) && sharedFolder.checkPath(file.path)) {
      return storage || new QueueWatcher(
        item.el,
        file.path,
        this.activeSync,
        this.activeDownloads
      );
    }
    if (storage) {
      storage.destroy();
    }
    return null;
  }
};
var FilePillDecoration = class {
  constructor(el, doc2) {
    this.el = el;
    this.doc = doc2;
    this.el.querySelectorAll(".system3-filepill").forEach((el2) => {
      el2.remove();
    });
    this.pill = new TextPill_default({
      target: this.el,
      props: {
        text: `${doc2.guid.slice(0, 3)}`
      }
    });
    const onUpdate = async () => {
      await doc2.whenSynced();
      await doc2.count();
      this.pill.$set({
        text: `${doc2.guid.slice(0, 3)} ${doc2.dbsize}`
      });
    };
    doc2.whenReady().then(() => {
      doc2.ydoc.on("update", onUpdate);
      onUpdate();
    });
    this.unsubscribe = () => {
      doc2.ydoc.off("update", onUpdate);
    };
  }
  destroy() {
    var _a2;
    this.pill.$destroy();
    (_a2 = this.unsubscribe) == null ? void 0 : _a2.call(this);
    this.el.querySelectorAll(".system3-filepill").forEach((el) => {
      el.remove();
    });
  }
};
var FilePillVisitor = class extends BaseVisitor {
  visitFile(file, item, storage, sharedFolder) {
    if (sharedFolder && sharedFolder.ready && sharedFolder.checkExtension(file.path)) {
      const doc2 = sharedFolder.viewFile(file.path);
      if (!doc2)
        return null;
      if (!doc2.ready)
        return null;
      return storage || new FilePillDecoration(item.selfEl, doc2);
    }
    if (storage) {
      storage.destroy();
    }
    return null;
  }
};
var NotSyncedPillDecoration = class {
  constructor(el) {
    this.el = el;
    this.el.querySelectorAll(".system3-filepill").forEach((el2) => {
      el2.remove();
    });
    this.pill = new TextPill_default({
      target: this.el,
      props: {
        text: "NOT SYNCED",
        label: "Relay does not support this file type."
      }
    });
  }
  destroy() {
    this.pill.$destroy();
    this.el.querySelectorAll(".system3-filepill").forEach((el) => {
      el.remove();
    });
  }
};
var NotSyncedPillVisitor = class extends BaseVisitor {
  visitFile(file, item, storage, sharedFolder) {
    if (sharedFolder && !sharedFolder.checkExtension(file.path)) {
      return storage || new NotSyncedPillDecoration(item.selfEl);
    }
    if (storage) {
      storage.destroy();
    }
    return null;
  }
};
var DocumentStatus = class {
  constructor(el, document2, doc2) {
    this.el = el;
    this.document = document2;
    this.document.subscribe(el, (status) => {
      this.docStatus(status);
    });
    this.docStatus(this.document.state);
  }
  docStatus(status) {
    if ((status == null ? void 0 : status.status) === "connected") {
      this.el.removeClass("system3-connecting");
      this.el.addClass("system3-connected");
      this.el.addClass("system3-live");
    } else if ((status == null ? void 0 : status.status) === "connecting") {
      this.el.removeClass("system3-connected");
      this.el.addClass("system3-connecting");
      this.el.addClass("system3-live");
    } else if ((status == null ? void 0 : status.status) === "disconnected") {
      this.el.addClass("system3-live");
      this.el.removeClass("system3-connected");
      this.el.removeClass("system3-connecting");
    } else {
      this.el.removeClass("system3-connected");
      this.el.removeClass("system3-connecting");
      this.el.removeClass("system3-live");
    }
  }
  destroy() {
    var _a2;
    (_a2 = this.document) == null ? void 0 : _a2.unsubscribe(this.el);
    this.docStatus();
  }
};
var FileStatusVisitor = class extends BaseVisitor {
  visitFile(file, item, storage, sharedFolder) {
    if (sharedFolder) {
      try {
        const guid = sharedFolder.ids.get(
          sharedFolder.getVirtualPath(file.path)
        );
        if (!guid)
          return null;
        const document2 = sharedFolder.docs.get(guid);
        if (!document2)
          return null;
        return storage || new DocumentStatus(item.el, document2, file);
      } catch (e2) {
        return null;
      }
    }
    if (storage) {
      storage.destroy();
    }
    return null;
  }
};
var DeSyncPillDecoration = class {
  constructor(el) {
    this.el = el;
    this.el.querySelectorAll(".system3-filepill").forEach((el2) => {
      el2.remove();
    });
    this.pill = new TextPill_default({
      target: this.el,
      props: {
        text: "DESYNC",
        label: "File content does not match document content"
      }
    });
  }
  destroy() {
    this.pill.$destroy();
    this.el.querySelectorAll(".system3-filepill").forEach((el) => {
      el.remove();
    });
  }
};
var DeSyncPillVisitor = class extends BaseVisitor {
  visitFile(file, item, storage, sharedFolder) {
    if (sharedFolder && sharedFolder.checkExtension(file.path)) {
      const doc2 = sharedFolder.viewFile(file.path);
      if (!doc2 || !doc2.ready)
        return null;
      if (file.stat.size !== doc2.stat.size) {
        return storage || new DeSyncPillDecoration(item.selfEl);
      }
    }
    if (storage) {
      storage.destroy();
    }
    return null;
  }
};
var FileExplorerWalker = class {
  constructor(fileExplorer, sharedFolders, visitors) {
    this.fileExplorer = fileExplorer;
    this.sharedFolders = sharedFolders;
    this.visitors = visitors;
    this.storage = /* @__PURE__ */ new Map();
    for (const visitor of this.visitors) {
      this.storage.set(visitor, /* @__PURE__ */ new Map());
    }
  }
  _getFileExplorerItem(path) {
    try {
      return this.fileExplorer.view.fileItems[path];
    } catch (e2) {
      return null;
    }
  }
  // XXX this is a private API
  getFileExplorerItem(fileExplorer, fileOrFolder) {
    if (typeof fileOrFolder === "string") {
      return this._getFileExplorerItem(fileOrFolder);
    }
    return this._getFileExplorerItem(fileOrFolder.path);
  }
  walk(folder, _sharedFolder) {
    if (this.fileExplorer.view.getViewType() !== "file-explorer") {
      return;
    }
    const sharedFolder = this.sharedFolders.find(
      (sharedFolder2) => sharedFolder2.path === folder.path
    ) || _sharedFolder;
    const folderItem = this.getFileExplorerItem(
      this.fileExplorer,
      folder
    );
    if (folderItem) {
      this.storage.forEach((store, visitor) => {
        const stored = store.get(folderItem);
        const update2 = visitor.visitFolder(
          folder,
          folderItem,
          stored,
          sharedFolder
        );
        if (stored && !update2) {
          store.delete(folderItem);
        } else if (update2) {
          store.set(folderItem, update2);
        }
      });
    }
    folder.children.forEach((child) => {
      if (child instanceof import_obsidian5.TFolder) {
        this.walk(child, sharedFolder);
      } else if (child instanceof import_obsidian5.TFile) {
        const fileItem = this.getFileExplorerItem(
          this.fileExplorer,
          child
        );
        if (!fileItem) {
          return;
        }
        this.storage.forEach((store, visitor) => {
          const stored = store.get(fileItem);
          const update2 = visitor.visitFile(
            child,
            fileItem,
            stored,
            sharedFolder
          );
          if (stored && !update2) {
            store.delete(fileItem);
          } else if (update2) {
            store.set(fileItem, update2);
          }
        });
      }
    });
  }
  destroy() {
    this.storage.forEach((store) => {
      store.forEach((item) => {
        item.destroy();
      });
    });
  }
};
var FolderNavigationDecorations = class {
  constructor(vault, workspace, sharedFolders, backgroundSync) {
    this.layoutReady = false;
    this.queueSubscriptions = [];
    this.vault = vault;
    this.workspace = workspace;
    this.sharedFolders = sharedFolders;
    this.backgroundSync = backgroundSync;
    this.treeState = /* @__PURE__ */ new Map();
    this.workspace.onLayoutReady(() => {
      this.layoutReady = true;
      this.refresh();
    });
    this.queueSubscriptions.push(
      backgroundSync.activeSync.subscribe(() => this.quickRefresh()),
      backgroundSync.activeDownloads.subscribe(() => this.quickRefresh()),
      backgroundSync.syncGroups.subscribe(() => this.quickRefresh())
    );
    this.offDocumentListeners = /* @__PURE__ */ new Map();
    this.offFolderListener = this.sharedFolders.subscribe(() => {
      this.sharedFolders.forEach((folder) => {
        withAnyOf([flag.enableDocumentStatus, flag.enableDebugFileTag], () => {
          const docsetListener = this.offDocumentListeners.get(folder);
          if (!docsetListener) {
            this.offDocumentListeners.set(
              folder,
              folder.docset.on(() => {
                this.refresh();
              })
            );
          }
        });
        folder.whenReady().then(() => {
          this.refresh();
        });
      });
      this.refresh();
    });
    this.offLayoutChange = (() => {
      const ref = this.workspace.on("layout-change", () => this.quickRefresh());
      return () => {
        this.workspace.offref(ref);
      };
    })();
  }
  makeVisitors() {
    const visitors = [];
    visitors.push(new FolderBarVisitor());
    visitors.push(new FolderPillVisitor());
    withFlag(flag.enableDocumentStatus, () => {
      visitors.push(new FileStatusVisitor());
      visitors.push(
        new QueueWatcherVisitor(
          this.backgroundSync.activeSync,
          this.backgroundSync.activeDownloads
        )
      );
    });
    withFlag(flag.enableDebugFileTag, () => {
      visitors.push(new FilePillVisitor());
    });
    withFlag(flag.enableDesyncPill, () => {
      visitors.push(new DeSyncPillVisitor());
    });
    visitors.push(new NotSyncedPillVisitor());
    return visitors;
  }
  getFileExplorers() {
    const fileExplorers = [];
    this.workspace.iterateAllLeaves((leaf) => {
      const viewType = leaf.view.getViewType();
      if (viewType === "file-explorer") {
        if (!fileExplorers.includes(leaf)) {
          fileExplorers.push(leaf);
        }
      }
    });
    return fileExplorers;
  }
  quickRefresh() {
    if (!this.layoutReady)
      return;
    const fileExplorers = this.getFileExplorers();
    const sharedFolders = this.sharedFolders.map((folder) => folder.path);
    for (const fileExplorer of fileExplorers) {
      const walker = this.treeState.get(fileExplorer) || new FileExplorerWalker(
        fileExplorer,
        this.sharedFolders,
        this.makeVisitors()
      );
      this.treeState.set(fileExplorer, walker);
      for (const sharedFolderPath of sharedFolders) {
        const sharedFolder = this.vault.getAbstractFileByPath(sharedFolderPath);
        if (sharedFolder instanceof import_obsidian5.TFolder) {
          walker.walk(sharedFolder);
        }
      }
    }
  }
  refresh() {
    if (!this.layoutReady)
      return;
    const fileExplorers = this.getFileExplorers();
    for (const fileExplorer of fileExplorers) {
      const walker = this.treeState.get(fileExplorer) || new FileExplorerWalker(
        fileExplorer,
        this.sharedFolders,
        this.makeVisitors()
      );
      this.treeState.set(fileExplorer, walker);
      const root = this.vault.getAbstractFileByPath("/");
      if (root instanceof import_obsidian5.TFolder) {
        walker.walk(root);
      }
    }
  }
  destroy() {
    var _a2;
    (_a2 = this.offFolderListener) == null ? void 0 : _a2.call(this);
    this.offDocumentListeners.forEach((off) => off());
    this.offDocumentListeners.clear();
    this.treeState.forEach((walker) => {
      walker.destroy();
    });
    this.treeState.clear();
    this.offLayoutChange();
    this.queueSubscriptions.forEach((unsub) => unsub());
    this.queueSubscriptions = [];
    this.vault = null;
    this.workspace = null;
    this.sharedFolders = null;
    this.backgroundSync = null;
    this.offFolderListener = null;
  }
};

// src/ui/SettingsTab.ts
var import_obsidian19 = require("obsidian");

// node_modules/tslib/tslib.es6.js
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// src/components/LoggedIn.svelte
var import_obsidian10 = require("obsidian");

// src/components/Discord.svelte
function create_fragment24(ctx) {
  let svg;
  let g;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      g = svg_element("g");
      path = svg_element("path");
      attr(path, "d", "M216.856339,16.5966031 C200.285002,8.84328665 182.566144,3.2084988 164.041564,0 C161.766523,4.11318106 159.108624,9.64549908 157.276099,14.0464379 C137.583995,11.0849896 118.072967,11.0849896 98.7430163,14.0464379 C96.9108417,9.64549908 94.1925838,4.11318106 91.8971895,0 C73.3526068,3.2084988 55.6133949,8.86399117 39.0420583,16.6376612 C5.61752293,67.146514 -3.4433191,116.400813 1.08711069,164.955721 C23.2560196,181.510915 44.7403634,191.567697 65.8621325,198.148576 C71.0772151,190.971126 75.7283628,183.341335 79.7352139,175.300261 C72.104019,172.400575 64.7949724,168.822202 57.8887866,164.667963 C59.7209612,163.310589 61.5131304,161.891452 63.2445898,160.431257 C105.36741,180.133187 151.134928,180.133187 192.754523,160.431257 C194.506336,161.891452 196.298154,163.310589 198.110326,164.667963 C191.183787,168.842556 183.854737,172.420929 176.223542,175.320965 C180.230393,183.341335 184.861538,190.991831 190.096624,198.16893 C211.238746,191.588051 232.743023,181.531619 254.911949,164.955721 C260.227747,108.668201 245.831087,59.8662432 216.856339,16.5966031 Z M85.4738752,135.09489 C72.8290281,135.09489 62.4592217,123.290155 62.4592217,108.914901 C62.4592217,94.5396472 72.607595,82.7145587 85.4738752,82.7145587 C98.3405064,82.7145587 108.709962,94.5189427 108.488529,108.914901 C108.508531,123.290155 98.3405064,135.09489 85.4738752,135.09489 Z M170.525237,135.09489 C157.88039,135.09489 147.510584,123.290155 147.510584,108.914901 C147.510584,94.5396472 157.658606,82.7145587 170.525237,82.7145587 C183.391518,82.7145587 193.761324,94.5189427 193.539891,108.914901 C193.539891,123.290155 183.391518,135.09489 170.525237,135.09489 Z");
      attr(path, "fill", "#5865F2");
      attr(path, "fill-rule", "nonzero");
      attr(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr(svg, "viewBox", "0 -28.5 256 256");
      attr(svg, "version", "1.1");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
      attr(svg, "preserveAspectRatio", "xMidYMid");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append2(svg, g);
      append2(g, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function instance24($$self, $$props, $$invalidate) {
  let { size = "1em" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
  };
  return [size];
}
var Discord = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance24, create_fragment24, safe_not_equal, { size: 0 });
  }
};
var Discord_default = Discord;

// src/components/GetInTouch.svelte
function add_css4(target) {
  append_styles(target, "svelte-4t8k3t", ".menu-container.svelte-4t8k3t{display:inline-block;position:relative}.menu-button.svelte-4t8k3t{box-shadow:none;padding:8px;border:none;background:transparent;color:var(--text-muted)}.menu-button.svelte-4t8k3t:hover{color:var(--icon-color-hover)}.menu-button.svelte-4t8k3t:focus{color:var(--icon-color-focus)}.menu-dropdown.svelte-4t8k3t{position:absolute;right:0;margin-top:8px;width:224px;background:var(--color-base-10);border-radius:6px;box-shadow:0 4px 6px -1px rgba(0, 0, 0, 0.1),\n			0 2px 4px -1px rgba(0, 0, 0, 0.06);border:1px solid rgba(0, 0, 0, 0.1)}.arrow.svelte-4t8k3t{position:absolute;top:-5px;right:12px;width:10px;height:10px;background:var(--color-base-10);border-left:1px solid rgba(0, 0, 0, 0.1);border-top:1px solid rgba(0, 0, 0, 0.1);transform:rotate(45deg)}.menu-content.svelte-4t8k3t{display:flex;flex-direction:column;gap:8px;padding:8px}.menu-item.svelte-4t8k3t{display:flex;width:100%;align-items:center;gap:12px;padding:8px;border-radius:4px;text-decoration:none;color:var(--text-muted);transition:background-color 0.2s;font-size:14px}.menu-item.svelte-4t8k3t:hover{background-color:var(--background-modifier-hover)}.menu-item.svelte-4t8k3t:focus{background-color:var(--background-modifier-hover)}");
}
function create_if_block3(ctx) {
  let div2;
  let div0;
  let t0;
  let div1;
  let span1;
  let a;
  let discord;
  let t1;
  let span0;
  let clickOutside_action;
  let current;
  let mounted;
  let dispose;
  discord = new Discord_default({ props: { size: 20 } });
  return {
    c() {
      div2 = element2("div");
      div0 = element2("div");
      t0 = space();
      div1 = element2("div");
      span1 = element2("span");
      a = element2("a");
      create_component(discord.$$.fragment);
      t1 = space();
      span0 = element2("span");
      span0.textContent = "Join the community";
      attr(div0, "class", "arrow svelte-4t8k3t");
      attr(a, "href", "https://discord.system3.md");
      attr(a, "target", "_blank");
      attr(a, "rel", "noopener noreferrer");
      attr(a, "class", "menu-item svelte-4t8k3t");
      set_style(span1, "text-align", "center");
      set_style(span1, "display", "flex");
      attr(div1, "class", "menu-content svelte-4t8k3t");
      attr(div2, "class", "menu-dropdown svelte-4t8k3t");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append2(div2, div0);
      append2(div2, t0);
      append2(div2, div1);
      append2(div1, span1);
      append2(span1, a);
      mount_component(discord, a, null);
      append2(a, t1);
      append2(a, span0);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(clickOutside_action = /*clickOutside*/
        ctx[1].call(null, div2));
        mounted = true;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(discord.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(discord.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(discord);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment25(ctx) {
  let div;
  let button;
  let messagesquareheart;
  let t2;
  let current;
  let mounted;
  let dispose;
  messagesquareheart = new message_square_heart_default({ props: { size: "20px" } });
  let if_block = (
    /*isOpen*/
    ctx[0] && create_if_block3(ctx)
  );
  return {
    c() {
      div = element2("div");
      button = element2("button");
      create_component(messagesquareheart.$$.fragment);
      t2 = space();
      if (if_block)
        if_block.c();
      attr(button, "class", "menu-button svelte-4t8k3t");
      attr(div, "class", "menu-container svelte-4t8k3t");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append2(div, button);
      mount_component(messagesquareheart, button, null);
      append2(div, t2);
      if (if_block)
        if_block.m(div, null);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", stop_propagation(
          /*toggleMenu*/
          ctx[2]
        ));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*isOpen*/
        ctx2[0]
      ) {
        if (if_block) {
          if (dirty & /*isOpen*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(messagesquareheart.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(messagesquareheart.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(messagesquareheart);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance25($$self, $$props, $$invalidate) {
  let isOpen = false;
  function clickOutside(node) {
    const handleClick = (event) => {
      const menuButton = document.querySelector(".menu-button");
      if (!node.contains(event.target) && event.target !== menuButton && !(menuButton == null ? void 0 : menuButton.contains(event.target))) {
        $$invalidate(0, isOpen = false);
      }
    };
    setTimeout(
      () => {
        document.addEventListener("click", handleClick);
      },
      0
    );
    return {
      destroy() {
        document.removeEventListener("click", handleClick);
      }
    };
  }
  function toggleMenu(event) {
    event.stopPropagation();
    $$invalidate(0, isOpen = !isOpen);
  }
  return [isOpen, clickOutside, toggleMenu];
}
var GetInTouch = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance25, create_fragment25, safe_not_equal, {}, add_css4);
  }
};
var GetInTouch_default = GetInTouch;

// src/components/RelayText.svelte
function add_css5(target) {
  append_styles(target, "svelte-ycfe1d", ".relay-text.svelte-ycfe1d{fill:var(--text-normal)}");
}
function create_fragment26(ctx) {
  let svg;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "d", "m112.88679 65.94517c-1.8219-.6498-2.8316-1.9996-2.8205-3.7707.019-2.9692 4.2679-9.1564 8.5532-12.4538.8896-.6846 3.2865-2.0796 5.3264-3.1002l3.7089-1.8555 1.1034-2.1157c.6069-1.1636 1.0788-2.1403 1.0487-2.1704-.03-.03-.7517.2969-1.6037.7266-1.7893.9026-3.4923 1.0179-5.6348.3816-1.2664-.376-2.6971-1.5724-3.0511-2.5512-.1036-.2865-.2262-.2926-.6259-.031-1.6133 1.0551-3.9805 2.2931-5.3124 2.7783-3.2045 1.1672-7.1579.5507-8.5509-1.3335l-.5903-.7983-1.2238.7491c-3.1246 1.9126-7.5052 2.5576-9.6905 1.4268-1.3209-.6835-2.1336-1.8529-2.3663-3.405-.099-.6587-.2706-1.1976-.3819-1.1976-.1112 0-.4909.3082-.8437.685-1.1393 1.2168-4.3891 3.211-6.2437 3.8314-4.3168 1.4441-8.0424.1949-8.8532-2.9684-.1823-.7114-.3977-1.2593-.4786-1.2177-8.2088 4.2188-13.1666 5.5617-17.3451 4.6983-7.2318-1.4943-8.5363-7.633-3.2721-15.3969 3.43-5.0586 8.1226-8.1393 12.5368-8.2303 4.2661-.088 6.1851 2.8612 4.6067 7.0798-1.4639 3.9129-6.6553 7.7738-11.3995 8.4781l-1.2322.183-.173.9219c-.2449 1.3054.055 2.3726.8414 2.9909 1.4773 1.162 5.3481.4499 9.169-1.6869 4.0877-2.286 9.2494-6.7459 10.2254-8.8353 2.1729-4.6512 10.3391-19.4528 12.6199-22.8741 1.9649-2.9472 2.9544-3.913 4.6877-4.575 2.2454-.8575 3.8556.1204 3.8556 2.3418 0 1.0627-.8749 2.8756-5.2398 10.8581-4.5459 8.3134-10.5554 20.346-10.9601 21.9446-.372 1.4696-.093 1.8547 1.0954 1.5137 3.1691-.9088 8.5727-5.615 10.728-9.3431 3.192-5.5215 7.5241-8.5901 12.516-8.8657 1.3396-.074 2.6532.01 3.3914.2166 1.585.4437 3.5318 2.2009 3.7762 3.4083.1003.4954.3584.9822.5736 1.0817 1.6112.7453 1.9862 1.0047 2.0682 1.4307.051.2665-.9529 2.6236-2.2318 5.238-1.8799 3.8432-2.328 4.9899-2.3404 5.9886l-.015 1.2352.9261.077c1.132.094 3.2883-1.1349 5.6894-3.243 2.3304-2.0459 3.4794-3.659 6.2257-8.7403 1.3371-2.4739 2.6529-4.8096 2.924-5.1906.7068-.9931 1.8337-1.3742 3.6712-1.2413 1.7839.1291 2.6563.7039 2.6563 1.7502 0 .3631-1.6536 3.8273-3.6747 7.698-3.6147 6.9231-4.2241 8.2285-3.8408 8.2285.3864 0 2.6593-1.4351 4.2082-2.6571 2.9724-2.3449 4.1289-3.8334 6.7129-8.64 3.2167-5.9836 4.0513-6.6961 7.4599-6.3685 1.5037.1444 2.3637.7781 2.3637 1.7416 0 .6971-3.7642 8.1283-7.3844 14.5783-1.1774 2.0975-2.1406 3.9288-2.1406 4.0695 0 1.0032 6.4569-2.0079 10.373-4.8373 1.75083-1.265 2.80833-1.8553 3.32363-1.8553.8396 0 1.9138.8456 1.9138 1.5065 0 1.6136-6.83683 5.3607-15.31743 8.3952l-3.0144 1.0785-3.1147 4.959c-6.6125 10.5277-11.2414 15.4863-16.0267 17.1682-1.6492.5797-2.5036.6042-3.8855.1114zm3.4676-4.0874c2.3533-1.2035 5.0029-4.3759 7.0335-8.4211 1.4729-2.9341 1.2858-3.2801-1.0497-1.9405-2.6054 1.4944-6.0792 5.1835-7.6115 8.0833-1.3391 2.5343-.6792 3.458 1.6277 2.2783zm-13.7433-25.7067c2.0798-1.3888 2.707-2.2251 5.1929-6.9235 1.1337-2.1427 2.4702-4.3736 2.9701-4.9576.4999-.5839.8343-1.1823.7432-1.3297-.3028-.49-1.5733-.2724-2.9201.5001-3.9 2.237-10.6318 12.1845-9.2087 13.6076.4489.4489 1.7491.087 3.2226-.8969zm-39.6413-6.7383c1.4951-.7532 3.4914-2.3885 4.373-3.5822.8778-1.1886.8303-2.7169-.089-2.8472-.9504-.1348-2.84 1.147-4.3353 2.9408-1.4368 1.7237-2.8652 3.8321-2.8652 4.2293 0 .3431 1.5421-.048 2.916-.7407zm-15.7519 34.9397c-7.7618-1.6901-14.6809-7.6649-17.3519-14.9834-1.0082-2.7626-2.5946-8.8926-3.6898-14.2584-.7621-3.7334-1.4567-5.8195-2.0623-6.1938-.1258-.078-.173.4384-.1049 1.147l.1238 1.2883-2.6916 5.648c-3.9954 8.3841-5.3958 10.566-7.4555 11.6168-1.4222.7256-3.7417.6896-5.2712-.082-1.0729-.541-1.1779-.6797-1.1514-1.5213.017-.5465.8143-2.6067 1.945-5.0271 3.1568-6.7568 12.4018-25.1754 13.3068-26.5105 1.1089-1.6358 2.3136-2.186 4.3772-1.9989 1.8988.1722 3.7575 1.0556 3.7575 1.7858 0 .685-.9801 3.23-2.4839 6.4499-.6712 1.437-1.2203 2.6574-1.2203 2.712 0 .2508 2.423.059 3.8048-.3005 2.1083-.5492 3.5885-1.4764 5.2895-3.3138 2.9831-3.2221 3.5133-7.5609 1.1835-9.6842-3.8351-3.4952-12.7275-2.9971-21.5226 1.2055-6.4797 3.0962-10.7971 8.141-11.8606 13.8587-.5183 2.7868-1.354 3.618-2.8384 2.8236-2.234-1.1956-1.5337-5.997 1.651-11.3196 5.1483-8.6044 15.656-14.9768 26.6996-16.192 9.3582-1.0298 17.2345 3.5198 17.8697 10.322.3469 3.7147-1.5827 8.0493-5.1855 11.6487-2.6104 2.6078-4.969 3.9861-7.9877 4.6679l-1.94.4381.8512.2875c1.5709.5307 1.8619 1.0923 3.1019 5.988 2.5245 9.9665 4.9471 14.9264 9.4592 19.3659 6.055 5.9576 14.0611 6.1192 19.4354.3922.7131-.7598 2.2084-2.7055 3.323-4.3238 1.1145-1.6182 2.2218-3.0172 2.4606-3.1088 2.1176-.8126 2.9615 1.5236 1.6137 4.4675-2.2327 4.877-6.6161 9.1629-11.4944 11.2387-4.1481 1.7652-9.8251 2.3621-13.9414 1.4657z");
      attr(svg, "class", "relay-text svelte-ycfe1d");
      attr(
        svg,
        "width",
        /*width*/
        ctx[0]
      );
      attr(
        svg,
        "height",
        /*height*/
        ctx[1]
      );
      attr(svg, "viewBox", "0 0 154.24573 66.293579");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append2(svg, path);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function instance26($$self, $$props, $$invalidate) {
  let { size = 64 } = $$props;
  let width = size;
  let height = size / 2;
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(2, size = $$props2.size);
  };
  return [width, height, size];
}
var RelayText = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance26, create_fragment26, safe_not_equal, { size: 2 }, add_css5);
  }
};
var RelayText_default = RelayText;

// src/components/WelcomeHeader.svelte
function add_css6(target) {
  append_styles(target, "svelte-120r7kg", ".subtitle.svelte-120r7kg{color:var(--text-muted);font-size:1.25rem;margin:0}.description.svelte-120r7kg{color:var(--text-muted);font-size:1rem;max-width:480px;margin:0}");
}
function create_fragment27(ctx) {
  let relaytext;
  let t0;
  let p0;
  let t2;
  let p1;
  let current;
  relaytext = new RelayText_default({ props: { size: 140 } });
  return {
    c() {
      create_component(relaytext.$$.fragment);
      t0 = space();
      p0 = element2("p");
      p0.textContent = "Real-time collaboration in Obsidian";
      t2 = space();
      p1 = element2("p");
      p1.textContent = "Share folders with your team, edit together in real time, and keep your\n	knowledge library exactly how you want it.";
      attr(p0, "class", "subtitle svelte-120r7kg");
      attr(p1, "class", "description svelte-120r7kg");
    },
    m(target, anchor) {
      mount_component(relaytext, target, anchor);
      insert(target, t0, anchor);
      insert(target, p0, anchor);
      insert(target, t2, anchor);
      insert(target, p1, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(relaytext.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(relaytext.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(p0);
        detach(t2);
        detach(p1);
      }
      destroy_component(relaytext, detaching);
    }
  };
}
var WelcomeHeader = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment27, safe_not_equal, {}, add_css6);
  }
};
var WelcomeHeader_default = WelcomeHeader;

// src/components/WelcomeFooter.svelte
var import_obsidian6 = require("obsidian");
function add_css7(target) {
  append_styles(target, "svelte-1kvxms3", ".help-section.svelte-1kvxms3{width:100%;padding:0 2rem;margin-bottom:2rem}.footer.svelte-1kvxms3{padding:0 2rem;margin-bottom:2rem;text-align:center}.help-container.svelte-1kvxms3{position:relative;max-width:640px;margin:0 auto}.why-google.svelte-1kvxms3:hover{background-color:transparent !important;box-shadow:none;color:var(--text-modifier-hover)}.why-google.svelte-1kvxms3{outline:0;color:var(--text-muted);font-size:0.875rem;margin:0;background-color:transparent !important;box-shadow:none;text-decoration-line:var(--link-decoration);padding:0;border:none;cursor:pointer;width:100%;text-align:left}.why-google.svelte-1kvxms3:hover{color:var(--text-normal)}.help-content.svelte-1kvxms3{margin-top:8px;padding:12px 16px;background:var(--color-base-05);border-radius:4px;font-size:0.9em;color:var(--text-muted);box-shadow:inset 0 1px 3px rgba(0, 0, 0, 0.1);text-align:left}.popover.svelte-1kvxms3{position:absolute;z-index:50;width:256px;padding-left:1em;padding-right:1em;font-size:0.875rem;background-color:var(--background-primary);border:1px solid var(--background-modifier-border);border-radius:4px;box-shadow:var(--shadow-s);top:calc(100% + 8px);text-align:left;left:50%;transform:translateX(-50%);opacity:0;visibility:hidden;transition:opacity 0.3s ease,\n			visibility 0.3s ease;transition-delay:0.1s}.popover.visible.svelte-1kvxms3{opacity:1;visibility:visible}.popover.svelte-1kvxms3:not(.visible){transition-delay:0s}.arrow.svelte-1kvxms3{position:absolute;width:8px;height:8px;background-color:var(--background-primary);border-top:1px solid var(--background-modifier-border);border-left:1px solid var(--background-modifier-border);transform:rotate(45deg);top:-5px;right:40px}.discord-link.svelte-1kvxms3{display:inline-flex;align-items:center;justify-content:center;gap:0.5rem;color:var(--text-muted);font-size:0.875rem;margin:0}");
}
function create_else_block3(ctx) {
  let div1;
  let div0;
  let t0;
  let p;
  return {
    c() {
      div1 = element2("div");
      div0 = element2("div");
      t0 = space();
      p = element2("p");
      p.textContent = `${googleHelpText}`;
      attr(div0, "class", "arrow svelte-1kvxms3");
      attr(div1, "class", "popover svelte-1kvxms3");
      toggle_class(
        div1,
        "visible",
        /*isVisible*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append2(div1, div0);
      append2(div1, t0);
      append2(div1, p);
      ctx[9](div1);
    },
    p(ctx2, dirty) {
      if (dirty & /*isVisible*/
      1) {
        toggle_class(
          div1,
          "visible",
          /*isVisible*/
          ctx2[0]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      ctx[9](null);
    }
  };
}
function create_if_block4(ctx) {
  let if_block_anchor;
  let if_block = (
    /*isVisible*/
    ctx[0] && create_if_block_12(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (
        /*isVisible*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_12(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_if_block_12(ctx) {
  let div;
  let p;
  return {
    c() {
      div = element2("div");
      p = element2("p");
      p.textContent = `${googleHelpText}`;
      attr(div, "class", "help-content svelte-1kvxms3");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append2(div, p);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_fragment28(ctx) {
  let div1;
  let div0;
  let button;
  let t1;
  let t2;
  let div2;
  let a;
  let discord;
  let t3;
  let current;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (
      /*isMobile*/
      ctx2[1]
    )
      return create_if_block4;
    return create_else_block3;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  discord = new Discord_default({});
  return {
    c() {
      div1 = element2("div");
      div0 = element2("div");
      button = element2("button");
      button.textContent = "Why sign in with Google?";
      t1 = space();
      if_block.c();
      t2 = space();
      div2 = element2("div");
      a = element2("a");
      create_component(discord.$$.fragment);
      t3 = text2("\n		Join the project on Discord");
      attr(button, "class", "why-google svelte-1kvxms3");
      toggle_class(
        button,
        "mobile",
        /*isMobile*/
        ctx[1]
      );
      attr(div0, "class", "help-container svelte-1kvxms3");
      attr(div1, "class", "help-section svelte-1kvxms3");
      attr(a, "href", "https://discord.system3.md");
      attr(a, "class", "discord-link svelte-1kvxms3");
      attr(div2, "class", "footer svelte-1kvxms3");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append2(div1, div0);
      append2(div0, button);
      ctx[8](button);
      append2(div0, t1);
      if_block.m(div0, null);
      insert(target, t2, anchor);
      insert(target, div2, anchor);
      append2(div2, a);
      mount_component(discord, a, null);
      append2(a, t3);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button,
            "mouseenter",
            /*handleMouseEnter*/
            ctx[4]
          ),
          listen(
            button,
            "mouseleave",
            /*handleMouseLeave*/
            ctx[5]
          ),
          listen(
            button,
            "click",
            /*handleClick*/
            ctx[6]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*isMobile*/
      2) {
        toggle_class(
          button,
          "mobile",
          /*isMobile*/
          ctx2[1]
        );
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div0, null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(discord.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(discord.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
        detach(t2);
        detach(div2);
      }
      ctx[8](null);
      if_block.d();
      destroy_component(discord);
      mounted = false;
      run_all(dispose);
    }
  };
}
var googleHelpText = "We require sign-in because your vault needs to communicate securely with Relay servers for syncing. An identity provider like Google helps to prevent spam accounts. We may add more sign-in options based on user feedback \u2014 let us know in Discord.";
function instance27($$self, $$props, $$invalidate) {
  var _a2;
  let isVisible2 = false;
  let isMobile = false;
  let buttonEl;
  let popoverEl;
  function handleMouseEnter() {
    if (!isMobile) {
      $$invalidate(0, isVisible2 = true);
    }
  }
  function handleMouseLeave() {
    if (!isMobile) {
      $$invalidate(0, isVisible2 = false);
    }
  }
  function handleClick() {
    if (isMobile) {
      $$invalidate(0, isVisible2 = !isVisible2);
    }
  }
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      buttonEl = $$value;
      $$invalidate(2, buttonEl);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      popoverEl = $$value;
      $$invalidate(3, popoverEl);
    });
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*_a*/
    128) {
      $: {
        $$invalidate(1, isMobile = $$invalidate(7, _a2 = import_obsidian6.Platform === null || import_obsidian6.Platform === void 0 ? void 0 : import_obsidian6.Platform.isMobile) !== null && _a2 !== void 0 ? _a2 : false);
      }
    }
  };
  return [
    isVisible2,
    isMobile,
    buttonEl,
    popoverEl,
    handleMouseEnter,
    handleMouseLeave,
    handleClick,
    _a2,
    button_binding,
    div1_binding
  ];
}
var WelcomeFooter = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance27, create_fragment28, safe_not_equal, {}, add_css7);
  }
};
var WelcomeFooter_default = WelcomeFooter;

// src/User.ts
var usercolors = [
  { color: "#30bced", light: "#30bced33" },
  { color: "#6eeb83", light: "#6eeb8333" },
  { color: "#ffbc42", light: "#ffbc4233" },
  { color: "#ecd444", light: "#ecd44433" },
  { color: "#ee6352", light: "#ee635233" },
  { color: "#9ac2c9", light: "#9ac2c933" },
  { color: "#8acb88", light: "#8acb8833" },
  { color: "#1be7ff", light: "#1be7ff33" }
];
var User = class {
  constructor(id2, name, email, picture, token) {
    this.id = id2;
    this.name = name;
    this.email = email;
    this.picture = picture;
    this.token = token;
    this.color = usercolors[uint32() % usercolors.length];
  }
};

// src/components/Avatar.svelte
function add_css8(target) {
  append_styles(target, "svelte-1ym1y1w", ".avatar.svelte-1ym1y1w{position:relative;border-radius:50%;overflow:hidden;display:flex;align-items:center;justify-content:center;background-color:var(--color-base-30)}.initial.svelte-1ym1y1w{color:var(--text-on-accent)}img.svelte-1ym1y1w{width:100%;height:100%;object-fit:cover}");
}
function create_else_block4(ctx) {
  let span;
  let t2;
  return {
    c() {
      span = element2("span");
      t2 = text2(
        /*initial*/
        ctx[5]
      );
      attr(span, "class", "initial svelte-1ym1y1w");
      set_style(
        span,
        "font-size",
        /*fontSize*/
        ctx[4]
      );
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append2(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*initial*/
      32)
        set_data(
          t2,
          /*initial*/
          ctx2[5]
        );
      if (dirty & /*fontSize*/
      16) {
        set_style(
          span,
          "font-size",
          /*fontSize*/
          ctx2[4]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block5(ctx) {
  let img;
  let img_src_value;
  let mounted;
  let dispose;
  return {
    c() {
      img = element2("img");
      if (!src_url_equal(img.src, img_src_value = /*user*/
      ctx[0].picture))
        attr(img, "src", img_src_value);
      attr(
        img,
        "alt",
        /*alt*/
        ctx[1]
      );
      attr(img, "class", "svelte-1ym1y1w");
    },
    m(target, anchor) {
      insert(target, img, anchor);
      if (!mounted) {
        dispose = listen(
          img,
          "error",
          /*handleError*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*user*/
      1 && !src_url_equal(img.src, img_src_value = /*user*/
      ctx2[0].picture)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*alt*/
      2) {
        attr(
          img,
          "alt",
          /*alt*/
          ctx2[1]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(img);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment29(ctx) {
  let div;
  function select_block_type(ctx2, dirty) {
    if (!/*imageError*/
    ctx2[3] && /*user*/
    ctx2[0].picture)
      return create_if_block5;
    return create_else_block4;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div = element2("div");
      if_block.c();
      attr(div, "class", "avatar svelte-1ym1y1w");
      set_style(
        div,
        "width",
        /*size*/
        ctx[2]
      );
      set_style(
        div,
        "height",
        /*size*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_block.m(div, null);
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div, null);
        }
      }
      if (dirty & /*size*/
      4) {
        set_style(
          div,
          "width",
          /*size*/
          ctx2[2]
        );
      }
      if (dirty & /*size*/
      4) {
        set_style(
          div,
          "height",
          /*size*/
          ctx2[2]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if_block.d();
    }
  };
}
function extractUnit(value) {
  var _a2;
  return ((_a2 = value.match(/[a-z]+$/i)) === null || _a2 === void 0 ? void 0 : _a2[0]) || "px";
}
function instance28($$self, $$props, $$invalidate) {
  let initial;
  let unit;
  let fontSize;
  let { user } = $$props;
  let { alt = "Profile picture" } = $$props;
  let { size = "40px" } = $$props;
  let imageError = false;
  function handleError() {
    $$invalidate(3, imageError = true);
  }
  $$self.$$set = ($$props2) => {
    if ("user" in $$props2)
      $$invalidate(0, user = $$props2.user);
    if ("alt" in $$props2)
      $$invalidate(1, alt = $$props2.alt);
    if ("size" in $$props2)
      $$invalidate(2, size = $$props2.size);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*user*/
    1) {
      $:
        $$invalidate(5, initial = user.name ? user.name.charAt(0).toUpperCase() : "?");
    }
    if ($$self.$$.dirty & /*size*/
    4) {
      $:
        $$invalidate(7, unit = extractUnit(size));
    }
    if ($$self.$$.dirty & /*size, unit*/
    132) {
      $:
        $$invalidate(4, fontSize = `${parseFloat(size) / 2}${unit}`);
    }
  };
  return [user, alt, size, imageError, fontSize, initial, handleError, unit];
}
var Avatar = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance28, create_fragment29, safe_not_equal, { user: 0, alt: 1, size: 2 }, add_css8);
  }
};
var Avatar_default = Avatar;

// src/components/AccountSettingItem.svelte
function create_fragment30(ctx) {
  let div3;
  let avatar;
  let t0;
  let div1;
  let div0;
  let t1_value = (
    /*user*/
    (ctx[0].name || "") + ""
  );
  let t1;
  let t2;
  let br;
  let t3;
  let t4_value = (
    /*user*/
    (ctx[0].email || "") + ""
  );
  let t4;
  let t5;
  let div2;
  let current;
  avatar = new Avatar_default({
    props: { size: "2.5em", user: (
      /*user*/
      ctx[0]
    ) }
  });
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  return {
    c() {
      div3 = element2("div");
      create_component(avatar.$$.fragment);
      t0 = space();
      div1 = element2("div");
      div0 = element2("div");
      t1 = text2(t1_value);
      t2 = space();
      br = element2("br");
      t3 = space();
      t4 = text2(t4_value);
      t5 = space();
      div2 = element2("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "setting-item-description");
      attr(div1, "class", "setting-item-info");
      set_style(div1, "display", "grid");
      attr(div2, "class", "setting-item-control");
      attr(div3, "class", "setting-item");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      mount_component(avatar, div3, null);
      append2(div3, t0);
      append2(div3, div1);
      append2(div1, div0);
      append2(div0, t1);
      append2(div0, t2);
      append2(div0, br);
      append2(div0, t3);
      append2(div0, t4);
      append2(div3, t5);
      append2(div3, div2);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      const avatar_changes = {};
      if (dirty & /*user*/
      1)
        avatar_changes.user = /*user*/
        ctx2[0];
      avatar.$set(avatar_changes);
      if ((!current || dirty & /*user*/
      1) && t1_value !== (t1_value = /*user*/
      (ctx2[0].name || "") + ""))
        set_data(t1, t1_value);
      if ((!current || dirty & /*user*/
      1) && t4_value !== (t4_value = /*user*/
      (ctx2[0].email || "") + ""))
        set_data(t4, t4_value);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(avatar.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(avatar.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      destroy_component(avatar);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance29($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { user } = $$props;
  $$self.$$set = ($$props2) => {
    if ("user" in $$props2)
      $$invalidate(0, user = $$props2.user);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [user, $$scope, slots];
}
var AccountSettingItem = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance29, create_fragment30, safe_not_equal, { user: 0 });
  }
};
var AccountSettingItem_default = AccountSettingItem;

// src/components/SettingItemHeading.svelte
var import_obsidian7 = require("obsidian");

// src/components/HelpPopover.svelte
function add_css9(target) {
  append_styles(target, "svelte-5zjjwa", ".help-container.svelte-5zjjwa{position:relative;display:inline-block}button.svelte-5zjjwa{display:flex;align-items:center;justify-content:center;width:24px;height:24px;padding:2px;margin:0;background:transparent;border:none;color:var(--text-muted);box-shadow:none;border-radius:50%}button.svelte-5zjjwa:hover{box-shadow:none;color:var(--icon-color-hover);opacity:var(--icon-opacity-hover);background-color:transparent;border-radius:0}button.svelte-5zjjwa:focus{outline:none;box-shadow:none;color:var(--icon-color-focus)}.popover.svelte-5zjjwa{position:absolute;z-index:50;width:256px;padding:8px;font-size:0.875rem;background-color:var(--background-primary);border:1px solid var(--background-modifier-border);border-radius:4px;box-shadow:var(--shadow-s);top:32px;transition-delay:0.1s}.popover.left.svelte-5zjjwa{right:100%;margin-right:8px}.popover.right.svelte-5zjjwa{left:0}.arrow.svelte-5zjjwa{position:absolute;width:8px;height:8px;background-color:var(--background-primary);border-top:1px solid var(--background-modifier-border);border-left:1px solid var(--background-modifier-border);transform:rotate(45deg);top:-5px}.arrow.left.svelte-5zjjwa{right:8px}.arrow.right.svelte-5zjjwa{left:8px}p.svelte-5zjjwa{margin:0;color:var(--text-normal)}");
}
function create_if_block6(ctx) {
  let div1;
  let div0;
  let t0;
  let p;
  let t1;
  return {
    c() {
      div1 = element2("div");
      div0 = element2("div");
      t0 = space();
      p = element2("p");
      t1 = text2(
        /*helpText*/
        ctx[0]
      );
      attr(div0, "class", "arrow svelte-5zjjwa");
      toggle_class(
        div0,
        "left",
        /*position*/
        ctx[4] === "left"
      );
      toggle_class(
        div0,
        "right",
        /*position*/
        ctx[4] === "right"
      );
      attr(p, "class", "svelte-5zjjwa");
      attr(div1, "class", "popover svelte-5zjjwa");
      toggle_class(
        div1,
        "left",
        /*position*/
        ctx[4] === "left"
      );
      toggle_class(
        div1,
        "right",
        /*position*/
        ctx[4] === "right"
      );
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append2(div1, div0);
      append2(div1, t0);
      append2(div1, p);
      append2(p, t1);
      ctx[9](div1);
    },
    p(ctx2, dirty) {
      if (dirty & /*position*/
      16) {
        toggle_class(
          div0,
          "left",
          /*position*/
          ctx2[4] === "left"
        );
      }
      if (dirty & /*position*/
      16) {
        toggle_class(
          div0,
          "right",
          /*position*/
          ctx2[4] === "right"
        );
      }
      if (dirty & /*helpText*/
      1)
        set_data(
          t1,
          /*helpText*/
          ctx2[0]
        );
      if (dirty & /*position*/
      16) {
        toggle_class(
          div1,
          "left",
          /*position*/
          ctx2[4] === "left"
        );
      }
      if (dirty & /*position*/
      16) {
        toggle_class(
          div1,
          "right",
          /*position*/
          ctx2[4] === "right"
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      ctx[9](null);
    }
  };
}
function create_fragment31(ctx) {
  let div;
  let button;
  let helpcircle;
  let t2;
  let current;
  let mounted;
  let dispose;
  helpcircle = new circle_help_default({ props: { size: 16 } });
  let if_block = (
    /*isVisible*/
    ctx[1] && create_if_block6(ctx)
  );
  return {
    c() {
      div = element2("div");
      button = element2("button");
      create_component(helpcircle.$$.fragment);
      t2 = space();
      if (if_block)
        if_block.c();
      attr(button, "type", "button");
      attr(button, "class", "svelte-5zjjwa");
      attr(div, "class", "help-container svelte-5zjjwa");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append2(div, button);
      mount_component(helpcircle, button, null);
      ctx[8](button);
      append2(div, t2);
      if (if_block)
        if_block.m(div, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button,
            "mouseenter",
            /*handleMouseEnter*/
            ctx[5]
          ),
          listen(
            button,
            "mouseleave",
            /*handleMouseLeave*/
            ctx[6]
          ),
          listen(
            button,
            "click",
            /*handleClick*/
            ctx[7]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*isVisible*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block6(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(helpcircle.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(helpcircle.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(helpcircle);
      ctx[8](null);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance30($$self, $$props, $$invalidate) {
  let { helpText } = $$props;
  let isVisible2 = false;
  let position = "right";
  let buttonEl;
  let popoverEl;
  function handleMouseEnter() {
    $$invalidate(1, isVisible2 = true);
  }
  function handleMouseLeave() {
    $$invalidate(1, isVisible2 = false);
  }
  function handleClick() {
    $$invalidate(1, isVisible2 = !isVisible2);
  }
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      buttonEl = $$value;
      $$invalidate(2, buttonEl);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      popoverEl = $$value;
      $$invalidate(3, popoverEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("helpText" in $$props2)
      $$invalidate(0, helpText = $$props2.helpText);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*isVisible, buttonEl, popoverEl*/
    14) {
      $:
        if (isVisible2 && buttonEl && popoverEl) {
          const buttonRect = buttonEl.getBoundingClientRect();
          const popoverRect = popoverEl.getBoundingClientRect();
          const windowWidth = window.innerWidth;
          $$invalidate(4, position = buttonRect.right + popoverRect.width > windowWidth - 20 ? "left" : "right");
        }
    }
  };
  return [
    helpText,
    isVisible2,
    buttonEl,
    popoverEl,
    position,
    handleMouseEnter,
    handleMouseLeave,
    handleClick,
    button_binding,
    div1_binding
  ];
}
var HelpPopover = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance30, create_fragment31, safe_not_equal, { helpText: 0 }, add_css9);
  }
};
var HelpPopover_default = HelpPopover;

// src/components/SettingItemHeading.svelte
function add_css10(target) {
  append_styles(target, "svelte-1v3t6m3", ".setting-item-name.svelte-1v3t6m3{display:flex;align-items:center;gap:8px}.help-button.svelte-1v3t6m3{display:flex;align-items:center;justify-content:center;width:24px;height:24px;padding:2px !important;margin:0;background:transparent;border:none;color:var(--text-muted);border-radius:50%;-webkit-tap-highlight-color:transparent}@media(hover: hover){.help-button.svelte-1v3t6m3:hover{box-shadow:none;color:var(--text-normal);background:transparent;border-radius:0}}.help-button.svelte-1v3t6m3:active{color:var(--text-normal)}.help-content.svelte-1v3t6m3{margin-top:8px;padding:12px 16px;background:var(--color-base-05);border-radius:4px;font-size:0.9em;color:var(--text-muted);box-shadow:inset 0 1px 3px rgba(0, 0, 0, 0.1)}p.svelte-1v3t6m3{margin:0}");
}
var get_description_slot_changes_1 = (dirty) => ({});
var get_description_slot_context_1 = (ctx) => ({});
var get_description_slot_changes = (dirty) => ({});
var get_description_slot_context = (ctx) => ({});
var get_name_slot_changes = (dirty) => ({});
var get_name_slot_context = (ctx) => ({});
function fallback_block_1(ctx) {
  let t2;
  return {
    c() {
      t2 = text2(
        /*name*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*name*/
      1)
        set_data(
          t2,
          /*name*/
          ctx2[0]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_13(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_2, create_else_block5];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*isMobile*/
      ctx2[3]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_else_block5(ctx) {
  let helppopover;
  let current;
  helppopover = new HelpPopover_default({ props: { helpText: (
    /*helpText*/
    ctx[1]
  ) } });
  return {
    c() {
      create_component(helppopover.$$.fragment);
    },
    m(target, anchor) {
      mount_component(helppopover, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const helppopover_changes = {};
      if (dirty & /*helpText*/
      2)
        helppopover_changes.helpText = /*helpText*/
        ctx2[1];
      helppopover.$set(helppopover_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(helppopover.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(helppopover.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(helppopover, detaching);
    }
  };
}
function create_if_block_2(ctx) {
  let button;
  let helpcircle;
  let current;
  let mounted;
  let dispose;
  helpcircle = new circle_help_default({ props: { size: 16 } });
  return {
    c() {
      button = element2("button");
      create_component(helpcircle.$$.fragment);
      attr(button, "class", "help-button svelte-1v3t6m3");
      attr(
        button,
        "aria-expanded",
        /*isHelpExpanded*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      mount_component(helpcircle, button, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*toggleHelp*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*isHelpExpanded*/
      4) {
        attr(
          button,
          "aria-expanded",
          /*isHelpExpanded*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(helpcircle.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(helpcircle.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      destroy_component(helpcircle);
      mounted = false;
      dispose();
    }
  };
}
function fallback_block(ctx) {
  let div;
  let current;
  const description_slot_template = (
    /*#slots*/
    ctx[7].description
  );
  const description_slot = create_slot(
    description_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_description_slot_context_1
  );
  return {
    c() {
      div = element2("div");
      if (description_slot)
        description_slot.c();
      attr(div, "class", "setting-item-description");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (description_slot) {
        description_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (description_slot) {
        if (description_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            description_slot,
            description_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              description_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_description_slot_changes_1
            ),
            get_description_slot_context_1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(description_slot, local);
      current = true;
    },
    o(local) {
      transition_out(description_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (description_slot)
        description_slot.d(detaching);
    }
  };
}
function create_if_block7(ctx) {
  let div;
  let p;
  let t2;
  return {
    c() {
      div = element2("div");
      p = element2("p");
      t2 = text2(
        /*helpText*/
        ctx[1]
      );
      attr(p, "class", "svelte-1v3t6m3");
      attr(div, "class", "help-content svelte-1v3t6m3");
      toggle_class(
        div,
        "expanded",
        /*isHelpExpanded*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append2(div, p);
      append2(p, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*helpText*/
      2)
        set_data(
          t2,
          /*helpText*/
          ctx2[1]
        );
      if (dirty & /*isHelpExpanded*/
      4) {
        toggle_class(
          div,
          "expanded",
          /*isHelpExpanded*/
          ctx2[2]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_fragment32(ctx) {
  let div3;
  let div1;
  let div0;
  let t0;
  let t1;
  let t2;
  let t3;
  let div2;
  let current;
  const name_slot_template = (
    /*#slots*/
    ctx[7].name
  );
  const name_slot = create_slot(
    name_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_name_slot_context
  );
  const name_slot_or_fallback = name_slot || fallback_block_1(ctx);
  let if_block0 = (
    /*helpText*/
    ctx[1] && create_if_block_13(ctx)
  );
  const description_slot_template = (
    /*#slots*/
    ctx[7].description
  );
  const description_slot = create_slot(
    description_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_description_slot_context
  );
  const description_slot_or_fallback = description_slot || fallback_block(ctx);
  let if_block1 = (
    /*helpText*/
    ctx[1] && /*isHelpExpanded*/
    ctx[2] && /*isMobile*/
    ctx[3] && create_if_block7(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  return {
    c() {
      div3 = element2("div");
      div1 = element2("div");
      div0 = element2("div");
      if (name_slot_or_fallback)
        name_slot_or_fallback.c();
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (description_slot_or_fallback)
        description_slot_or_fallback.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      div2 = element2("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "setting-item-name svelte-1v3t6m3");
      attr(div1, "class", "setting-item-info");
      attr(div2, "class", "setting-item-control");
      attr(div3, "class", "setting-item setting-item-heading");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append2(div3, div1);
      append2(div1, div0);
      if (name_slot_or_fallback) {
        name_slot_or_fallback.m(div0, null);
      }
      append2(div0, t0);
      if (if_block0)
        if_block0.m(div0, null);
      append2(div1, t1);
      if (description_slot_or_fallback) {
        description_slot_or_fallback.m(div1, null);
      }
      append2(div1, t2);
      if (if_block1)
        if_block1.m(div1, null);
      append2(div3, t3);
      append2(div3, div2);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (name_slot) {
        if (name_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            name_slot,
            name_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              name_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_name_slot_changes
            ),
            get_name_slot_context
          );
        }
      } else {
        if (name_slot_or_fallback && name_slot_or_fallback.p && (!current || dirty & /*name*/
        1)) {
          name_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (
        /*helpText*/
        ctx2[1]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*helpText*/
          2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_13(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, null);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (description_slot) {
        if (description_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            description_slot,
            description_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              description_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_description_slot_changes
            ),
            get_description_slot_context
          );
        }
      } else {
        if (description_slot_or_fallback && description_slot_or_fallback.p && (!current || dirty & /*$$scope*/
        64)) {
          description_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (
        /*helpText*/
        ctx2[1] && /*isHelpExpanded*/
        ctx2[2] && /*isMobile*/
        ctx2[3]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block7(ctx2);
          if_block1.c();
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(name_slot_or_fallback, local);
      transition_in(if_block0);
      transition_in(description_slot_or_fallback, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(name_slot_or_fallback, local);
      transition_out(if_block0);
      transition_out(description_slot_or_fallback, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      if (name_slot_or_fallback)
        name_slot_or_fallback.d(detaching);
      if (if_block0)
        if_block0.d();
      if (description_slot_or_fallback)
        description_slot_or_fallback.d(detaching);
      if (if_block1)
        if_block1.d();
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance31($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  var _a2;
  let { name = "" } = $$props;
  let { helpText = void 0 } = $$props;
  let isHelpExpanded = false;
  let isMobile = false;
  function toggleHelp() {
    if (isMobile) {
      $$invalidate(2, isHelpExpanded = !isHelpExpanded);
    }
  }
  $$self.$$set = ($$props2) => {
    if ("name" in $$props2)
      $$invalidate(0, name = $$props2.name);
    if ("helpText" in $$props2)
      $$invalidate(1, helpText = $$props2.helpText);
    if ("$$scope" in $$props2)
      $$invalidate(6, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*_a*/
    32) {
      $: {
        $$invalidate(3, isMobile = $$invalidate(5, _a2 = import_obsidian7.Platform === null || import_obsidian7.Platform === void 0 ? void 0 : import_obsidian7.Platform.isMobile) !== null && _a2 !== void 0 ? _a2 : false);
      }
    }
  };
  return [name, helpText, isHelpExpanded, isMobile, toggleHelp, _a2, $$scope, slots];
}
var SettingItemHeading = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance31, create_fragment32, safe_not_equal, { name: 0, helpText: 1 }, add_css10);
  }
};
var SettingItemHeading_default = SettingItemHeading;

// node_modules/svelte/src/runtime/store/index.js
var subscriber_queue = [];
function readable(value, start) {
  return {
    subscribe: writable(value, start).subscribe
  };
}
function writable(value, start = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i2 = 0; i2 < subscriber_queue.length; i2 += 2) {
            subscriber_queue[i2][0](subscriber_queue[i2 + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set(fn(value));
  }
  function subscribe3(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set, update2) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe3 };
}
function derived(stores, fn, initial_value) {
  const single = !Array.isArray(stores);
  const stores_array = single ? [stores] : stores;
  if (!stores_array.every(Boolean)) {
    throw new Error("derived() expects stores as input, got a falsy value");
  }
  const auto = fn.length < 2;
  return readable(initial_value, (set, update2) => {
    let started = false;
    const values = [];
    let pending = 0;
    let cleanup = noop;
    const sync = () => {
      if (pending) {
        return;
      }
      cleanup();
      const result = fn(single ? values[0] : values, set, update2);
      if (auto) {
        set(result);
      } else {
        cleanup = is_function(result) ? result : noop;
      }
    };
    const unsubscribers = stores_array.map(
      (store, i2) => subscribe2(
        store,
        (value) => {
          values[i2] = value;
          pending &= ~(1 << i2);
          if (started) {
            sync();
          }
        },
        () => {
          pending |= 1 << i2;
        }
      )
    );
    started = true;
    sync();
    return function stop() {
      run_all(unsubscribers);
      cleanup();
      started = false;
    };
  });
}

// src/customFetch.ts
var import_obsidian8 = require("obsidian");
var import_obsidian9 = require("obsidian");
if (globalThis.Response === void 0 || globalThis.Headers === void 0) {
  try {
    console.warn(
      "[Relay] Polyfilling Fetch API (Electron Bug: https://github.com/electron/electron/pull/42419)"
    );
    if (globalThis.blinkfetch) {
      globalThis.fetch = globalThis.blinkFetch;
      const keys2 = ["fetch", "Response", "FormData", "Request", "Headers"];
      for (const key of keys2) {
        globalThis[key] = globalThis[`blink${key}`];
      }
    }
  } catch (e2) {
    console.error(e2);
  }
}
if (globalThis.EventSource === void 0) {
  if (import_obsidian9.Platform.isMobile) {
    console.warn("[Relay] Polyfilling EventSource API required, but unable to polyfill on Mobile");
  } else {
    console.warn("[Relay] Polyfilling EventSource API");
    globalThis.EventSource = require_eventsource();
  }
}
var customFetch = async (url, config) => {
  const urlString = url instanceof URL ? url.toString() : url;
  const method = (config == null ? void 0 : config.method) || "GET";
  const headers = Object.assign({}, config == null ? void 0 : config.headers, {
    "Relay-Version": "0.4.5"
  });
  const requestParams = {
    url: urlString,
    method,
    body: config == null ? void 0 : config.body,
    headers,
    throw: false
  };
  let response = void 0;
  response = await (0, import_obsidian8.requestUrl)(requestParams);
  if (!response.arrayBuffer.byteLength) {
    return new Response(null, {
      status: response.status,
      statusText: response.status.toString(),
      headers: new Headers(response.headers)
    });
  }
  const fetchResponse = new Response(response.arrayBuffer, {
    status: response.status,
    statusText: response.status.toString(),
    headers: new Headers(response.headers)
  });
  const json = async () => JSON.parse(response.text);
  Object.defineProperty(fetchResponse, "json", {
    value: json
  });
  const level = response.status >= 500 ? "error" : response.status >= 400 ? "warn" : "debug";
  const response_text = response.text;
  let response_json;
  try {
    response_json = JSON.parse(response_text);
  } catch (e2) {
  }
  curryLog("[CustomFetch]", level)(
    response.status.toString(),
    method,
    urlString,
    response_json || response_text
  );
  if (response.status >= 500) {
    throw new Error(response_text);
  }
  return fetchResponse;
};

// src/components/LoggedIn.svelte
function add_css11(target) {
  append_styles(target, "svelte-16zgfvu", '.continue.svelte-16zgfvu{font-weight:600;font-size:larger;margin-top:0;margin-bottom:0px}.link.svelte-16zgfvu{color:var(--text-muted)}.link.svelte-16zgfvu:hover{color:var(--text-normal)}.not-working.svelte-16zgfvu{margin-top:0px;margin-bottom:0px;color:var(--text-faint);font-size:0.75em}.link-button.svelte-16zgfvu{box-shadow:none;background:none;border:none;padding:0;font:inherit;text-decoration:underline}button.link-button.svelte-16zgfvu:hover{box-shadow:none;color:var(--text-normal)}button.link.link-button.svelte-16zgfvu{height:auto;padding:0;color:var(--text-faint)}.welcome.svelte-16zgfvu{display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center;padding:7rem 2rem 1rem 2rem;max-width:640px;margin:0 auto;gap:2rem}.google-sign-in-button.svelte-16zgfvu{height:unset;padding:12px 16px 12px 42px !important;border:none;border-radius:3px;box-shadow:0 -1px 0 rgba(0, 0, 0, 0.04),\n			0 1px 1px rgba(0, 0, 0, 0.25);color:var(--text-color);font-size:14px;font-weight:500;font-family:-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,\n			Ubuntu, Cantarell, "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif;background-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTgiIGhlaWdodD0iMTgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNMTcuNiA5LjJsLS4xLTEuOEg5djMuNGg0LjhDMTMuNiAxMiAxMyAxMyAxMiAxMy42djIuMmgzYTguOCA4LjggMCAwIDAgMi42LTYuNnoiIGZpbGw9IiM0Mjg1RjQiIGZpbGwtcnVsZT0ibm9uemVybyIvPjxwYXRoIGQ9Ik05IDE4YzIuNCAwIDQuNS0uOCA2LTIuMmwtMy0yLjJhNS40IDUuNCAwIDAgMS04LTIuOUgxVjEzYTkgOSAwIDAgMCA4IDV6IiBmaWxsPSIjMzRBODUzIiBmaWxsLXJ1bGU9Im5vbnplcm8iLz48cGF0aCBkPSJNNCAxMC43YTUuNCA1LjQgMCAwIDEgMC0zLjRWNUgxYTkgOSAwIDAgMCAwIDhsMy0yLjN6IiBmaWxsPSIjRkJCQzA1IiBmaWxsLXJ1bGU9Im5vbnplcm8iLz48cGF0aCBkPSJNOSAzLjZjMS4zIDAgMi41LjQgMy40IDEuM0wxNSAyLjNBOSA5IDAgMCAwIDEgNWwzIDIuNGE1LjQgNS40IDAgMCAxIDUtMy43eiIgZmlsbD0iI0VBNDMzNSIgZmlsbC1ydWxlPSJub256ZXJvIi8+PHBhdGggZD0iTTAgMGgxOHYxOEgweiIvPjwvZz48L3N2Zz4=);background-color:var(--background-secondary);background-repeat:no-repeat;background-position:12px 11px}.google-sign-in-button.svelte-16zgfvu:hover{box-shadow:0 -1px 0 rgba(0, 0, 0, 0.04),\n			0 2px 4px rgba(0, 0, 0, 0.25)}.google-sign-in-button.svelte-16zgfvu:disabled{cursor:unset;filter:grayscale(100%);box-shadow:0 -1px 0 rgba(0, 0, 0, 0.04),\n			0 1px 1px rgba(0, 0, 0, 0.25)}');
}
function create_else_block6(ctx) {
  let div;
  let welcomeheader;
  let t0;
  let t1;
  let t2;
  let welcomefooter;
  let current;
  welcomeheader = new WelcomeHeader_default({});
  function select_block_type_1(ctx2, dirty) {
    if (
      /*$automaticFlow*/
      ctx2[3]
    )
      return create_if_block_4;
    return create_else_block_1;
  }
  let current_block_type = select_block_type_1(ctx, [-1, -1]);
  let if_block0 = current_block_type(ctx);
  function select_block_type_2(ctx2, dirty) {
    if (
      /*$error*/
      ctx2[5]
    )
      return create_if_block_14;
    if (
      /*$pending*/
      ctx2[4]
    )
      return create_if_block_3;
  }
  let current_block_type_1 = select_block_type_2(ctx, [-1, -1]);
  let if_block1 = current_block_type_1 && current_block_type_1(ctx);
  welcomefooter = new WelcomeFooter_default({});
  return {
    c() {
      div = element2("div");
      create_component(welcomeheader.$$.fragment);
      t0 = space();
      if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      create_component(welcomefooter.$$.fragment);
      attr(div, "class", "welcome svelte-16zgfvu");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(welcomeheader, div, null);
      append2(div, t0);
      if_block0.m(div, null);
      append2(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      insert(target, t2, anchor);
      mount_component(welcomefooter, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2, dirty)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div, t1);
        }
      }
      if (current_block_type_1 === (current_block_type_1 = select_block_type_2(ctx2, dirty)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if (if_block1)
          if_block1.d(1);
        if_block1 = current_block_type_1 && current_block_type_1(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(div, null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(welcomeheader.$$.fragment, local);
      transition_in(welcomefooter.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(welcomeheader.$$.fragment, local);
      transition_out(welcomefooter.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t2);
      }
      destroy_component(welcomeheader);
      if_block0.d();
      if (if_block1) {
        if_block1.d();
      }
      destroy_component(welcomefooter, detaching);
    }
  };
}
function create_if_block8(ctx) {
  let settingitemheading0;
  let t0;
  let settingitemheading1;
  let t1;
  let accountsettingitem;
  let t2;
  let current;
  settingitemheading0 = new SettingItemHeading_default({
    props: {
      $$slots: {
        name: [create_name_slot],
        default: [create_default_slot_1]
      },
      $$scope: { ctx }
    }
  });
  settingitemheading1 = new SettingItemHeading_default({ props: { name: "Account" } });
  accountsettingitem = new AccountSettingItem_default({
    props: {
      user: (
        /*$lm*/
        ctx[2].user
      ),
      $$slots: { default: [create_default_slot20] },
      $$scope: { ctx }
    }
  });
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[23],
    null
  );
  return {
    c() {
      create_component(settingitemheading0.$$.fragment);
      t0 = space();
      create_component(settingitemheading1.$$.fragment);
      t1 = space();
      create_component(accountsettingitem.$$.fragment);
      t2 = space();
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      mount_component(settingitemheading0, target, anchor);
      insert(target, t0, anchor);
      mount_component(settingitemheading1, target, anchor);
      insert(target, t1, anchor);
      mount_component(accountsettingitem, target, anchor);
      insert(target, t2, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      const settingitemheading0_changes = {};
      if (dirty[0] & /*$$scope*/
      8388608) {
        settingitemheading0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitemheading0.$set(settingitemheading0_changes);
      const accountsettingitem_changes = {};
      if (dirty[0] & /*$lm*/
      4)
        accountsettingitem_changes.user = /*$lm*/
        ctx2[2].user;
      if (dirty[0] & /*$$scope*/
      8388608) {
        accountsettingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      accountsettingitem.$set(accountsettingitem_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        8388608)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[23],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[23]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[23],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitemheading0.$$.fragment, local);
      transition_in(settingitemheading1.$$.fragment, local);
      transition_in(accountsettingitem.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(settingitemheading0.$$.fragment, local);
      transition_out(settingitemheading1.$$.fragment, local);
      transition_out(accountsettingitem.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
      }
      destroy_component(settingitemheading0, detaching);
      destroy_component(settingitemheading1, detaching);
      destroy_component(accountsettingitem, detaching);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_else_block_1(ctx) {
  let a;
  let button;
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      a = element2("a");
      button = element2("button");
      t2 = text2("Sign in with Google");
      attr(button, "class", "google-sign-in-button svelte-16zgfvu");
      button.disabled = /*$pending*/
      ctx[4];
      attr(
        a,
        "href",
        /*$url*/
        ctx[1]
      );
      attr(a, "target", "_blank");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append2(a, button);
      append2(button, t2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler_2*/
          ctx[20]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$pending*/
      16) {
        button.disabled = /*$pending*/
        ctx2[4];
      }
      if (dirty[0] & /*$url*/
      2) {
        attr(
          a,
          "href",
          /*$url*/
          ctx2[1]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(a);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_4(ctx) {
  let button;
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      button = element2("button");
      t2 = text2("Sign in with Google");
      attr(button, "class", "google-sign-in-button svelte-16zgfvu");
      button.disabled = /*$pending*/
      ctx[4];
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append2(button, t2);
      if (!mounted) {
        dispose = listen(button, "click", (0, import_obsidian10.debounce)(
          /*click_handler_1*/
          ctx[19]
        ));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$pending*/
      16) {
        button.disabled = /*$pending*/
        ctx2[4];
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_3(ctx) {
  let div;
  let p0;
  let t1;
  let p1;
  let t2;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      div = element2("div");
      p0 = element2("p");
      p0.textContent = "Continue in your browser...";
      t1 = space();
      p1 = element2("p");
      t2 = text2("Not working?\n					");
      button = element2("button");
      button.textContent = "(try again)";
      attr(p0, "class", "continue svelte-16zgfvu");
      attr(button, "class", "link link-button svelte-16zgfvu");
      attr(p1, "class", "not-working svelte-16zgfvu");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append2(div, p0);
      append2(div, t1);
      append2(div, p1);
      append2(p1, t2);
      append2(p1, button);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler_4*/
          ctx[22]
        );
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_14(ctx) {
  let p;
  let t0;
  let t1;
  let br;
  let t2;
  let if_block = (
    /*$timedOut*/
    ctx[6] && create_if_block_22(ctx)
  );
  return {
    c() {
      p = element2("p");
      t0 = text2(
        /*$error*/
        ctx[5]
      );
      t1 = text2(".");
      br = element2("br");
      t2 = space();
      if (if_block)
        if_block.c();
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append2(p, t0);
      append2(p, t1);
      append2(p, br);
      append2(p, t2);
      if (if_block)
        if_block.m(p, null);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$error*/
      32)
        set_data(
          t0,
          /*$error*/
          ctx2[5]
        );
      if (
        /*$timedOut*/
        ctx2[6]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_22(ctx2);
          if_block.c();
          if_block.m(p, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
      if (if_block)
        if_block.d();
    }
  };
}
function create_if_block_22(ctx) {
  let t0;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      t0 = text2("Already logged in? ");
      button = element2("button");
      button.textContent = "(click here)";
      attr(button, "class", "link link-button svelte-16zgfvu");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", (0, import_obsidian10.debounce)(
          /*click_handler_3*/
          ctx[21]
        ));
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_1(ctx) {
  let getintouch;
  let current;
  getintouch = new GetInTouch_default({});
  return {
    c() {
      create_component(getintouch.$$.fragment);
    },
    m(target, anchor) {
      mount_component(getintouch, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(getintouch.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(getintouch.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(getintouch, detaching);
    }
  };
}
function create_name_slot(ctx) {
  let relaytext;
  let current;
  relaytext = new RelayText_default({ props: { slot: "name" } });
  return {
    c() {
      create_component(relaytext.$$.fragment);
    },
    m(target, anchor) {
      mount_component(relaytext, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(relaytext.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(relaytext.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(relaytext, detaching);
    }
  };
}
function create_default_slot20(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element2("button");
      button.textContent = "Logout";
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", (0, import_obsidian10.debounce)(
          /*click_handler*/
          ctx[18]
        ));
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment33(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block8, create_else_block6];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$lm*/
      ctx2[2].hasUser && /*$lm*/
      ctx2[2].user
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function getResponse() {
  try {
    return Response.toString();
  } catch (e2) {
    return "undefined";
  }
}
function getFetch() {
  try {
    return fetch.toString();
  } catch (e2) {
    return "undefined";
  }
}
function getUsingBlink() {
  try {
    return (globalThis === null || globalThis === void 0 ? void 0 : globalThis.blinkfetch) !== void 0 ? "Yes" : "No";
  } catch (e2) {
    return "No";
  }
}
function instance32($$self, $$props, $$invalidate) {
  let $useCustomFetch;
  let $url;
  let $lm, $$unsubscribe_lm = noop, $$subscribe_lm = () => ($$unsubscribe_lm(), $$unsubscribe_lm = subscribe2(lm, ($$value) => $$invalidate(2, $lm = $$value)), lm);
  let $automaticFlow;
  let $pending;
  let $error;
  let $timedOut;
  $$self.$$.on_destroy.push(() => $$unsubscribe_lm());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { plugin } = $$props;
  let lm;
  let automaticFlow = writable(!import_obsidian10.Platform.isIosApp);
  component_subscribe($$self, automaticFlow, (value) => $$invalidate(3, $automaticFlow = value));
  let pending = writable(false);
  component_subscribe($$self, pending, (value) => $$invalidate(4, $pending = value));
  $$subscribe_lm(lm = plugin.loginManager);
  let timedOut = writable(false);
  component_subscribe($$self, timedOut, (value) => $$invalidate(6, $timedOut = value));
  let success = writable(false);
  let useCustomFetch = writable(true);
  component_subscribe($$self, useCustomFetch, (value) => $$invalidate(26, $useCustomFetch = value));
  let url = writable("please wait...");
  component_subscribe($$self, url, (value) => $$invalidate(1, $url = value));
  let provider;
  let authWithCode;
  let error = writable("");
  component_subscribe($$self, error, (value) => $$invalidate(5, $error = value));
  let debugLogs = writable(plugin.settings.debugging);
  function toggleDebug() {
    debugLogs.set(plugin.toggleDebugging(true));
  }
  function logout() {
    return __awaiter(this, void 0, void 0, function* () {
      plugin.loginManager.logout();
      success.set(false);
      timedOut.set(false);
    });
  }
  function login() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        yield plugin.loginManager.login();
      } catch (e2) {
        automaticFlow.set(false);
        success.set(false);
        if ($url && $url !== "please wait...") {
          window.open($url, "_blank");
          poll();
        }
      }
    });
  }
  const responseImpl = writable(getResponse());
  const fetchImpl = writable(getFetch());
  const usingBlink = writable(getUsingBlink());
  const anyPb = writable(plugin.loginManager.pb);
  function refresh2() {
    responseImpl.set(getResponse());
    fetchImpl.set(getFetch());
    usingBlink.set(getUsingBlink());
    anyPb.set(plugin.loginManager.pb);
  }
  function initiate() {
    try {
      const whichFetch = $useCustomFetch ? customFetch : fetch;
      provider = void 0;
      url.set("please wait...");
      lm.initiateManualOAuth2CodeFlow(whichFetch).then(([url_, provider_, authWithCode_]) => {
        provider = provider_;
        authWithCode = authWithCode_;
        url.set(url_);
      }).catch((e2) => {
        let message = e2.message;
        message = message + "\n" + getResponse();
        error.set(message);
        throw e2;
      });
    } catch (e2) {
      error.set(e2.message);
    }
  }
  onMount(() => {
    success.set(false);
    initiate();
  });
  function poll() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!provider || !authWithCode) {
        return;
      }
      return yield plugin.loginManager.poll(provider, authWithCode).then((authRecord) => {
        success.set(true);
        pending.set(false);
        error.set("");
      }).catch((e2) => {
        timedOut.set(true);
        pending.set(false);
        success.set(false);
        error.set(e2.message);
      });
    });
  }
  function selectText(event) {
    const inputEl = event.target;
    inputEl.focus();
    inputEl.select();
    navigator.clipboard.writeText(inputEl.value).then(() => new import_obsidian10.Notice("Invite link copied")).catch((err) => {
    });
    poll();
  }
  const click_handler = () => {
    logout();
  };
  const click_handler_1 = async () => {
    pending.set(true);
    await login();
  };
  const click_handler_2 = () => {
    pending.set(true);
    poll();
  };
  const click_handler_3 = () => {
    poll();
  };
  const click_handler_4 = () => {
    pending.set(false);
    automaticFlow.set(false);
  };
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(16, plugin = $$props2.plugin);
    if ("$$scope" in $$props2)
      $$invalidate(23, $$scope = $$props2.$$scope);
  };
  return [
    lm,
    $url,
    $lm,
    $automaticFlow,
    $pending,
    $error,
    $timedOut,
    automaticFlow,
    pending,
    timedOut,
    useCustomFetch,
    url,
    error,
    logout,
    login,
    poll,
    plugin,
    slots,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    click_handler_4,
    $$scope
  ];
}
var LoggedIn = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance32, create_fragment33, safe_not_equal, { plugin: 16 }, add_css11, [-1, -1]);
  }
};
var LoggedIn_default = LoggedIn;

// src/components/SettingItem.svelte
function get_each_context2(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i2];
  return child_ctx;
}
var get_description_slot_changes2 = (dirty) => ({});
var get_description_slot_context2 = (ctx) => ({});
var get_name_slot_changes2 = (dirty) => ({});
var get_name_slot_context2 = (ctx) => ({});
function fallback_block_12(ctx) {
  let t2;
  return {
    c() {
      t2 = text2(
        /*name*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*name*/
      1)
        set_data(
          t2,
          /*name*/
          ctx2[0]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block9(ctx) {
  let each_1_anchor;
  let each_value = ensure_array_like(
    /*itemDescriptionLines*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block2(get_each_context2(ctx, each_value, i2));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*itemDescriptionLines*/
      2) {
        each_value = ensure_array_like(
          /*itemDescriptionLines*/
          ctx2[1]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block2(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block2(ctx) {
  let div;
  return {
    c() {
      div = element2("div");
      div.textContent = `${/*itemDescriptionLine*/
      ctx[5]} `;
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function fallback_block2(ctx) {
  let if_block_anchor;
  let if_block = (
    /*itemDescriptionLines*/
    ctx[1].length > 0 && create_if_block9(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (
        /*itemDescriptionLines*/
        ctx2[1].length > 0
      )
        if_block.p(ctx2, dirty);
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_fragment34(ctx) {
  let div4;
  let div2;
  let div0;
  let t0;
  let div1;
  let t1;
  let div3;
  let current;
  const name_slot_template = (
    /*#slots*/
    ctx[4].name
  );
  const name_slot = create_slot(
    name_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    get_name_slot_context2
  );
  const name_slot_or_fallback = name_slot || fallback_block_12(ctx);
  const description_slot_template = (
    /*#slots*/
    ctx[4].description
  );
  const description_slot = create_slot(
    description_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    get_description_slot_context2
  );
  const description_slot_or_fallback = description_slot || fallback_block2(ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      div4 = element2("div");
      div2 = element2("div");
      div0 = element2("div");
      if (name_slot_or_fallback)
        name_slot_or_fallback.c();
      t0 = space();
      div1 = element2("div");
      if (description_slot_or_fallback)
        description_slot_or_fallback.c();
      t1 = space();
      div3 = element2("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "setting-item-name");
      set_style(div0, "display", "grid");
      set_style(div0, "align-items", "center");
      attr(div1, "class", "setting-item-description");
      attr(div2, "class", "setting-item-info");
      set_style(div2, "display", "grid");
      attr(div3, "class", "setting-item-control");
      attr(div4, "class", "setting-item");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append2(div4, div2);
      append2(div2, div0);
      if (name_slot_or_fallback) {
        name_slot_or_fallback.m(div0, null);
      }
      append2(div2, t0);
      append2(div2, div1);
      if (description_slot_or_fallback) {
        description_slot_or_fallback.m(div1, null);
      }
      append2(div4, t1);
      append2(div4, div3);
      if (default_slot) {
        default_slot.m(div3, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (name_slot) {
        if (name_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            name_slot,
            name_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              name_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              get_name_slot_changes2
            ),
            get_name_slot_context2
          );
        }
      } else {
        if (name_slot_or_fallback && name_slot_or_fallback.p && (!current || dirty & /*name*/
        1)) {
          name_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (description_slot) {
        if (description_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            description_slot,
            description_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              description_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              get_description_slot_changes2
            ),
            get_description_slot_context2
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(name_slot_or_fallback, local);
      transition_in(description_slot_or_fallback, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(name_slot_or_fallback, local);
      transition_out(description_slot_or_fallback, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
      if (name_slot_or_fallback)
        name_slot_or_fallback.d(detaching);
      if (description_slot_or_fallback)
        description_slot_or_fallback.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance33($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { name = "" } = $$props;
  let { description } = $$props;
  const itemDescriptionLines = description !== void 0 ? description.split("\n") : [];
  $$self.$$set = ($$props2) => {
    if ("name" in $$props2)
      $$invalidate(0, name = $$props2.name);
    if ("description" in $$props2)
      $$invalidate(2, description = $$props2.description);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [name, itemDescriptionLines, description, $$scope, slots];
}
var SettingItem = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance33, create_fragment34, safe_not_equal, { name: 0, description: 2 });
  }
};
var SettingItem_default = SettingItem;

// src/components/SlimSettingItem.svelte
function add_css12(target) {
  append_styles(target, "svelte-tyruzk", ".setting-item-control.svelte-tyruzk{width:unset !important;margin-top:unset !important}.setting-item.svelte-tyruzk{flex-direction:unset !important;align-items:flex-start}.setting-item-info.svelte-tyruzk{min-width:0;margin-top:auto;margin-bottom:auto}.setting-item-name.svelte-tyruzk{min-width:0}.truncate.svelte-tyruzk *{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}");
}
var get_description_slot_changes3 = (dirty) => ({});
var get_description_slot_context3 = (ctx) => ({});
var get_name_slot_changes3 = (dirty) => ({});
var get_name_slot_context3 = (ctx) => ({});
function fallback_block3(ctx) {
  let t2;
  return {
    c() {
      t2 = text2(
        /*name*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*name*/
      1)
        set_data(
          t2,
          /*name*/
          ctx2[0]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_fragment35(ctx) {
  let div3;
  let div1;
  let div0;
  let t0;
  let t1;
  let div2;
  let current;
  const name_slot_template = (
    /*#slots*/
    ctx[2].name
  );
  const name_slot = create_slot(
    name_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    get_name_slot_context3
  );
  const name_slot_or_fallback = name_slot || fallback_block3(ctx);
  const description_slot_template = (
    /*#slots*/
    ctx[2].description
  );
  const description_slot = create_slot(
    description_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    get_description_slot_context3
  );
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  return {
    c() {
      div3 = element2("div");
      div1 = element2("div");
      div0 = element2("div");
      if (name_slot_or_fallback)
        name_slot_or_fallback.c();
      t0 = space();
      if (description_slot)
        description_slot.c();
      t1 = space();
      div2 = element2("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "setting-item-name truncate svelte-tyruzk");
      attr(div1, "class", "setting-item-info svelte-tyruzk");
      attr(div2, "class", "setting-item-control svelte-tyruzk");
      attr(div3, "class", "setting-item svelte-tyruzk");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append2(div3, div1);
      append2(div1, div0);
      if (name_slot_or_fallback) {
        name_slot_or_fallback.m(div0, null);
      }
      append2(div3, t0);
      if (description_slot) {
        description_slot.m(div3, null);
      }
      append2(div3, t1);
      append2(div3, div2);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (name_slot) {
        if (name_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            name_slot,
            name_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              name_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              get_name_slot_changes3
            ),
            get_name_slot_context3
          );
        }
      } else {
        if (name_slot_or_fallback && name_slot_or_fallback.p && (!current || dirty & /*name*/
        1)) {
          name_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (description_slot) {
        if (description_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            description_slot,
            description_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              description_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              get_description_slot_changes3
            ),
            get_description_slot_context3
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(name_slot_or_fallback, local);
      transition_in(description_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(name_slot_or_fallback, local);
      transition_out(description_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      if (name_slot_or_fallback)
        name_slot_or_fallback.d(detaching);
      if (description_slot)
        description_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance34($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { name = "" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("name" in $$props2)
      $$invalidate(0, name = $$props2.name);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [name, $$scope, slots];
}
var SlimSettingItem = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance34, create_fragment35, safe_not_equal, { name: 0 }, add_css12);
  }
};
var SlimSettingItem_default = SlimSettingItem;

// src/components/SettingsControl.svelte
function add_css13(target) {
  append_styles(target, "svelte-y529x8", ".extra-setting-button.svelte-y529x8:focus{outline:none;box-shadow:none;color:var(--icon-color-focus)}.extra-setting-button.svelte-y529x8:hover{box-shadow:none;opacity:var(--icon-opacity-hover);color:var(--icon-color-hover);background-color:var(--background-modifier-hover)}");
}
function create_fragment36(ctx) {
  let div;
  let settings;
  let current;
  let mounted;
  let dispose;
  settings = new settings_default({
    props: {
      class: "svg-icon lucide-settings",
      props: { class: "svg-icon lucide-settings" }
    }
  });
  return {
    c() {
      div = element2("div");
      create_component(settings.$$.fragment);
      attr(div, "class", "clickable-icon extra-setting-button svelte-y529x8");
      attr(div, "aria-label", "Options");
      attr(div, "role", "button");
      attr(div, "tabindex", "0");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(settings, div, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            div,
            "click",
            /*handleSettingsClick*/
            ctx[0]
          ),
          listen(
            div,
            "keydown",
            /*handleSettingsClick*/
            ctx[0]
          )
        ];
        mounted = true;
      }
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(settings.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settings.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(settings);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance35($$self) {
  const dispatch = createEventDispatcher();
  function handleSettingsClick(event) {
    if (event instanceof MouseEvent || event instanceof KeyboardEvent && (event.key === "Enter" || event.key === " ")) {
      dispatch("settings");
    }
  }
  return [handleSettingsClick];
}
var SettingsControl = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance35, create_fragment36, safe_not_equal, {}, add_css13);
  }
};
var SettingsControl_default = SettingsControl;

// src/components/Satellite.svelte
function create_fragment37(ctx) {
  let span;
  let satellite;
  let t2;
  let current;
  let mounted;
  let dispose;
  satellite = new satellite_default({
    props: {
      class: "svg-icon",
      style: "margin-right: .2em; flex-shrink: 0;"
    }
  });
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  return {
    c() {
      span = element2("span");
      create_component(satellite.$$.fragment);
      t2 = space();
      if (default_slot)
        default_slot.c();
      attr(span, "role", "button");
      attr(span, "tabindex", "0");
      set_style(span, "display", "flex");
      set_style(span, "align-items", "center");
      set_style(span, "width", "100%");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      mount_component(satellite, span, null);
      append2(span, t2);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            span,
            "keypress",
            /*manageRelay*/
            ctx[0]
          ),
          listen(
            span,
            "click",
            /*manageRelay*/
            ctx[0]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(satellite.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(satellite.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      destroy_component(satellite);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance36($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { relay = void 0 } = $$props;
  const dispatch = createEventDispatcher();
  function manageRelay() {
    if (relay) {
      dispatch("manageRelay", { relay });
    }
  }
  $$self.$$set = ($$props2) => {
    if ("relay" in $$props2)
      $$invalidate(1, relay = $$props2.relay);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [manageRelay, relay, $$scope, slots];
}
var Satellite_1 = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance36, create_fragment37, safe_not_equal, { relay: 1 });
  }
};
var Satellite_default = Satellite_1;

// src/components/Folder.svelte
function create_fragment38(ctx) {
  let span;
  let folder_1;
  let t2;
  let current;
  let mounted;
  let dispose;
  folder_1 = new folder_default({
    props: {
      class: "svg-icon",
      style: "margin-right: .2em; flex-shrink: 0"
    }
  });
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  return {
    c() {
      span = element2("span");
      create_component(folder_1.$$.fragment);
      t2 = space();
      if (default_slot)
        default_slot.c();
      attr(span, "role", "button");
      attr(span, "tabindex", "0");
      set_style(span, "display", "inline-flex");
      set_style(span, "align-items", "center");
      set_style(span, "width", "100%");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      mount_component(folder_1, span, null);
      append2(span, t2);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            span,
            "keypress",
            /*manageSharedFolder*/
            ctx[0]
          ),
          listen(
            span,
            "click",
            /*manageSharedFolder*/
            ctx[0]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(folder_1.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(folder_1.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      destroy_component(folder_1);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance37($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { folder = void 0 } = $$props;
  const dispatch = createEventDispatcher();
  function manageSharedFolder() {
    var _a2;
    if (folder) {
      dispatch("manageSharedFolder", {
        folder,
        relay: (_a2 = folder.remote) === null || _a2 === void 0 ? void 0 : _a2.relay
      });
    }
  }
  $$self.$$set = ($$props2) => {
    if ("folder" in $$props2)
      $$invalidate(1, folder = $$props2.folder);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [manageSharedFolder, folder, $$scope, slots];
}
var Folder_1 = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance37, create_fragment38, safe_not_equal, { folder: 1 });
  }
};
var Folder_default = Folder_1;

// src/components/SharedFolderSpan.svelte
function create_default_slot_12(ctx) {
  let span;
  let t_value = (
    /*folder*/
    ctx[0].name + ""
  );
  let t2;
  return {
    c() {
      span = element2("span");
      t2 = text2(t_value);
      set_style(span, "overflow", "hidden");
      set_style(span, "text-overflow", "ellipsis");
      set_style(span, "white-space", "nowrap");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append2(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*folder*/
      1 && t_value !== (t_value = /*folder*/
      ctx2[0].name + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block10(ctx) {
  let span;
  let arrowrightleft;
  let t2;
  let satellite;
  let current;
  arrowrightleft = new arrow_right_left_default({ props: { size: 16, class: "svg-icon" } });
  satellite = new Satellite_default({
    props: {
      relay: (
        /*relay*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot21] },
      $$scope: { ctx }
    }
  });
  satellite.$on(
    "manageRelay",
    /*manageRelay_handler*/
    ctx[3]
  );
  return {
    c() {
      span = element2("span");
      create_component(arrowrightleft.$$.fragment);
      t2 = space();
      create_component(satellite.$$.fragment);
      set_style(span, "width", "16px");
      set_style(span, "flex-shrink", "0");
      set_style(span, "display", "flex");
      set_style(span, "justify-content", "center");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      mount_component(arrowrightleft, span, null);
      insert(target, t2, anchor);
      mount_component(satellite, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const satellite_changes = {};
      if (dirty & /*relay*/
      2)
        satellite_changes.relay = /*relay*/
        ctx2[1];
      if (dirty & /*$$scope, folder*/
      17) {
        satellite_changes.$$scope = { dirty, ctx: ctx2 };
      }
      satellite.$set(satellite_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(arrowrightleft.$$.fragment, local);
      transition_in(satellite.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(arrowrightleft.$$.fragment, local);
      transition_out(satellite.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
        detach(t2);
      }
      destroy_component(arrowrightleft);
      destroy_component(satellite, detaching);
    }
  };
}
function create_default_slot21(ctx) {
  let span;
  let t_value = (
    /*folder*/
    ctx[0].remote.relay.name + ""
  );
  let t2;
  return {
    c() {
      span = element2("span");
      t2 = text2(t_value);
      set_style(span, "flex", "1");
      set_style(span, "min-width", "0");
      set_style(span, "text-overflow", "ellipsis");
      set_style(span, "white-space", "nowrap");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append2(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*folder*/
      1 && t_value !== (t_value = /*folder*/
      ctx2[0].remote.relay.name + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_fragment39(ctx) {
  let span1;
  let span0;
  let folder_1;
  let t2;
  let current;
  folder_1 = new Folder_default({
    props: {
      folder: (
        /*folder*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot_12] },
      $$scope: { ctx }
    }
  });
  folder_1.$on(
    "manageSharedFolder",
    /*manageSharedFolder_handler*/
    ctx[2]
  );
  let if_block = (
    /*folder*/
    ctx[0].remote && create_if_block10(ctx)
  );
  return {
    c() {
      span1 = element2("span");
      span0 = element2("span");
      create_component(folder_1.$$.fragment);
      t2 = space();
      if (if_block)
        if_block.c();
      set_style(span0, "display", "inline-flex");
      set_style(span0, "align-items", "center");
      set_style(span0, "width", "200px");
      set_style(span0, "min-width", "200px");
      set_style(span0, "flex-shrink", "0");
      set_style(span1, "display", "inline-flex");
      set_style(span1, "align-items", "center");
      set_style(span1, "width", "100%");
      set_style(span1, "gap", "8px");
    },
    m(target, anchor) {
      insert(target, span1, anchor);
      append2(span1, span0);
      mount_component(folder_1, span0, null);
      append2(span1, t2);
      if (if_block)
        if_block.m(span1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const folder_1_changes = {};
      if (dirty & /*folder*/
      1)
        folder_1_changes.folder = /*folder*/
        ctx2[0];
      if (dirty & /*$$scope, folder*/
      17) {
        folder_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      folder_1.$set(folder_1_changes);
      if (
        /*folder*/
        ctx2[0].remote
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*folder*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block10(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(span1, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(folder_1.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(folder_1.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span1);
      }
      destroy_component(folder_1);
      if (if_block)
        if_block.d();
    }
  };
}
function instance38($$self, $$props, $$invalidate) {
  let { folder } = $$props;
  let { relay } = $$props;
  function manageSharedFolder_handler(event) {
    bubble.call(this, $$self, event);
  }
  function manageRelay_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("folder" in $$props2)
      $$invalidate(0, folder = $$props2.folder);
    if ("relay" in $$props2)
      $$invalidate(1, relay = $$props2.relay);
  };
  return [folder, relay, manageSharedFolder_handler, manageRelay_handler];
}
var SharedFolderSpan = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance38, create_fragment39, safe_not_equal, { folder: 0, relay: 1 });
  }
};
var SharedFolderSpan_default = SharedFolderSpan;

// src/components/Relays.svelte
var import_obsidian11 = require("obsidian");
function add_css14(target) {
  append_styles(target, "svelte-yg42fv", "input.system3-input-invalid.svelte-yg42fv{border:1px solid var(--color-red) !important}span.faint.svelte-yg42fv{color:var(--text-faint)}");
}
function get_each_context3(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list[i2];
  return child_ctx;
}
function get_each_context_1(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[24] = list[i2];
  return child_ctx;
}
function create_default_slot_4(ctx) {
  let input;
  let input_class_value;
  let t0;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      input = element2("input");
      t0 = space();
      button = element2("button");
      button.textContent = "Join";
      attr(input, "type", "text");
      attr(input, "placeholder", "Enter share key");
      attr(input, "class", input_class_value = null_to_empty(
        /*invalidShareKey*/
        ctx[2] ? "system3-input-invalid" : ""
      ) + " svelte-yg42fv");
      attr(button, "class", "mod-cta");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(
        input,
        /*shareKey*/
        ctx[1]
      );
      insert(target, t0, anchor);
      insert(target, button, anchor);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[12]
          ),
          listen(
            input,
            "input",
            /*handleShareKeyInput*/
            ctx[8]
          ),
          listen(button, "click", function() {
            if (is_function((0, import_obsidian11.debounce)(
              /*click_handler*/
              ctx[13]
            )))
              (0, import_obsidian11.debounce)(
                /*click_handler*/
                ctx[13]
              ).apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*invalidShareKey*/
      4 && input_class_value !== (input_class_value = null_to_empty(
        /*invalidShareKey*/
        ctx[2] ? "system3-input-invalid" : ""
      ) + " svelte-yg42fv")) {
        attr(input, "class", input_class_value);
      }
      if (dirty & /*shareKey*/
      2 && input.value !== /*shareKey*/
      ctx[1]) {
        set_input_value(
          input,
          /*shareKey*/
          ctx[1]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
        detach(t0);
        detach(button);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_name_slot_2(ctx) {
  let span;
  return {
    c() {
      span = element2("span");
      span.textContent = "Relay Servers";
      attr(span, "slot", "name");
      set_style(span, "display", "inline-flex");
      set_style(span, "align-items", "center");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_default_slot_3(ctx) {
  let settingscontrol;
  let current;
  function settings_handler() {
    return (
      /*settings_handler*/
      ctx[15](
        /*relay*/
        ctx[24]
      )
    );
  }
  settingscontrol = new SettingsControl_default({});
  settingscontrol.$on("settings", settings_handler);
  return {
    c() {
      create_component(settingscontrol.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingscontrol, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    i(local) {
      if (current)
        return;
      transition_in(settingscontrol.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingscontrol.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingscontrol, detaching);
    }
  };
}
function create_else_block7(ctx) {
  let span;
  return {
    c() {
      span = element2("span");
      span.textContent = "(Untitled Relay Server)";
      attr(span, "class", "faint svelte-yg42fv");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_15(ctx) {
  let t_value = (
    /*relay*/
    ctx[24].name + ""
  );
  let t2;
  return {
    c() {
      t2 = text2(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$relays*/
      8 && t_value !== (t_value = /*relay*/
      ctx2[24].name + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_2(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*relay*/
      ctx2[24].name
    )
      return create_if_block_15;
    return create_else_block7;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function create_name_slot_1(ctx) {
  let satellite;
  let current;
  satellite = new Satellite_default({
    props: {
      slot: "name",
      relay: (
        /*relay*/
        ctx[24]
      ),
      t: "name",
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    }
  });
  satellite.$on(
    "manageRelay",
    /*manageRelay_handler*/
    ctx[14]
  );
  return {
    c() {
      create_component(satellite.$$.fragment);
    },
    m(target, anchor) {
      mount_component(satellite, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const satellite_changes = {};
      if (dirty & /*$relays*/
      8)
        satellite_changes.relay = /*relay*/
        ctx2[24];
      if (dirty & /*$$scope, $relays*/
      134217736) {
        satellite_changes.$$scope = { dirty, ctx: ctx2 };
      }
      satellite.$set(satellite_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(satellite.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(satellite.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(satellite, detaching);
    }
  };
}
function create_each_block_1(ctx) {
  let slimsettingitem;
  let current;
  slimsettingitem = new SlimSettingItem_default({
    props: {
      $$slots: {
        name: [create_name_slot_1],
        default: [create_default_slot_3]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(slimsettingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(slimsettingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const slimsettingitem_changes = {};
      if (dirty & /*$$scope, $relays*/
      134217736) {
        slimsettingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      slimsettingitem.$set(slimsettingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(slimsettingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(slimsettingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(slimsettingitem, detaching);
    }
  };
}
function create_default_slot_13(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element2("button");
      button.textContent = "Create";
      attr(button, "class", "mod-cta");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", (0, import_obsidian11.debounce)(
          /*click_handler_1*/
          ctx[16]
        ));
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block11(ctx) {
  let settingitem;
  let current;
  settingitem = new SettingItem_default({
    props: {
      description: "Go to a Relay Server's settings page above to share existing folders, or add Shared Folders to your vault."
    }
  });
  return {
    c() {
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem, detaching);
    }
  };
}
function create_default_slot22(ctx) {
  let settingscontrol;
  let t2;
  let current;
  function settings_handler_1() {
    return (
      /*settings_handler_1*/
      ctx[19](
        /*folder*/
        ctx[21]
      )
    );
  }
  settingscontrol = new SettingsControl_default({});
  settingscontrol.$on("settings", function() {
    if (is_function((0, import_obsidian11.debounce)(settings_handler_1)))
      (0, import_obsidian11.debounce)(settings_handler_1).apply(this, arguments);
  });
  return {
    c() {
      create_component(settingscontrol.$$.fragment);
      t2 = space();
    },
    m(target, anchor) {
      mount_component(settingscontrol, target, anchor);
      insert(target, t2, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    i(local) {
      if (current)
        return;
      transition_in(settingscontrol.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingscontrol.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(settingscontrol, detaching);
    }
  };
}
function create_name_slot2(ctx) {
  var _a2;
  let sharedfolderspan;
  let current;
  sharedfolderspan = new SharedFolderSpan_default({
    props: {
      folder: (
        /*folder*/
        ctx[21]
      ),
      relay: (
        /*folder*/
        (_a2 = ctx[21].remote) == null ? void 0 : _a2.relay
      ),
      slot: "name"
    }
  });
  sharedfolderspan.$on(
    "manageRelay",
    /*manageRelay_handler_1*/
    ctx[17]
  );
  sharedfolderspan.$on(
    "manageSharedFolder",
    /*manageSharedFolder_handler*/
    ctx[18]
  );
  return {
    c() {
      create_component(sharedfolderspan.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sharedfolderspan, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a3;
      const sharedfolderspan_changes = {};
      if (dirty & /*$sharedFolders*/
      16)
        sharedfolderspan_changes.folder = /*folder*/
        ctx2[21];
      if (dirty & /*$sharedFolders*/
      16)
        sharedfolderspan_changes.relay = /*folder*/
        (_a3 = ctx2[21].remote) == null ? void 0 : _a3.relay;
      sharedfolderspan.$set(sharedfolderspan_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sharedfolderspan.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sharedfolderspan.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sharedfolderspan, detaching);
    }
  };
}
function create_each_block3(ctx) {
  let slimsettingitem;
  let current;
  slimsettingitem = new SlimSettingItem_default({
    props: {
      $$slots: {
        name: [create_name_slot2],
        default: [create_default_slot22]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(slimsettingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(slimsettingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const slimsettingitem_changes = {};
      if (dirty & /*$$scope, $sharedFolders, $relays*/
      134217752) {
        slimsettingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      slimsettingitem.$set(slimsettingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(slimsettingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(slimsettingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(slimsettingitem, detaching);
    }
  };
}
function create_fragment40(ctx) {
  let settingitemheading0;
  let t0;
  let settingitem0;
  let t1;
  let settingitemheading1;
  let t2;
  let t3;
  let settingitem1;
  let t4;
  let settingitemheading2;
  let t5;
  let show_if = (
    /*$sharedFolders*/
    ctx[4].items().length === 0
  );
  let t6;
  let each1_anchor;
  let current;
  settingitemheading0 = new SettingItemHeading_default({ props: { name: "Join a Relay Server" } });
  settingitem0 = new SettingItem_default({
    props: {
      name: "Share key",
      description: "Enter the code that was shared with you.",
      $$slots: { default: [create_default_slot_4] },
      $$scope: { ctx }
    }
  });
  settingitemheading1 = new SettingItemHeading_default({
    props: {
      helpText: "A Relay Server coordinates real-time updates between collaborators. You can add collaborators and share folders on the Relay Server's settings page.",
      $$slots: { name: [create_name_slot_2] },
      $$scope: { ctx }
    }
  });
  let each_value_1 = ensure_array_like(
    /*$relays*/
    ctx[3].values().sort(sortFn)
  );
  let each_blocks_1 = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks_1[i2] = create_each_block_1(get_each_context_1(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks_1[i2], 1, 1, () => {
    each_blocks_1[i2] = null;
  });
  settingitem1 = new SettingItem_default({
    props: {
      name: "",
      description: "",
      $$slots: { default: [create_default_slot_13] },
      $$scope: { ctx }
    }
  });
  settingitemheading2 = new SettingItemHeading_default({
    props: {
      name: "Shared Folders",
      helpText: "Shared Folders enhance local folders by tracking edits. You can see what Relay Server a Shared Folder is connected to below."
    }
  });
  let if_block = show_if && create_if_block11(ctx);
  let each_value = ensure_array_like(
    /*$sharedFolders*/
    ctx[4].items()
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block3(get_each_context3(ctx, each_value, i2));
  }
  const out_1 = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      create_component(settingitemheading0.$$.fragment);
      t0 = space();
      create_component(settingitem0.$$.fragment);
      t1 = space();
      create_component(settingitemheading1.$$.fragment);
      t2 = space();
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        each_blocks_1[i2].c();
      }
      t3 = space();
      create_component(settingitem1.$$.fragment);
      t4 = space();
      create_component(settingitemheading2.$$.fragment);
      t5 = space();
      if (if_block)
        if_block.c();
      t6 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(settingitemheading0, target, anchor);
      insert(target, t0, anchor);
      mount_component(settingitem0, target, anchor);
      insert(target, t1, anchor);
      mount_component(settingitemheading1, target, anchor);
      insert(target, t2, anchor);
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        if (each_blocks_1[i2]) {
          each_blocks_1[i2].m(target, anchor);
        }
      }
      insert(target, t3, anchor);
      mount_component(settingitem1, target, anchor);
      insert(target, t4, anchor);
      mount_component(settingitemheading2, target, anchor);
      insert(target, t5, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t6, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const settingitem0_changes = {};
      if (dirty & /*$$scope, shareKey, invalidShareKey*/
      134217734) {
        settingitem0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem0.$set(settingitem0_changes);
      const settingitemheading1_changes = {};
      if (dirty & /*$$scope*/
      134217728) {
        settingitemheading1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitemheading1.$set(settingitemheading1_changes);
      if (dirty & /*$relays, sortFn, handleManageRelay*/
      72) {
        each_value_1 = ensure_array_like(
          /*$relays*/
          ctx2[3].values().sort(sortFn)
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i2);
          if (each_blocks_1[i2]) {
            each_blocks_1[i2].p(child_ctx, dirty);
            transition_in(each_blocks_1[i2], 1);
          } else {
            each_blocks_1[i2] = create_each_block_1(child_ctx);
            each_blocks_1[i2].c();
            transition_in(each_blocks_1[i2], 1);
            each_blocks_1[i2].m(t3.parentNode, t3);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks_1.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      const settingitem1_changes = {};
      if (dirty & /*$$scope*/
      134217728) {
        settingitem1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem1.$set(settingitem1_changes);
      if (dirty & /*$sharedFolders*/
      16)
        show_if = /*$sharedFolders*/
        ctx2[4].items().length === 0;
      if (show_if) {
        if (if_block) {
          if (dirty & /*$sharedFolders*/
          16) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block11(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t6.parentNode, t6);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty & /*$sharedFolders, $relays, handleManageSharedFolder*/
      152) {
        each_value = ensure_array_like(
          /*$sharedFolders*/
          ctx2[4].items()
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block3(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each1_anchor.parentNode, each1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out_1(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitemheading0.$$.fragment, local);
      transition_in(settingitem0.$$.fragment, local);
      transition_in(settingitemheading1.$$.fragment, local);
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks_1[i2]);
      }
      transition_in(settingitem1.$$.fragment, local);
      transition_in(settingitemheading2.$$.fragment, local);
      transition_in(if_block);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(settingitemheading0.$$.fragment, local);
      transition_out(settingitem0.$$.fragment, local);
      transition_out(settingitemheading1.$$.fragment, local);
      each_blocks_1 = each_blocks_1.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        transition_out(each_blocks_1[i2]);
      }
      transition_out(settingitem1.$$.fragment, local);
      transition_out(settingitemheading2.$$.fragment, local);
      transition_out(if_block);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
        detach(t5);
        detach(t6);
        detach(each1_anchor);
      }
      destroy_component(settingitemheading0, detaching);
      destroy_component(settingitem0, detaching);
      destroy_component(settingitemheading1, detaching);
      destroy_each(each_blocks_1, detaching);
      destroy_component(settingitem1, detaching);
      destroy_component(settingitemheading2, detaching);
      if (if_block)
        if_block.d(detaching);
      destroy_each(each_blocks, detaching);
    }
  };
}
function sortFn(a, b) {
  if (a.owner && !b.owner) {
    return -1;
  }
  if (b.owner && !a.owner) {
    return 1;
  }
  return a.name > b.name ? 1 : -1;
}
function instance39($$self, $$props, $$invalidate) {
  let $relays, $$unsubscribe_relays = noop, $$subscribe_relays = () => ($$unsubscribe_relays(), $$unsubscribe_relays = subscribe2(relays, ($$value) => $$invalidate(3, $relays = $$value)), relays);
  let $sharedFolders;
  $$self.$$.on_destroy.push(() => $$unsubscribe_relays());
  let { plugin } = $$props;
  let { relays } = $$props;
  $$subscribe_relays();
  const sharedFolders = plugin.sharedFolders;
  component_subscribe($$self, sharedFolders, (value) => $$invalidate(4, $sharedFolders = value));
  let shareKey = "";
  let invalidShareKey = false;
  const dispatch = createEventDispatcher();
  function handleManageRelay(relay) {
    if (!relay) {
      return;
    }
    dispatch("manageRelay", { relay });
  }
  function handleManageSharedFolder(folder, relay) {
    if (!folder) {
      return;
    }
    dispatch("manageSharedFolder", { folder, relay });
  }
  function handleShareKeyInput() {
    $$invalidate(2, invalidShareKey = false);
  }
  function handleJoinRelayFromInvite(shareKey2) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const relay = yield plugin.relayManager.acceptInvitation(shareKey2);
        dispatch("joinRelay", { relay });
      } catch (e2) {
        $$invalidate(2, invalidShareKey = true);
      }
    });
  }
  function handleCreateRelay() {
    dispatch("createRelay");
  }
  function input_input_handler() {
    shareKey = this.value;
    $$invalidate(1, shareKey);
  }
  const click_handler = () => handleJoinRelayFromInvite(shareKey);
  function manageRelay_handler(event) {
    bubble.call(this, $$self, event);
  }
  const settings_handler = (relay) => {
    handleManageRelay(relay);
  };
  const click_handler_1 = () => handleCreateRelay();
  function manageRelay_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function manageSharedFolder_handler(event) {
    bubble.call(this, $$self, event);
  }
  const settings_handler_1 = (folder) => {
    const relay = $relays.values().find((relay2) => {
      var _a2;
      return ((_a2 = folder.remote) == null ? void 0 : _a2.relay.guid) === relay2.guid;
    });
    handleManageSharedFolder(folder, relay);
  };
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(11, plugin = $$props2.plugin);
    if ("relays" in $$props2)
      $$subscribe_relays($$invalidate(0, relays = $$props2.relays));
  };
  return [
    relays,
    shareKey,
    invalidShareKey,
    $relays,
    $sharedFolders,
    sharedFolders,
    handleManageRelay,
    handleManageSharedFolder,
    handleShareKeyInput,
    handleJoinRelayFromInvite,
    handleCreateRelay,
    plugin,
    input_input_handler,
    click_handler,
    manageRelay_handler,
    settings_handler,
    click_handler_1,
    manageRelay_handler_1,
    manageSharedFolder_handler,
    settings_handler_1
  ];
}
var Relays = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance39, create_fragment40, safe_not_equal, { plugin: 11, relays: 0 }, add_css14);
  }
};
var Relays_default = Relays;

// src/components/ManageRelay.svelte
var import_obsidian17 = require("obsidian");
var import_path_browserify2 = __toESM(require_path_browserify());

// src/components/Breadcrumbs.svelte
function create_default_slot23(ctx) {
  let span0;
  let t0;
  let t1;
  let chevronright;
  let t2;
  let span1;
  let current;
  let mounted;
  let dispose;
  chevronright = new chevron_right_default({ props: { size: 16 } });
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  return {
    c() {
      span0 = element2("span");
      t0 = text2(
        /*categoryText*/
        ctx[1]
      );
      t1 = space();
      create_component(chevronright.$$.fragment);
      t2 = space();
      span1 = element2("span");
      if (default_slot)
        default_slot.c();
      attr(span0, "tabindex", "0");
      attr(span0, "role", "button");
      set_style(span1, "flex", "1");
      set_style(span1, "min-width", "0");
      set_style(span1, "text-overflow", "ellipsis");
      set_style(span1, "white-space", "nowrap");
      set_style(span1, "overflow", "hidden");
    },
    m(target, anchor) {
      insert(target, span0, anchor);
      append2(span0, t0);
      insert(target, t1, anchor);
      mount_component(chevronright, target, anchor);
      insert(target, t2, anchor);
      insert(target, span1, anchor);
      if (default_slot) {
        default_slot.m(span1, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            span0,
            "click",
            /*handleGoBack*/
            ctx[2]
          ),
          listen(
            span0,
            "keypress",
            /*handleGoBack*/
            ctx[2]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*categoryText*/
      2)
        set_data(
          t0,
          /*categoryText*/
          ctx2[1]
        );
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(chevronright.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(chevronright.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span0);
        detach(t1);
        detach(t2);
        detach(span1);
      }
      destroy_component(chevronright, detaching);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment41(ctx) {
  let h4;
  let switch_instance;
  let current;
  var switch_value = (
    /*category*/
    ctx[0]
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        $$slots: { default: [create_default_slot23] },
        $$scope: { ctx: ctx2 }
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      h4 = element2("h4");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
    },
    m(target, anchor) {
      insert(target, h4, anchor);
      if (switch_instance)
        mount_component(switch_instance, h4, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*category*/
      1 && switch_value !== (switch_value = /*category*/
      ctx2[0])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, h4, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*$$scope, categoryText*/
        18) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h4);
      }
      if (switch_instance)
        destroy_component(switch_instance);
    }
  };
}
function instance40($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { category } = $$props;
  let { categoryText } = $$props;
  const dispatch = createEventDispatcher();
  function handleGoBack() {
    dispatch("goBack");
  }
  $$self.$$set = ($$props2) => {
    if ("category" in $$props2)
      $$invalidate(0, category = $$props2.category);
    if ("categoryText" in $$props2)
      $$invalidate(1, categoryText = $$props2.categoryText);
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  return [category, categoryText, handleGoBack, slots, $$scope];
}
var Breadcrumbs = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance40, create_fragment41, safe_not_equal, { category: 0, categoryText: 1 });
  }
};
var Breadcrumbs_default = Breadcrumbs;

// src/ui/FolderSuggestModal.ts
var import_obsidian12 = require("obsidian");

// src/components/FolderSuggestion.svelte
function create_else_block8(ctx) {
  let div;
  let current;
  let if_block = (
    /*suggestion*/
    ctx[0].shared && create_if_block_16(ctx)
  );
  return {
    c() {
      div = element2("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "suggestion-icon");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*suggestion*/
        ctx2[0].shared
      ) {
        if (if_block) {
          if (dirty & /*suggestion*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_16(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block)
        if_block.d();
    }
  };
}
function create_if_block12(ctx) {
  let span;
  return {
    c() {
      span = element2("span");
      span.textContent = "Enter to create";
      attr(span, "class", "suggestion-action");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_16(ctx) {
  let layers;
  let current;
  layers = new layers_default({ props: { class: "svg-icon" } });
  return {
    c() {
      create_component(layers.$$.fragment);
    },
    m(target, anchor) {
      mount_component(layers, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(layers.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(layers.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(layers, detaching);
    }
  };
}
function create_fragment42(ctx) {
  let div1;
  let div0;
  let t0_value = (
    /*suggestion*/
    ctx[0].folder + ""
  );
  let t0;
  let t1;
  let div2;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block12, create_else_block8];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!/*suggestion*/
    ctx2[0].exists)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div1 = element2("div");
      div0 = element2("div");
      t0 = text2(t0_value);
      t1 = space();
      div2 = element2("div");
      if_block.c();
      attr(div0, "class", "suggestion-title");
      attr(div1, "class", "suggestion-content");
      attr(div2, "class", "suggestion-aux");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append2(div1, div0);
      append2(div0, t0);
      insert(target, t1, anchor);
      insert(target, div2, anchor);
      if_blocks[current_block_type_index].m(div2, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & /*suggestion*/
      1) && t0_value !== (t0_value = /*suggestion*/
      ctx2[0].folder + ""))
        set_data(t0, t0_value);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div2, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
        detach(t1);
        detach(div2);
      }
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance41($$self, $$props, $$invalidate) {
  let { suggestion } = $$props;
  $$self.$$set = ($$props2) => {
    if ("suggestion" in $$props2)
      $$invalidate(0, suggestion = $$props2.suggestion);
  };
  return [suggestion];
}
var FolderSuggestion = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance41, create_fragment42, safe_not_equal, { suggestion: 0 });
  }
};
var FolderSuggestion_default = FolderSuggestion;

// src/ui/FolderSuggestModal.ts
var FolderSuggestModal = class extends import_obsidian12.SuggestModal {
  constructor(app, sharedFolders, onChoose) {
    super(app);
    this.sharedFolders = sharedFolders;
    this.onChoose = onChoose;
    this.components = [];
    this.sharedPaths = new Set(
      this.sharedFolders.map((folder) => folder.path)
    );
    this.hasRemotes = new Set(
      this.sharedFolders.filter((folder) => folder.remote !== void 0).map((folder) => folder.path)
    );
    this.setInstructions([
      {
        command: "\u2191/\u2193",
        purpose: "Navigate"
      },
      {
        command: "Enter",
        purpose: "Choose and share folder"
      },
      {
        command: "Esc",
        purpose: "Cancel"
      }
    ]);
  }
  sortFn(a, b) {
    if (a.exists && !b.exists) {
      return 1;
    }
    if (!a.exists && b.exists) {
      return -1;
    }
    if (a.shared && !b.shared) {
      return -1;
    }
    if (b.shared && !a.shared) {
      return 1;
    }
    return a.folder.localeCompare(b.folder);
  }
  onClose() {
    super.onClose();
    this.components.forEach((component) => {
      component.$destroy();
    });
  }
  getSuggestions(inputStr) {
    this.components.forEach((component) => {
      component.$destroy();
    });
    const lowerCaseInputStr = inputStr.toLowerCase();
    const folders = [];
    const exists = this.app.vault.getAbstractFileByPath(inputStr) !== null;
    if (inputStr.length > 0 && !exists) {
      folders.push({
        folder: inputStr,
        exists: false,
        shared: false
      });
    }
    const getAllFoldersRecursively = (folder) => {
      const shared = this.sharedPaths.has(folder.path);
      const hasRemote = this.hasRemotes.has(folder.path);
      if (folder.path.toLowerCase().contains(lowerCaseInputStr) && folder.path.length > 1 && !hasRemote) {
        folders.push({
          folder: folder.path,
          exists: true,
          shared
        });
      }
      if (shared) {
        return;
      }
      for (const child of folder.children) {
        if (child instanceof import_obsidian12.TFolder) {
          getAllFoldersRecursively(child);
        }
      }
    };
    getAllFoldersRecursively(this.app.vault.getRoot());
    return folders.sort(this.sortFn);
  }
  renderSuggestion(suggestion, el) {
    el.addClass("mod-complex");
    const component = new FolderSuggestion_default({
      target: el,
      props: {
        suggestion
      }
    });
    this.components.push(component);
  }
  onChooseSuggestion(item, evt) {
    this.onChoose(item.folder);
  }
};

// src/ui/AddToVaultModal.ts
var import_obsidian16 = require("obsidian");

// src/components/AddToVaultModalContent.svelte
var import_obsidian15 = require("obsidian");

// src/ui/FolderSuggest.ts
var import_obsidian13 = require("obsidian");
var import_obsidian14 = require("obsidian");
var FolderSuggest = class extends import_obsidian14.AbstractInputSuggest {
  constructor(app, sharedFolders, inputEl) {
    super(app, inputEl);
    this.app = app;
    this.sharedFolders = sharedFolders;
    this.inputEl = inputEl;
    this.sharedPaths = new Set(
      this.sharedFolders.map((folder) => folder.path)
    );
  }
  getSuggestions(inputStr) {
    const lowerCaseInputStr = inputStr.toLowerCase();
    const folders = [];
    const getAllFoldersRecursively = (folder) => {
      const shared = this.sharedPaths.has(folder.path);
      if (shared) {
        return;
      }
      if (folder.path.toLowerCase().contains(lowerCaseInputStr)) {
        folders.push(folder.path);
      }
      for (const child of folder.children) {
        if (child instanceof import_obsidian13.TFolder) {
          getAllFoldersRecursively(child);
        }
      }
    };
    getAllFoldersRecursively(this.app.vault.getRoot());
    return folders;
  }
  renderSuggestion(folder, el) {
    el.setText(folder);
  }
  selectSuggestion(folder) {
    this.inputEl.value = folder;
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/components/FolderSelectInput.svelte
function create_fragment43(ctx) {
  let div;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      div = element2("div");
      input = element2("input");
      attr(input, "type", "text");
      attr(input, "placeholder", "/");
      attr(div, "class", "folder-suggest-container");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append2(div, input);
      ctx[5](input);
      set_input_value(
        input,
        /*$selectedFolder*/
        ctx[2]
      );
      if (!mounted) {
        dispose = [
          listen(input, "input", handleInput),
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[6]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$selectedFolder*/
      4 && input.value !== /*$selectedFolder*/
      ctx2[2]) {
        set_input_value(
          input,
          /*$selectedFolder*/
          ctx2[2]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      ctx[5](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function handleInput() {
}
function instance42($$self, $$props, $$invalidate) {
  let $selectedFolder, $$unsubscribe_selectedFolder = noop, $$subscribe_selectedFolder = () => ($$unsubscribe_selectedFolder(), $$unsubscribe_selectedFolder = subscribe2(selectedFolder, ($$value) => $$invalidate(2, $selectedFolder = $$value)), selectedFolder);
  $$self.$$.on_destroy.push(() => $$unsubscribe_selectedFolder());
  let { app } = $$props;
  let inputEl;
  let folderSuggest;
  let { sharedFolders } = $$props;
  let { selectedFolder = writable() } = $$props;
  $$subscribe_selectedFolder();
  onMount(() => {
    folderSuggest = new FolderSuggest(app, sharedFolders, inputEl);
    const handleFolderSelect = (event) => {
      $$subscribe_selectedFolder($$invalidate(0, selectedFolder = event.detail.folder.path));
    };
    inputEl.addEventListener("folder-selected", handleFolderSelect);
    return () => {
      inputEl.removeEventListener("folder-selected", handleFolderSelect);
    };
  });
  onDestroy(() => {
    if (folderSuggest) {
      folderSuggest.close();
    }
  });
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputEl = $$value;
      $$invalidate(1, inputEl);
    });
  }
  function input_input_handler() {
    $selectedFolder = this.value;
    selectedFolder.set($selectedFolder);
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(3, app = $$props2.app);
    if ("sharedFolders" in $$props2)
      $$invalidate(4, sharedFolders = $$props2.sharedFolders);
    if ("selectedFolder" in $$props2)
      $$subscribe_selectedFolder($$invalidate(0, selectedFolder = $$props2.selectedFolder));
  };
  return [
    selectedFolder,
    inputEl,
    $selectedFolder,
    app,
    sharedFolders,
    input_binding,
    input_input_handler
  ];
}
var FolderSelectInput = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance42, create_fragment43, safe_not_equal, {
      app: 3,
      sharedFolders: 4,
      selectedFolder: 0
    });
  }
};
var FolderSelectInput_default = FolderSelectInput;

// src/components/AddToVaultModalContent.svelte
function add_css15(target) {
  append_styles(target, "svelte-hgd3zf", "span.error.svelte-hgd3zf{flex:auto;align-content:center}");
}
function create_default_slot_14(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element2("input");
      attr(input, "type", "text");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(
        input,
        /*folderName*/
        ctx[4]
      );
      if (!mounted) {
        dispose = listen(
          input,
          "input",
          /*input_input_handler*/
          ctx[8]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*folderName*/
      16 && input.value !== /*folderName*/
      ctx2[4]) {
        set_input_value(
          input,
          /*folderName*/
          ctx2[4]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot24(ctx) {
  let folderselect;
  let current;
  folderselect = new FolderSelectInput_default({
    props: {
      app: (
        /*app*/
        ctx[0]
      ),
      sharedFolders: (
        /*sharedFolders*/
        ctx[2]
      ),
      selectedFolder: (
        /*folderLocation*/
        ctx[7]
      )
    }
  });
  return {
    c() {
      create_component(folderselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(folderselect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const folderselect_changes = {};
      if (dirty & /*app*/
      1)
        folderselect_changes.app = /*app*/
        ctx2[0];
      if (dirty & /*sharedFolders*/
      4)
        folderselect_changes.sharedFolders = /*sharedFolders*/
        ctx2[2];
      folderselect.$set(folderselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(folderselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(folderselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(folderselect, detaching);
    }
  };
}
function create_if_block13(ctx) {
  let span;
  let t2;
  return {
    c() {
      span = element2("span");
      t2 = text2(
        /*error*/
        ctx[5]
      );
      attr(span, "class", "mod-warning error svelte-hgd3zf");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append2(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*error*/
      32)
        set_data(
          t2,
          /*error*/
          ctx2[5]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_fragment44(ctx) {
  let div0;
  let t1;
  let div2;
  let settingitem0;
  let t2;
  let settingitem1;
  let t3;
  let div1;
  let t4;
  let button;
  let current;
  let mounted;
  let dispose;
  settingitem0 = new SettingItem_default({
    props: {
      name: "Folder name",
      description: "Set the name of the folder to be added.",
      $$slots: { default: [create_default_slot_14] },
      $$scope: { ctx }
    }
  });
  settingitem1 = new SettingItem_default({
    props: {
      name: "Folder location",
      description: "Set the location in your vault.",
      $$slots: { default: [create_default_slot24] },
      $$scope: { ctx }
    }
  });
  let if_block = (
    /*error*/
    ctx[5] && create_if_block13(ctx)
  );
  return {
    c() {
      div0 = element2("div");
      div0.textContent = "Add to vault";
      t1 = space();
      div2 = element2("div");
      create_component(settingitem0.$$.fragment);
      t2 = space();
      create_component(settingitem1.$$.fragment);
      t3 = space();
      div1 = element2("div");
      if (if_block)
        if_block.c();
      t4 = space();
      button = element2("button");
      button.textContent = "Confirm";
      attr(div0, "class", "modal-title");
      attr(button, "class", "mod-cta");
      attr(div1, "class", "modal-button-container");
      attr(div2, "class", "modal-content");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      insert(target, t1, anchor);
      insert(target, div2, anchor);
      mount_component(settingitem0, div2, null);
      append2(div2, t2);
      mount_component(settingitem1, div2, null);
      append2(div2, t3);
      append2(div2, div1);
      if (if_block)
        if_block.m(div1, null);
      append2(div1, t4);
      append2(div1, button);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function((0, import_obsidian15.debounce)(
            /*click_handler*/
            ctx[9]
          )))
            (0, import_obsidian15.debounce)(
              /*click_handler*/
              ctx[9]
            ).apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      const settingitem0_changes = {};
      if (dirty & /*$$scope, folderName*/
      1040) {
        settingitem0_changes.$$scope = { dirty, ctx };
      }
      settingitem0.$set(settingitem0_changes);
      const settingitem1_changes = {};
      if (dirty & /*$$scope, app, sharedFolders*/
      1029) {
        settingitem1_changes.$$scope = { dirty, ctx };
      }
      settingitem1.$set(settingitem1_changes);
      if (
        /*error*/
        ctx[5]
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block13(ctx);
          if_block.c();
          if_block.m(div1, t4);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem0.$$.fragment, local);
      transition_in(settingitem1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem0.$$.fragment, local);
      transition_out(settingitem1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t1);
        detach(div2);
      }
      destroy_component(settingitem0);
      destroy_component(settingitem1);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance43($$self, $$props, $$invalidate) {
  let $folderLocation;
  let { app } = $$props;
  let { remoteFolder } = $$props;
  let { sharedFolders } = $$props;
  let { onConfirm } = $$props;
  let folderName = remoteFolder.name;
  let folderLocation = writable();
  component_subscribe($$self, folderLocation, (value) => $$invalidate(6, $folderLocation = value));
  let error = "";
  function input_input_handler() {
    folderName = this.value;
    $$invalidate(4, folderName);
  }
  const click_handler = async () => {
    onConfirm(remoteFolder, folderName, $folderLocation || "").catch((e2) => {
      $$invalidate(5, error = e2.message);
    });
  };
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
    if ("remoteFolder" in $$props2)
      $$invalidate(1, remoteFolder = $$props2.remoteFolder);
    if ("sharedFolders" in $$props2)
      $$invalidate(2, sharedFolders = $$props2.sharedFolders);
    if ("onConfirm" in $$props2)
      $$invalidate(3, onConfirm = $$props2.onConfirm);
  };
  return [
    app,
    remoteFolder,
    sharedFolders,
    onConfirm,
    folderName,
    error,
    $folderLocation,
    folderLocation,
    input_input_handler,
    click_handler
  ];
}
var AddToVaultModalContent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance43,
      create_fragment44,
      safe_not_equal,
      {
        app: 0,
        remoteFolder: 1,
        sharedFolders: 2,
        onConfirm: 3
      },
      add_css15
    );
  }
};
var AddToVaultModalContent_default = AddToVaultModalContent;

// src/ui/AddToVaultModal.ts
var AddToVaultModal = class extends import_obsidian16.Modal {
  constructor(app, sharedFolders, remoteFolder, onConfirm) {
    super(app);
    this.sharedFolders = sharedFolders;
    this.remoteFolder = remoteFolder;
    this.onConfirm = onConfirm;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    this.component = new AddToVaultModalContent_default({
      target: contentEl,
      props: {
        remoteFolder: this.remoteFolder,
        sharedFolders: this.sharedFolders,
        onConfirm: async (remoteFolder, folderName, folderLocation) => {
          await this.onConfirm(remoteFolder, folderName, folderLocation);
          this.close();
        },
        app: this.app
      }
    });
  }
  onClose() {
    var _a2;
    const { contentEl } = this;
    contentEl.empty();
    (_a2 = this.component) == null ? void 0 : _a2.$destroy();
  }
};

// src/components/ManageRelay.svelte
var import_moment = __toESM(require_moment());
function add_css16(target) {
  append_styles(target, "svelte-xzg7gq", ".system3-settings-danger-zone.svelte-xzg7gq{margin-top:6em}input.system3-updating.svelte-xzg7gq{border:1px solid var(--color-accent) !important}input.system3-input-invalid.svelte-xzg7gq{border:1px solid var(--color-red) !important}.faint.svelte-xzg7gq{color:var(--text-faint)}");
}
function get_each_context4(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[50] = list[i2];
  return child_ctx;
}
function get_each_context_12(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[53] = list[i2];
  return child_ctx;
}
function create_else_block_4(ctx) {
  let span;
  return {
    c() {
      span = element2("span");
      span.textContent = "(Untitled Relay Server)";
      attr(span, "class", "faint svelte-xzg7gq");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_8(ctx) {
  let t_value = (
    /*relay*/
    ctx[0].name + ""
  );
  let t2;
  return {
    c() {
      t2 = text2(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*relay*/
      1 && t_value !== (t_value = /*relay*/
      ctx2[0].name + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_142(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*relay*/
      ctx2[0].name
    )
      return create_if_block_8;
    return create_else_block_4;
  }
  let current_block_type = select_block_type(ctx, [-1, -1]);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function create_if_block_7(ctx) {
  let settingitem;
  let current;
  settingitem = new SettingItem_default({
    props: {
      name: "Name",
      description: "Set the Relay Server's name.",
      $$slots: { default: [create_default_slot_132] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const settingitem_changes = {};
      if (dirty[0] & /*$updating, $nameValid, relay, nameInput*/
      297 | dirty[1] & /*$$scope*/
      33554432) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem, detaching);
    }
  };
}
function create_default_slot_132(ctx) {
  let input;
  let input_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      input = element2("input");
      attr(input, "type", "text");
      attr(input, "spellcheck", "false");
      attr(input, "placeholder", "Example: Shared Notes");
      attr(input, "class", input_class_value = null_to_empty(
        /*$updating*/
        (ctx[8] ? "system3-updating" : "") + /*$nameValid*/
        (ctx[5] ? "" : " system3-input-invalid")
      ) + " svelte-xzg7gq");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(
        input,
        /*relay*/
        ctx[0].name
      );
      ctx[35](input);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[34]
          ),
          listen(
            input,
            "input",
            /*handleNameChange*/
            ctx[26]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$updating, $nameValid*/
      288 && input_class_value !== (input_class_value = null_to_empty(
        /*$updating*/
        (ctx2[8] ? "system3-updating" : "") + /*$nameValid*/
        (ctx2[5] ? "" : " system3-input-invalid")
      ) + " svelte-xzg7gq")) {
        attr(input, "class", input_class_value);
      }
      if (dirty[0] & /*relay*/
      1 && input.value !== /*relay*/
      ctx2[0].name) {
        set_input_value(
          input,
          /*relay*/
          ctx2[0].name
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      ctx[35](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_else_block_3(ctx) {
  let slimsettingitem;
  let current;
  slimsettingitem = new SlimSettingItem_default({
    props: {
      $$slots: {
        name: [create_name_slot_22],
        default: [create_default_slot_122]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(slimsettingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(slimsettingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const slimsettingitem_changes = {};
      if (dirty[0] & /*$remoteFolders*/
      512 | dirty[1] & /*$$scope*/
      33554432) {
        slimsettingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      slimsettingitem.$set(slimsettingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(slimsettingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(slimsettingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(slimsettingitem, detaching);
    }
  };
}
function create_if_block_6(ctx) {
  let slimsettingitem;
  let current;
  slimsettingitem = new SlimSettingItem_default({
    props: {
      $$slots: {
        name: [create_name_slot_12],
        default: [create_default_slot_10]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(slimsettingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(slimsettingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const slimsettingitem_changes = {};
      if (dirty[0] & /*$sharedFolders, $remoteFolders*/
      1536 | dirty[1] & /*$$scope*/
      33554432) {
        slimsettingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      slimsettingitem.$set(slimsettingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(slimsettingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(slimsettingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(slimsettingitem, detaching);
    }
  };
}
function create_default_slot_122(ctx) {
  let button;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[39](
        /*remote*/
        ctx[53]
      )
    );
  }
  return {
    c() {
      button = element2("button");
      button.textContent = "Add to Vault";
      attr(button, "class", "mod-cta");
      attr(button, "aria-label", "Add shared folder to vault");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function((0, import_obsidian17.debounce)(click_handler)))
            (0, import_obsidian17.debounce)(click_handler).apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_11(ctx) {
  let t_value = (
    /*remote*/
    ctx[53].name + ""
  );
  let t2;
  return {
    c() {
      t2 = text2(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$remoteFolders*/
      512 && t_value !== (t_value = /*remote*/
      ctx2[53].name + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_name_slot_22(ctx) {
  let folder;
  let current;
  folder = new Folder_default({
    props: {
      slot: "name",
      $$slots: { default: [create_default_slot_11] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(folder.$$.fragment);
    },
    m(target, anchor) {
      mount_component(folder, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const folder_changes = {};
      if (dirty[0] & /*$remoteFolders*/
      512 | dirty[1] & /*$$scope*/
      33554432) {
        folder_changes.$$scope = { dirty, ctx: ctx2 };
      }
      folder.$set(folder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(folder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(folder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(folder, detaching);
    }
  };
}
function create_default_slot_10(ctx) {
  let settingscontrol;
  let current;
  function settings_handler() {
    return (
      /*settings_handler*/
      ctx[38](
        /*remote*/
        ctx[53]
      )
    );
  }
  settingscontrol = new SettingsControl_default({});
  settingscontrol.$on("settings", function() {
    if (is_function((0, import_obsidian17.debounce)(settings_handler)))
      (0, import_obsidian17.debounce)(settings_handler).apply(this, arguments);
  });
  return {
    c() {
      create_component(settingscontrol.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingscontrol, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    i(local) {
      if (current)
        return;
      transition_in(settingscontrol.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingscontrol.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingscontrol, detaching);
    }
  };
}
function create_default_slot_9(ctx) {
  let t_value = (
    /*remote*/
    ctx[53].name + ""
  );
  let t2;
  return {
    c() {
      t2 = text2(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$remoteFolders*/
      512 && t_value !== (t_value = /*remote*/
      ctx2[53].name + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_name_slot_12(ctx) {
  let folder;
  let current;
  function func_1(...args3) {
    return (
      /*func_1*/
      ctx[36](
        /*remote*/
        ctx[53],
        ...args3
      )
    );
  }
  folder = new Folder_default({
    props: {
      folder: (
        /*$sharedFolders*/
        ctx[10].find(func_1)
      ),
      slot: "name",
      $$slots: { default: [create_default_slot_9] },
      $$scope: { ctx }
    }
  });
  folder.$on(
    "manageSharedFolder",
    /*manageSharedFolder_handler*/
    ctx[37]
  );
  return {
    c() {
      create_component(folder.$$.fragment);
    },
    m(target, anchor) {
      mount_component(folder, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const folder_changes = {};
      if (dirty[0] & /*$sharedFolders, $remoteFolders*/
      1536)
        folder_changes.folder = /*$sharedFolders*/
        ctx[10].find(func_1);
      if (dirty[0] & /*$remoteFolders*/
      512 | dirty[1] & /*$$scope*/
      33554432) {
        folder_changes.$$scope = { dirty, ctx };
      }
      folder.$set(folder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(folder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(folder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(folder, detaching);
    }
  };
}
function create_each_block_12(ctx) {
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  function func(...args3) {
    return (
      /*func*/
      ctx[33](
        /*remote*/
        ctx[53],
        ...args3
      )
    );
  }
  const if_block_creators = [create_if_block_6, create_else_block_3];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (dirty[0] & /*$sharedFolders, $remoteFolders*/
    1536)
      show_if = null;
    if (show_if == null)
      show_if = !!/*$sharedFolders*/
      ctx2[10].find(func);
    if (show_if)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_default_slot_8(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element2("button");
      button.textContent = "Share a folder";
      attr(button, "class", "mod-cta");
      attr(button, "aria-label", "Select a folder to share it with this Relay Server");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", (0, import_obsidian17.debounce)(
          /*click_handler_1*/
          ctx[40]
        ));
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_7(ctx) {
  let t0_value = (
    /*$roles*/
    ctx[11].values().length + ""
  );
  let t0;
  let t1;
  let t2_value = (
    /*$relay*/
    ctx[7].userLimit + ""
  );
  let t2;
  return {
    c() {
      t0 = text2(t0_value);
      t1 = text2(" / ");
      t2 = text2(t2_value);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$roles*/
      2048 && t0_value !== (t0_value = /*$roles*/
      ctx2[11].values().length + ""))
        set_data(t0, t0_value);
      if (dirty[0] & /*$relay*/
      128 && t2_value !== (t2_value = /*$relay*/
      ctx2[7].userLimit + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
      }
    }
  };
}
function create_if_block_5(ctx) {
  let button;
  let mounted;
  let dispose;
  function click_handler_2() {
    return (
      /*click_handler_2*/
      ctx[41](
        /*item*/
        ctx[50]
      )
    );
  }
  return {
    c() {
      button = element2("button");
      button.textContent = "Kick";
      attr(button, "class", "mod-destructive");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function((0, import_obsidian17.debounce)(click_handler_2)))
            (0, import_obsidian17.debounce)(click_handler_2).apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_6(ctx) {
  let t2;
  let if_block = (
    /*item*/
    ctx[50].role === "Member" && /*$relay*/
    ctx[7].owner && create_if_block_5(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      t2 = space();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (
        /*item*/
        ctx2[50].role === "Member" && /*$relay*/
        ctx2[7].owner
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_5(ctx2);
          if_block.c();
          if_block.m(t2.parentNode, t2);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_each_block4(ctx) {
  let settingitem;
  let current;
  settingitem = new SettingItem_default({
    props: {
      name: (
        /*item*/
        ctx[50].user.name
      ),
      description: (
        /*item*/
        ctx[50].role
      ),
      $$slots: { default: [create_default_slot_6] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const settingitem_changes = {};
      if (dirty[0] & /*$roles*/
      2048)
        settingitem_changes.name = /*item*/
        ctx2[50].user.name;
      if (dirty[0] & /*$roles*/
      2048)
        settingitem_changes.description = /*item*/
        ctx2[50].role;
      if (dirty[0] & /*$roles, $relay*/
      2176 | dirty[1] & /*$$scope*/
      33554432) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem, detaching);
    }
  };
}
function create_default_slot_5(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element2("input");
      input.value = /*relay_invitation_key*/
      ctx[4];
      attr(input, "type", "text");
      input.readOnly = true;
      attr(input, "id", "system3InviteLink");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      if (!mounted) {
        dispose = listen(input, "click", (0, import_obsidian17.debounce)(
          /*selectText*/
          ctx[30]
        ));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*relay_invitation_key*/
      16 && input.value !== /*relay_invitation_key*/
      ctx2[4]) {
        input.value = /*relay_invitation_key*/
        ctx2[4];
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_else_block_2(ctx) {
  let settingitemheading;
  let t2;
  let settingitem;
  let current;
  settingitemheading = new SettingItemHeading_default({ props: { name: "Membership" } });
  settingitem = new SettingItem_default({
    props: {
      name: "Leave Relay Server",
      description: "Leave the Relay Server. Local data is preserved.",
      $$slots: { default: [create_default_slot_42] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitemheading.$$.fragment);
      t2 = space();
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitemheading, target, anchor);
      insert(target, t2, anchor);
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const settingitem_changes = {};
      if (dirty[1] & /*$$scope*/
      33554432) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitemheading.$$.fragment, local);
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitemheading.$$.fragment, local);
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(settingitemheading, detaching);
      destroy_component(settingitem, detaching);
    }
  };
}
function create_if_block14(ctx) {
  let current_block_type_index;
  let if_block;
  let t0;
  let settingitemheading;
  let t1;
  let settingitem;
  let current;
  const if_block_creators = [create_if_block_23, create_else_block_12];
  const if_blocks = [];
  function select_block_type_3(ctx2, dirty) {
    if (
      /*$subscription*/
      ctx2[12]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_3(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  settingitemheading = new SettingItemHeading_default({ props: { name: "Storage" } });
  settingitem = new SettingItem_default({
    props: {
      name: "Destroy Relay Server",
      description: "This will destroy the Relay Server (deleting all data on the server). Local data is preserved.",
      $$slots: { default: [create_default_slot25] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      if_block.c();
      t0 = space();
      create_component(settingitemheading.$$.fragment);
      t1 = space();
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, t0, anchor);
      mount_component(settingitemheading, target, anchor);
      insert(target, t1, anchor);
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_3(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(t0.parentNode, t0);
      }
      const settingitem_changes = {};
      if (dirty[0] & /*$subscriptions*/
      64 | dirty[1] & /*$$scope*/
      33554432) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(settingitemheading.$$.fragment, local);
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(settingitemheading.$$.fragment, local);
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
      if_blocks[current_block_type_index].d(detaching);
      destroy_component(settingitemheading, detaching);
      destroy_component(settingitem, detaching);
    }
  };
}
function create_default_slot_42(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element2("button");
      button.textContent = "Leave";
      attr(button, "class", "mod-warning");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", (0, import_obsidian17.debounce)(
          /*click_handler_6*/
          ctx[45]
        ));
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_else_block_12(ctx) {
  let settingitem;
  let current;
  settingitem = new SettingItem_default({
    props: {
      name: `Plan: ${/*$relay*/
      ctx[7].plan}`,
      description: "",
      $$slots: {
        description: [create_description_slot_1],
        default: [create_default_slot_32]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const settingitem_changes = {};
      if (dirty[0] & /*$relay*/
      128)
        settingitem_changes.name = `Plan: ${/*$relay*/
        ctx2[7].plan}`;
      if (dirty[0] & /*$relay*/
      128 | dirty[1] & /*$$scope*/
      33554432) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem, detaching);
    }
  };
}
function create_if_block_23(ctx) {
  let settingitem;
  let t2;
  let show_if = !/*$subscriptions*/
  ctx[6].values()[0].active || /*$subscriptions*/
  ctx[6].values()[0].cancelAt;
  let if_block_anchor;
  let current;
  settingitem = new SettingItem_default({
    props: {
      name: `Plan: ${/*$relay*/
      ctx[7].plan}`,
      description: "",
      $$slots: {
        description: [create_description_slot],
        default: [create_default_slot_22]
      },
      $$scope: { ctx }
    }
  });
  let if_block = show_if && create_if_block_32(ctx);
  return {
    c() {
      create_component(settingitem.$$.fragment);
      t2 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(settingitem, target, anchor);
      insert(target, t2, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const settingitem_changes = {};
      if (dirty[0] & /*$relay*/
      128)
        settingitem_changes.name = `Plan: ${/*$relay*/
        ctx2[7].plan}`;
      if (dirty[0] & /*$relay, $subscription, $subscriptions*/
      4288 | dirty[1] & /*$$scope*/
      33554432) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
      if (dirty[0] & /*$subscriptions*/
      64)
        show_if = !/*$subscriptions*/
        ctx2[6].values()[0].active || /*$subscriptions*/
        ctx2[6].values()[0].cancelAt;
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*$subscriptions*/
          64) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_32(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(if_block_anchor);
      }
      destroy_component(settingitem, detaching);
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_default_slot_32(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element2("button");
      button.textContent = "Upgrade";
      attr(button, "class", "mod-cta");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function((0, import_obsidian17.debounce)(
            /*click_handler_5*/
            ctx[44]
          )))
            (0, import_obsidian17.debounce)(
              /*click_handler_5*/
              ctx[44]
            ).apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_description_slot_1(ctx) {
  let fragment2;
  let t_value = (
    /*$relay*/
    (ctx[7].cta || "Thanks for supporting Relay development <3") + ""
  );
  let t2;
  return {
    c() {
      fragment2 = element2("fragment");
      t2 = text2(t_value);
      attr(fragment2, "slot", "description");
    },
    m(target, anchor) {
      insert(target, fragment2, anchor);
      append2(fragment2, t2);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$relay*/
      128 && t_value !== (t_value = /*$relay*/
      (ctx2[7].cta || "Thanks for supporting Relay development <3") + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(fragment2);
      }
    }
  };
}
function create_if_block_42(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element2("button");
      button.textContent = "Cancel";
      attr(button, "class", "mod-destructive");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function((0, import_obsidian17.debounce)(
            /*click_handler_4*/
            ctx[43]
          )))
            (0, import_obsidian17.debounce)(
              /*click_handler_4*/
              ctx[43]
            ).apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_22(ctx) {
  let button;
  let t1;
  let show_if = (
    /*$subscriptions*/
    ctx[6].values()[0].active && !/*$subscriptions*/
    ctx[6].values()[0].cancelAt
  );
  let if_block_anchor;
  let mounted;
  let dispose;
  let if_block = show_if && create_if_block_42(ctx);
  return {
    c() {
      button = element2("button");
      button.textContent = "Manage";
      t1 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      insert(target, button, anchor);
      insert(target, t1, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function((0, import_obsidian17.debounce)(
            /*click_handler_3*/
            ctx[42]
          )))
            (0, import_obsidian17.debounce)(
              /*click_handler_3*/
              ctx[42]
            ).apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*$subscriptions*/
      64)
        show_if = /*$subscriptions*/
        ctx[6].values()[0].active && !/*$subscriptions*/
        ctx[6].values()[0].cancelAt;
      if (show_if) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block_42(ctx);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
        detach(t1);
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_description_slot(ctx) {
  let fragment2;
  let t_value = (
    /*$relay*/
    ctx[7].cta + ""
  );
  let t2;
  return {
    c() {
      fragment2 = element2("fragment");
      t2 = text2(t_value);
      attr(fragment2, "slot", "description");
    },
    m(target, anchor) {
      insert(target, fragment2, anchor);
      append2(fragment2, t2);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$relay*/
      128 && t_value !== (t_value = /*$relay*/
      ctx2[7].cta + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(fragment2);
      }
    }
  };
}
function create_if_block_32(ctx) {
  let settingitem;
  let current;
  settingitem = new SettingItem_default({
    props: {
      description: "",
      $$slots: {
        name: [create_name_slot3],
        default: [create_default_slot_15]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const settingitem_changes = {};
      if (dirty[0] & /*$subscriptions*/
      64 | dirty[1] & /*$$scope*/
      33554432) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem, detaching);
    }
  };
}
function create_default_slot_15(ctx) {
  let t_value = (
    /*getActiveForMessage*/
    ctx[14](
      /*$subscriptions*/
      ctx[6].values()[0].cancelAt
    ) + ""
  );
  let t2;
  return {
    c() {
      t2 = text2(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$subscriptions*/
      64 && t_value !== (t_value = /*getActiveForMessage*/
      ctx2[14](
        /*$subscriptions*/
        ctx2[6].values()[0].cancelAt
      ) + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_name_slot3(ctx) {
  let span;
  return {
    c() {
      span = element2("span");
      span.textContent = "Status: Cancelled";
      attr(span, "slot", "name");
      attr(span, "class", "mod-warning");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_else_block9(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element2("button");
      button.textContent = "Destroy";
      attr(button, "class", "mod-warning");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", (0, import_obsidian17.debounce)(
          /*handleDestroy*/
          ctx[27]
        ));
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_17(ctx) {
  let button;
  let button_disabled_value;
  return {
    c() {
      button = element2("button");
      button.textContent = "Destroy";
      button.disabled = button_disabled_value = true;
      attr(button, "class", "mod-warning");
      attr(button, "aria-label", "Cancel subscription to destroy Relay Server.");
    },
    m(target, anchor) {
      insert(target, button, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
    }
  };
}
function create_default_slot25(ctx) {
  let show_if;
  let if_block_anchor;
  function select_block_type_4(ctx2, dirty) {
    if (dirty[0] & /*$subscriptions*/
    64)
      show_if = null;
    if (show_if == null)
      show_if = !!/*$subscriptions*/
      (ctx2[6].values().length > 0 && !/*$subscriptions*/
      ctx2[6].values()[0].cancelAt);
    if (show_if)
      return create_if_block_17;
    return create_else_block9;
  }
  let current_block_type = select_block_type_4(ctx, [-1, -1]);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_4(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function create_fragment45(ctx) {
  let breadcrumbs;
  let t0;
  let t1;
  let settingitemheading0;
  let t2;
  let t3;
  let settingitem0;
  let t4;
  let settingitemheading1;
  let t5;
  let t6;
  let settingitemheading2;
  let t7;
  let settingitem1;
  let t8;
  let current_block_type_index;
  let if_block1;
  let if_block1_anchor;
  let current;
  breadcrumbs = new Breadcrumbs_default({
    props: {
      category: Satellite_default,
      categoryText: "Relay Servers",
      $$slots: { default: [create_default_slot_142] },
      $$scope: { ctx }
    }
  });
  breadcrumbs.$on(
    "goBack",
    /*goBack*/
    ctx[23]
  );
  let if_block0 = (
    /*relay*/
    ctx[0].owner && create_if_block_7(ctx)
  );
  settingitemheading0 = new SettingItemHeading_default({
    props: { name: "Folders on this Relay Server" }
  });
  let each_value_1 = ensure_array_like(
    /*$remoteFolders*/
    ctx[9].values()
  );
  let each_blocks_1 = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks_1[i2] = create_each_block_12(get_each_context_12(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks_1[i2], 1, 1, () => {
    each_blocks_1[i2] = null;
  });
  settingitem0 = new SettingItem_default({
    props: {
      description: "",
      name: "",
      $$slots: { default: [create_default_slot_8] },
      $$scope: { ctx }
    }
  });
  settingitemheading1 = new SettingItemHeading_default({
    props: {
      name: "Users",
      $$slots: { default: [create_default_slot_7] },
      $$scope: { ctx }
    }
  });
  let each_value = ensure_array_like(
    /*$roles*/
    ctx[11].values().sort(userSort)
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block4(get_each_context4(ctx, each_value, i2));
  }
  const out_1 = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  settingitemheading2 = new SettingItemHeading_default({ props: { name: "Sharing" } });
  settingitem1 = new SettingItem_default({
    props: {
      name: "Share Key",
      description: "Share this key with your collaborators.",
      $$slots: { default: [create_default_slot_5] },
      $$scope: { ctx }
    }
  });
  const if_block_creators = [create_if_block14, create_else_block_2];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (
      /*$relay*/
      ctx2[7].owner
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx, [-1, -1]);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      create_component(breadcrumbs.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      create_component(settingitemheading0.$$.fragment);
      t2 = space();
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        each_blocks_1[i2].c();
      }
      t3 = space();
      create_component(settingitem0.$$.fragment);
      t4 = space();
      create_component(settingitemheading1.$$.fragment);
      t5 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t6 = space();
      create_component(settingitemheading2.$$.fragment);
      t7 = space();
      create_component(settingitem1.$$.fragment);
      t8 = space();
      if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(breadcrumbs, target, anchor);
      insert(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t1, anchor);
      mount_component(settingitemheading0, target, anchor);
      insert(target, t2, anchor);
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        if (each_blocks_1[i2]) {
          each_blocks_1[i2].m(target, anchor);
        }
      }
      insert(target, t3, anchor);
      mount_component(settingitem0, target, anchor);
      insert(target, t4, anchor);
      mount_component(settingitemheading1, target, anchor);
      insert(target, t5, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, t6, anchor);
      mount_component(settingitemheading2, target, anchor);
      insert(target, t7, anchor);
      mount_component(settingitem1, target, anchor);
      insert(target, t8, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const breadcrumbs_changes = {};
      if (dirty[0] & /*relay*/
      1 | dirty[1] & /*$$scope*/
      33554432) {
        breadcrumbs_changes.$$scope = { dirty, ctx: ctx2 };
      }
      breadcrumbs.$set(breadcrumbs_changes);
      if (
        /*relay*/
        ctx2[0].owner
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*relay*/
          1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_7(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (dirty[0] & /*$sharedFolders, $remoteFolders, handleManageSharedFolder, showAddToVaultModal*/
      570426880) {
        each_value_1 = ensure_array_like(
          /*$remoteFolders*/
          ctx2[9].values()
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_12(ctx2, each_value_1, i2);
          if (each_blocks_1[i2]) {
            each_blocks_1[i2].p(child_ctx, dirty);
            transition_in(each_blocks_1[i2], 1);
          } else {
            each_blocks_1[i2] = create_each_block_12(child_ctx);
            each_blocks_1[i2].c();
            transition_in(each_blocks_1[i2], 1);
            each_blocks_1[i2].m(t3.parentNode, t3);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks_1.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      const settingitem0_changes = {};
      if (dirty[1] & /*$$scope*/
      33554432) {
        settingitem0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem0.$set(settingitem0_changes);
      const settingitemheading1_changes = {};
      if (dirty[0] & /*$relay, $roles*/
      2176 | dirty[1] & /*$$scope*/
      33554432) {
        settingitemheading1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitemheading1.$set(settingitemheading1_changes);
      if (dirty[0] & /*$roles, handleKick, $relay*/
      268437632) {
        each_value = ensure_array_like(
          /*$roles*/
          ctx2[11].values().sort(userSort)
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context4(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block4(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(t6.parentNode, t6);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out_1(i2);
        }
        check_outros();
      }
      const settingitem1_changes = {};
      if (dirty[0] & /*relay_invitation_key*/
      16 | dirty[1] & /*$$scope*/
      33554432) {
        settingitem1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem1.$set(settingitem1_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(breadcrumbs.$$.fragment, local);
      transition_in(if_block0);
      transition_in(settingitemheading0.$$.fragment, local);
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks_1[i2]);
      }
      transition_in(settingitem0.$$.fragment, local);
      transition_in(settingitemheading1.$$.fragment, local);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(settingitemheading2.$$.fragment, local);
      transition_in(settingitem1.$$.fragment, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(breadcrumbs.$$.fragment, local);
      transition_out(if_block0);
      transition_out(settingitemheading0.$$.fragment, local);
      each_blocks_1 = each_blocks_1.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        transition_out(each_blocks_1[i2]);
      }
      transition_out(settingitem0.$$.fragment, local);
      transition_out(settingitemheading1.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(settingitemheading2.$$.fragment, local);
      transition_out(settingitem1.$$.fragment, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
        detach(t5);
        detach(t6);
        detach(t7);
        detach(t8);
        detach(if_block1_anchor);
      }
      destroy_component(breadcrumbs, detaching);
      if (if_block0)
        if_block0.d(detaching);
      destroy_component(settingitemheading0, detaching);
      destroy_each(each_blocks_1, detaching);
      destroy_component(settingitem0, detaching);
      destroy_component(settingitemheading1, detaching);
      destroy_each(each_blocks, detaching);
      destroy_component(settingitemheading2, detaching);
      destroy_component(settingitem1, detaching);
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function userSort(a, b) {
  if (a.role === "Owner" && b.role !== "Owner") {
    return -1;
  }
  if (a.role !== "Owner" && b.role === "Owner") {
    return 1;
  }
  return a.user.name > b.user.name ? 1 : -1;
}
function isValidObsidianFolderName(path) {
  const restrictedCharacters = /[\\:*?"<>|]/;
  if (restrictedCharacters.test(path)) {
    return false;
  }
  const segments = path.split("/");
  for (const segment of segments) {
    if (segment === "" || segment === "." || segment === "..") {
      return false;
    }
  }
  return true;
}
function instance44($$self, $$props, $$invalidate) {
  let $nameValid;
  let $relayRoles, $$unsubscribe_relayRoles = noop, $$subscribe_relayRoles = () => ($$unsubscribe_relayRoles(), $$unsubscribe_relayRoles = subscribe2(relayRoles, ($$value) => $$invalidate(46, $relayRoles = $$value)), relayRoles);
  let $subscriptions;
  let $relay, $$unsubscribe_relay = noop, $$subscribe_relay = () => ($$unsubscribe_relay(), $$unsubscribe_relay = subscribe2(relay, ($$value) => $$invalidate(7, $relay = $$value)), relay);
  let $updating;
  let $remoteFolders;
  let $sharedFolders, $$unsubscribe_sharedFolders = noop, $$subscribe_sharedFolders = () => ($$unsubscribe_sharedFolders(), $$unsubscribe_sharedFolders = subscribe2(sharedFolders, ($$value) => $$invalidate(10, $sharedFolders = $$value)), sharedFolders);
  let $roles;
  let $subscription;
  $$self.$$.on_destroy.push(() => $$unsubscribe_relayRoles());
  $$self.$$.on_destroy.push(() => $$unsubscribe_relay());
  $$self.$$.on_destroy.push(() => $$unsubscribe_sharedFolders());
  let { relay } = $$props;
  $$subscribe_relay();
  const remoteFolders = relay.folders;
  component_subscribe($$self, remoteFolders, (value) => $$invalidate(9, $remoteFolders = value));
  let { plugin } = $$props;
  let { sharedFolders } = $$props;
  $$subscribe_sharedFolders();
  let { relayRoles } = $$props;
  $$subscribe_relayRoles();
  function getActiveForMessage(cancelAtDate) {
    if (!cancelAtDate) {
      return "Active";
    }
    const now2 = (0, import_moment.default)();
    const cancelAt = (0, import_moment.default)(cancelAtDate);
    const daysRemaining = cancelAt.diff(now2, "days");
    if (daysRemaining <= 0) {
      return "Subscription has ended";
    } else if (daysRemaining === 1) {
      return "Active for 1 more day";
    } else {
      return `Active for ${daysRemaining} more days`;
    }
  }
  const subscriptions = $relay.subscriptions;
  component_subscribe($$self, subscriptions, (value) => $$invalidate(6, $subscriptions = value));
  const subscription = derived($subscriptions, ($subscriptions2) => {
    if ($subscriptions2.values().length === 0) {
      return void 0;
    }
    const subscription2 = $subscriptions2.values()[0];
    if (!subscription2.token) {
      plugin.relayManager.getSubscriptionToken(subscription2).then((token) => {
        subscription2.token = token;
      });
    }
    return subscription2;
  });
  component_subscribe($$self, subscription, (value) => $$invalidate(12, $subscription = value));
  const roles = $relayRoles.filter((role) => {
    var _a2;
    return ((_a2 = role.relay) === null || _a2 === void 0 ? void 0 : _a2.id) === relay.id;
  });
  component_subscribe($$self, roles, (value) => $$invalidate(11, $roles = value));
  let nameValid = writable(true);
  component_subscribe($$self, nameValid, (value) => $$invalidate(5, $nameValid = value));
  let nameInput;
  onMount(() => {
    if (nameInput && nameInput.value === "") {
      nameInput.focus();
    }
  });
  const dispatch = createEventDispatcher();
  function handleUpgrade(relay2) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a2;
      if (!((_a2 = plugin.loginManager) === null || _a2 === void 0 ? void 0 : _a2.user)) {
        return;
      }
      const payload = {
        relay: relay2.id,
        quantity: 10,
        user_email: plugin.loginManager.user.email
      };
      const encodedPayload = btoa(JSON.stringify(payload)).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
      window.open(plugin.buildApiUrl(`/subscribe/${encodedPayload}`), "_blank");
    });
  }
  function handleManage(subscription2) {
    return __awaiter(this, void 0, void 0, function* () {
      const token = subscription2.token;
      const sub_id = subscription2.id;
      window.open(plugin.buildApiUrl(`/subscriptions/${sub_id}/manage?token=${token}`), "_blank");
    });
  }
  function handleCancel(subscription2) {
    return __awaiter(this, void 0, void 0, function* () {
      const token = subscription2.token;
      const sub_id = subscription2.id;
      window.open(plugin.buildApiUrl(`/subscriptions/${sub_id}/cancel?token=${token}`), "_blank");
    });
  }
  function handleLeaveRelay() {
    return __awaiter(this, void 0, void 0, function* () {
      plugin.relayManager.leaveRelay(relay);
      dispatch("goBack", { clear: true });
    });
  }
  function goBack() {
    return __awaiter(this, void 0, void 0, function* () {
      dispatch("goBack", { clear: true });
    });
  }
  let relay_invitation_key;
  plugin.relayManager.getRelayInvitationKey(relay).then((key) => {
    $$invalidate(4, relay_invitation_key = key);
  });
  function addToVault(remoteFolder, name, location2) {
    return __awaiter(this, void 0, void 0, function* () {
      const vaultRelativePath = (0, import_obsidian17.normalizePath)((0, import_path_browserify2.join)(location2, name));
      if (plugin.vault.getFolderByPath(vaultRelativePath) === null) {
        yield plugin.vault.createFolder(vaultRelativePath);
      }
      const folder = plugin.sharedFolders.new(vaultRelativePath, remoteFolder.guid, relay.guid, true);
      folder.remote = remoteFolder;
      plugin.sharedFolders.notifyListeners();
      return folder;
    });
  }
  let updating = writable(false);
  component_subscribe($$self, updating, (value) => $$invalidate(8, $updating = value));
  const updateRelay = (0, import_obsidian17.debounce)(
    () => {
      plugin.relayManager.updateRelay(relay);
      updating.set(false);
    },
    500,
    true
  );
  const showAddToVaultModal = (remoteFolder) => {
    new AddToVaultModal(plugin.app, sharedFolders, remoteFolder, addToVault).open();
  };
  function handleNameChange() {
    nameValid.set(isValidObsidianFolderName(nameInput.value));
    if ($nameValid && nameInput.value !== "") {
      updating.set(true);
      updateRelay();
    }
  }
  function handleDestroy() {
    plugin.relayManager.destroyRelay(relay);
    dispatch("goBack", {});
  }
  function handleKick(relay_role) {
    plugin.relayManager.kick(relay_role);
  }
  function handleManageSharedFolder(folder, relay2) {
    if (!folder) {
      return;
    }
    dispatch("manageSharedFolder", { folder, relay: relay2, mount: false });
  }
  function selectText(event) {
    const inputEl = event.target;
    inputEl.focus();
    inputEl.select();
    navigator.clipboard.writeText(inputEl.value).then(() => new import_obsidian17.Notice("Invite link copied")).catch((err) => {
    });
  }
  const folderSelect = new FolderSuggestModal(
    plugin.app,
    sharedFolders,
    (path) => __awaiter(void 0, void 0, void 0, function* () {
      const normalizedPath = (0, import_obsidian17.normalizePath)(path);
      const folder = sharedFolders.find((folder2) => folder2.path == path);
      if (folder) {
        const remote2 = yield plugin.relayManager.createRemoteFolder(folder, relay);
        folder.remote = remote2;
        folder.connect();
        plugin.sharedFolders.notifyListeners();
        return;
      }
      if (plugin.vault.getFolderByPath(normalizedPath) === null) {
        yield plugin.vault.createFolder(normalizedPath);
      }
      const guid = uuidv4();
      const sharedFolder = plugin.sharedFolders.new((0, import_obsidian17.normalizePath)(path), guid, relay.guid, true);
      const remote = yield plugin.relayManager.createRemoteFolder(sharedFolder, relay);
      sharedFolder.remote = remote;
      plugin.sharedFolders.notifyListeners();
    })
  );
  const func = (remote, local) => local.remote === remote;
  function input_input_handler() {
    relay.name = this.value;
    $$subscribe_relay($$invalidate(0, relay));
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      nameInput = $$value;
      $$invalidate(3, nameInput);
    });
  }
  const func_1 = (remote, local) => local.remote === remote;
  function manageSharedFolder_handler(event) {
    bubble.call(this, $$self, event);
  }
  const settings_handler = (remote) => {
    const local = $sharedFolders.find((local2) => local2.remote === remote);
    if (local) {
      handleManageSharedFolder(local, remote.relay);
    }
  };
  const click_handler = (remote) => {
    showAddToVaultModal(remote);
  };
  const click_handler_1 = () => {
    folderSelect.open();
  };
  const click_handler_2 = (item) => {
    handleKick(item);
  };
  const click_handler_3 = () => {
    handleManage($subscription);
  };
  const click_handler_4 = () => {
    handleCancel($subscription);
  };
  const click_handler_5 = () => {
    handleUpgrade($relay);
  };
  const click_handler_6 = () => {
    handleLeaveRelay();
  };
  $$self.$$set = ($$props2) => {
    if ("relay" in $$props2)
      $$subscribe_relay($$invalidate(0, relay = $$props2.relay));
    if ("plugin" in $$props2)
      $$invalidate(32, plugin = $$props2.plugin);
    if ("sharedFolders" in $$props2)
      $$subscribe_sharedFolders($$invalidate(1, sharedFolders = $$props2.sharedFolders));
    if ("relayRoles" in $$props2)
      $$subscribe_relayRoles($$invalidate(2, relayRoles = $$props2.relayRoles));
  };
  return [
    relay,
    sharedFolders,
    relayRoles,
    nameInput,
    relay_invitation_key,
    $nameValid,
    $subscriptions,
    $relay,
    $updating,
    $remoteFolders,
    $sharedFolders,
    $roles,
    $subscription,
    remoteFolders,
    getActiveForMessage,
    subscriptions,
    subscription,
    roles,
    nameValid,
    handleUpgrade,
    handleManage,
    handleCancel,
    handleLeaveRelay,
    goBack,
    updating,
    showAddToVaultModal,
    handleNameChange,
    handleDestroy,
    handleKick,
    handleManageSharedFolder,
    selectText,
    folderSelect,
    plugin,
    func,
    input_input_handler,
    input_binding,
    func_1,
    manageSharedFolder_handler,
    settings_handler,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    click_handler_4,
    click_handler_5,
    click_handler_6
  ];
}
var ManageRelay = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance44,
      create_fragment45,
      safe_not_equal,
      {
        relay: 0,
        plugin: 32,
        sharedFolders: 1,
        relayRoles: 2
      },
      add_css16,
      [-1, -1]
    );
  }
};
var ManageRelay_default = ManageRelay;

// src/components/ModalSettingsNav.svelte
function create_fragment46(ctx) {
  let div1;
  let div0;
  let chevronleft;
  let current;
  let mounted;
  let dispose;
  chevronleft = new chevron_left_default({});
  return {
    c() {
      div1 = element2("div");
      div0 = element2("div");
      create_component(chevronleft.$$.fragment);
      attr(div0, "class", "clickable-icon");
      attr(div0, "aria-label", "Back");
      attr(div0, "tabindex", "0");
      attr(div0, "role", "button");
      attr(div1, "class", "modal-setting-nav-bar");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append2(div1, div0);
      mount_component(chevronleft, div0, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            div0,
            "click",
            /*handleGoBack*/
            ctx[0]
          ),
          listen(
            div0,
            "keypress",
            /*handleKeypress*/
            ctx[1]
          )
        ];
        mounted = true;
      }
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(chevronleft.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(chevronleft.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(chevronleft);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance45($$self) {
  const dispatch = createEventDispatcher();
  function handleGoBack() {
    dispatch("goBack", {});
  }
  function handleKeypress(event) {
    if (event.key === "Escape") {
      dispatch("goBack", {});
      event.stopPropagation();
    }
  }
  return [handleGoBack, handleKeypress];
}
var ModalSettingsNav = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance45, create_fragment46, safe_not_equal, {});
  }
};
var ModalSettingsNav_default = ModalSettingsNav;

// src/components/ManageSharedFolder.svelte
var import_obsidian18 = require("obsidian");
function create_default_slot_52(ctx) {
  let t_value = (
    /*sharedFolder*/
    ctx[1].name + ""
  );
  let t2;
  return {
    c() {
      t2 = text2(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*sharedFolder*/
      2 && t_value !== (t_value = /*sharedFolder*/
      ctx2[1].name + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_43(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element2("button");
      button.textContent = "Delete local";
      attr(button, "class", "mod-warning");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", (0, import_obsidian18.debounce)(
          /*click_handler*/
          ctx[13]
        ));
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_33(ctx) {
  let button;
  let t2;
  let button_class_value;
  let button_disabled_value;
  let button_aria_label_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element2("button");
      t2 = text2("Delete metadata");
      attr(button, "class", button_class_value = /*$relayStore*/
      ctx[4] ? "mod-disabled" : "mod-warning");
      button.disabled = button_disabled_value = /*$relayStore*/
      ctx[4] ? true : false;
      attr(button, "aria-label", button_aria_label_value = /*$relayStore*/
      ctx[4] ? "Metadata is required for sharing." : "");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append2(button, t2);
      if (!mounted) {
        dispose = listen(button, "click", (0, import_obsidian18.debounce)(
          /*click_handler_1*/
          ctx[14]
        ));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$relayStore*/
      16 && button_class_value !== (button_class_value = /*$relayStore*/
      ctx2[4] ? "mod-disabled" : "mod-warning")) {
        attr(button, "class", button_class_value);
      }
      if (dirty & /*$relayStore*/
      16 && button_disabled_value !== (button_disabled_value = /*$relayStore*/
      ctx2[4] ? true : false)) {
        button.disabled = button_disabled_value;
      }
      if (dirty & /*$relayStore*/
      16 && button_aria_label_value !== (button_aria_label_value = /*$relayStore*/
      ctx2[4] ? "Metadata is required for sharing." : "")) {
        attr(button, "aria-label", button_aria_label_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_18(ctx) {
  var _a2, _b2, _c, _d, _e;
  let if_block_anchor;
  let current;
  let if_block = (
    /*$relayStore*/
    (((_a2 = ctx[4]) == null ? void 0 : _a2.owner) || /*$folderStore*/
    ((_d = (_c = (_b2 = ctx[3]) == null ? void 0 : _b2.remote) == null ? void 0 : _c.creator) == null ? void 0 : _d.id) === /*plugin*/
    ((_e = ctx[0].relayManager.user) == null ? void 0 : _e.id)) && create_if_block_24(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a3, _b3, _c2, _d2, _e2;
      if (
        /*$relayStore*/
        ((_a3 = ctx2[4]) == null ? void 0 : _a3.owner) || /*$folderStore*/
        ((_d2 = (_c2 = (_b3 = ctx2[3]) == null ? void 0 : _b3.remote) == null ? void 0 : _c2.creator) == null ? void 0 : _d2.id) === /*plugin*/
        ((_e2 = ctx2[0].relayManager.user) == null ? void 0 : _e2.id)
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$relayStore, $folderStore, plugin*/
          25) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_24(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_if_block_24(ctx) {
  let settingitemheading;
  let t2;
  let settingitem;
  let current;
  settingitemheading = new SettingItemHeading_default({ props: { name: "Remote Folder" } });
  settingitem = new SettingItem_default({
    props: {
      name: "Remove from relay",
      description: `Deletes the remote folder from the relay. Local files will be preserved.`,
      $$slots: { default: [create_default_slot_23] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitemheading.$$.fragment);
      t2 = space();
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitemheading, target, anchor);
      insert(target, t2, anchor);
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const settingitem_changes = {};
      if (dirty & /*$$scope*/
      1048576) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitemheading.$$.fragment, local);
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitemheading.$$.fragment, local);
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(settingitemheading, detaching);
      destroy_component(settingitem, detaching);
    }
  };
}
function create_default_slot_23(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element2("button");
      button.textContent = "Delete remote";
      attr(button, "class", "mod-destructive");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", (0, import_obsidian18.debounce)(
          /*handleDeleteRemote*/
          ctx[9]
        ));
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_else_block10(ctx) {
  let settingitem;
  let current;
  settingitem = new SettingItem_default({
    props: {
      description: "This folder is tracking edits, but is not connected to a Relay Server."
    }
  });
  return {
    c() {
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem, detaching);
    }
  };
}
function create_if_block15(ctx) {
  let slimsettingitem;
  let current;
  slimsettingitem = new SlimSettingItem_default({
    props: {
      $$slots: {
        name: [create_name_slot4],
        default: [create_default_slot_16]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(slimsettingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(slimsettingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const slimsettingitem_changes = {};
      if (dirty & /*$$scope, $relayStore*/
      1048592) {
        slimsettingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      slimsettingitem.$set(slimsettingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(slimsettingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(slimsettingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(slimsettingitem, detaching);
    }
  };
}
function create_default_slot_16(ctx) {
  let settingscontrol;
  let current;
  settingscontrol = new SettingsControl_default({});
  settingscontrol.$on("settings", function() {
    if (is_function((0, import_obsidian18.debounce)(
      /*settings_handler*/
      ctx[16]
    )))
      (0, import_obsidian18.debounce)(
        /*settings_handler*/
        ctx[16]
      ).apply(this, arguments);
  });
  return {
    c() {
      create_component(settingscontrol.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingscontrol, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    i(local) {
      if (current)
        return;
      transition_in(settingscontrol.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingscontrol.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingscontrol, detaching);
    }
  };
}
function create_default_slot26(ctx) {
  let t_value = (
    /*$relayStore*/
    ctx[4].name + ""
  );
  let t2;
  return {
    c() {
      t2 = text2(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$relayStore*/
      16 && t_value !== (t_value = /*$relayStore*/
      ctx2[4].name + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_name_slot4(ctx) {
  let satellite;
  let current;
  satellite = new Satellite_default({
    props: {
      slot: "name",
      relay: (
        /*$relayStore*/
        ctx[4]
      ),
      $$slots: { default: [create_default_slot26] },
      $$scope: { ctx }
    }
  });
  satellite.$on(
    "manageRelay",
    /*manageRelay_handler*/
    ctx[15]
  );
  return {
    c() {
      create_component(satellite.$$.fragment);
    },
    m(target, anchor) {
      mount_component(satellite, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const satellite_changes = {};
      if (dirty & /*$relayStore*/
      16)
        satellite_changes.relay = /*$relayStore*/
        ctx2[4];
      if (dirty & /*$$scope, $relayStore*/
      1048592) {
        satellite_changes.$$scope = { dirty, ctx: ctx2 };
      }
      satellite.$set(satellite_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(satellite.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(satellite.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(satellite, detaching);
    }
  };
}
function create_fragment47(ctx) {
  let breadcrumbs;
  let t0;
  let settingitemheading0;
  let t1;
  let settingitem0;
  let t2;
  let settingitem1;
  let t3;
  let t4;
  let settingitemheading1;
  let t5;
  let current_block_type_index;
  let if_block1;
  let if_block1_anchor;
  let current;
  breadcrumbs = new Breadcrumbs_default({
    props: {
      category: Folder_default,
      categoryText: "Shared Folders",
      $$slots: { default: [create_default_slot_52] },
      $$scope: { ctx }
    }
  });
  breadcrumbs.$on(
    "goBack",
    /*goBack*/
    ctx[7]
  );
  settingitemheading0 = new SettingItemHeading_default({ props: { name: "Local folder" } });
  settingitem0 = new SettingItem_default({
    props: {
      name: "Delete from vault",
      description: "Delete the local Shared Folder and all of its contents.",
      $$slots: { default: [create_default_slot_43] },
      $$scope: { ctx }
    }
  });
  settingitem1 = new SettingItem_default({
    props: {
      name: "Delete metadata",
      description: "Deletes edit history and disables change tracking.",
      $$slots: { default: [create_default_slot_33] },
      $$scope: { ctx }
    }
  });
  let if_block0 = (
    /*$relayStore*/
    ctx[4] && create_if_block_18(ctx)
  );
  settingitemheading1 = new SettingItemHeading_default({ props: { name: "Relay Server" } });
  const if_block_creators = [create_if_block15, create_else_block10];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$relayStore*/
      ctx2[4]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      create_component(breadcrumbs.$$.fragment);
      t0 = space();
      create_component(settingitemheading0.$$.fragment);
      t1 = space();
      create_component(settingitem0.$$.fragment);
      t2 = space();
      create_component(settingitem1.$$.fragment);
      t3 = space();
      if (if_block0)
        if_block0.c();
      t4 = space();
      create_component(settingitemheading1.$$.fragment);
      t5 = space();
      if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(breadcrumbs, target, anchor);
      insert(target, t0, anchor);
      mount_component(settingitemheading0, target, anchor);
      insert(target, t1, anchor);
      mount_component(settingitem0, target, anchor);
      insert(target, t2, anchor);
      mount_component(settingitem1, target, anchor);
      insert(target, t3, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t4, anchor);
      mount_component(settingitemheading1, target, anchor);
      insert(target, t5, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const breadcrumbs_changes = {};
      if (dirty & /*$$scope, sharedFolder*/
      1048578) {
        breadcrumbs_changes.$$scope = { dirty, ctx: ctx2 };
      }
      breadcrumbs.$set(breadcrumbs_changes);
      const settingitem0_changes = {};
      if (dirty & /*$$scope*/
      1048576) {
        settingitem0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem0.$set(settingitem0_changes);
      const settingitem1_changes = {};
      if (dirty & /*$$scope, $relayStore*/
      1048592) {
        settingitem1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem1.$set(settingitem1_changes);
      if (
        /*$relayStore*/
        ctx2[4]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$relayStore*/
          16) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_18(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t4.parentNode, t4);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(breadcrumbs.$$.fragment, local);
      transition_in(settingitemheading0.$$.fragment, local);
      transition_in(settingitem0.$$.fragment, local);
      transition_in(settingitem1.$$.fragment, local);
      transition_in(if_block0);
      transition_in(settingitemheading1.$$.fragment, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(breadcrumbs.$$.fragment, local);
      transition_out(settingitemheading0.$$.fragment, local);
      transition_out(settingitem0.$$.fragment, local);
      transition_out(settingitem1.$$.fragment, local);
      transition_out(if_block0);
      transition_out(settingitemheading1.$$.fragment, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
        detach(t5);
        detach(if_block1_anchor);
      }
      destroy_component(breadcrumbs, detaching);
      destroy_component(settingitemheading0, detaching);
      destroy_component(settingitem0, detaching);
      destroy_component(settingitem1, detaching);
      if (if_block0)
        if_block0.d(detaching);
      destroy_component(settingitemheading1, detaching);
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function instance46($$self, $$props, $$invalidate) {
  let $folderStore;
  let $sharedFolders, $$unsubscribe_sharedFolders = noop, $$subscribe_sharedFolders = () => ($$unsubscribe_sharedFolders(), $$unsubscribe_sharedFolders = subscribe2(sharedFolders, ($$value) => $$invalidate(17, $sharedFolders = $$value)), sharedFolders);
  let $relayStore;
  $$self.$$.on_destroy.push(() => $$unsubscribe_sharedFolders());
  let { plugin } = $$props;
  let { sharedFolder } = $$props;
  let { sharedFolders } = $$props;
  $$subscribe_sharedFolders();
  let { relayRoles } = $$props;
  let folderStore = derived($sharedFolders, ($sharedFolders2) => {
    return $sharedFolders2.find((folder) => folder === sharedFolder);
  });
  component_subscribe($$self, folderStore, (value) => $$invalidate(3, $folderStore = value));
  let relayStore = derived([folderStore, relayRoles], ([$folderStore2, $relayRoles]) => {
    var _a2;
    return (_a2 = $relayRoles.find((role) => {
      var _a3;
      return role.relay === ((_a3 = $folderStore2 === null || $folderStore2 === void 0 ? void 0 : $folderStore2.remote) === null || _a3 === void 0 ? void 0 : _a3.relay);
    })) === null || _a2 === void 0 ? void 0 : _a2.relay;
  });
  component_subscribe($$self, relayStore, (value) => $$invalidate(4, $relayStore = value));
  let nameInput;
  onMount(() => {
    if (!sharedFolder && nameInput && nameInput.value === "") {
      nameInput.focus();
    }
  });
  const dispatch = createEventDispatcher();
  function goBack() {
    return __awaiter(this, void 0, void 0, function* () {
      dispatch("goBack", { clear: true });
    });
  }
  function handleManageRelay(relay) {
    if (!relay) {
      return;
    }
    dispatch("manageRelay", { relay });
  }
  function handleDeleteRemote() {
    return __awaiter(this, void 0, void 0, function* () {
      yield plugin.relayManager.deleteRemote(sharedFolder);
      plugin.sharedFolders.notifyListeners();
    });
  }
  function handleDeleteMetadata() {
    return __awaiter(this, void 0, void 0, function* () {
      if ($folderStore) {
        plugin.sharedFolders.delete($folderStore);
      }
      dispatch("goBack", { clear: true });
    });
  }
  function handleDeleteLocal() {
    const folder = plugin.vault.getFolderByPath(sharedFolder.path);
    if (folder) {
      plugin.app.vault.trash(folder, false);
    }
    dispatch("goBack", {});
  }
  const click_handler = () => {
    handleDeleteLocal();
  };
  const click_handler_1 = () => {
    handleDeleteMetadata();
  };
  function manageRelay_handler(event) {
    bubble.call(this, $$self, event);
  }
  const settings_handler = () => {
    handleManageRelay($relayStore);
  };
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
    if ("sharedFolder" in $$props2)
      $$invalidate(1, sharedFolder = $$props2.sharedFolder);
    if ("sharedFolders" in $$props2)
      $$subscribe_sharedFolders($$invalidate(2, sharedFolders = $$props2.sharedFolders));
    if ("relayRoles" in $$props2)
      $$invalidate(12, relayRoles = $$props2.relayRoles);
  };
  return [
    plugin,
    sharedFolder,
    sharedFolders,
    $folderStore,
    $relayStore,
    folderStore,
    relayStore,
    goBack,
    handleManageRelay,
    handleDeleteRemote,
    handleDeleteMetadata,
    handleDeleteLocal,
    relayRoles,
    click_handler,
    click_handler_1,
    manageRelay_handler,
    settings_handler
  ];
}
var ManageSharedFolder = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance46, create_fragment47, safe_not_equal, {
      plugin: 0,
      sharedFolder: 1,
      sharedFolders: 2,
      relayRoles: 12
    });
  }
};
var ManageSharedFolder_default = ManageSharedFolder;

// src/components/PluginSettings.svelte
function add_css17(target) {
  append_styles(target, "svelte-iv3x1u", ".relay-version.svelte-iv3x1u{user-select:auto;background:var(--color-base-10);color:var(--text-faint);position:absolute;bottom:0;right:0;font-size:xx-small;padding-right:1em;padding-top:0.3em;padding-left:1em;border-top-left-radius:1em}.vertical-tab-content.svelte-iv3x1u{max-height:var(--modal-max-height);position:relative}.system3-announcement-banner.svelte-iv3x1u{padding-left:48px !important;background-color:var(--color-red) !important}.system3-announcement.svelte-iv3x1u{color:var(--text-on-accent)}");
}
function create_if_block_43(ctx) {
  let div;
  let span;
  let t_value = (
    /*plugin*/
    ctx[0].networkStatus.status + ""
  );
  let t2;
  return {
    c() {
      div = element2("div");
      span = element2("span");
      t2 = text2(t_value);
      attr(span, "class", "system3-announcement svelte-iv3x1u");
      attr(div, "class", "modal-setting-nav-bar system3-announcement-banner svelte-iv3x1u");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append2(div, span);
      append2(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*plugin*/
      1 && t_value !== (t_value = /*plugin*/
      ctx2[0].networkStatus.status + ""))
        set_data(t2, t_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block_33(ctx) {
  let modalsettingsnav;
  let current;
  modalsettingsnav = new ModalSettingsNav_default({});
  modalsettingsnav.$on(
    "goBack",
    /*handleGoBack*/
    ctx[9]
  );
  return {
    c() {
      create_component(modalsettingsnav.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modalsettingsnav, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(modalsettingsnav.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modalsettingsnav.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modalsettingsnav, detaching);
    }
  };
}
function create_else_block11(ctx) {
  let loggedin;
  let current;
  loggedin = new LoggedIn_default({
    props: {
      plugin: (
        /*plugin*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot27] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(loggedin.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loggedin, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const loggedin_changes = {};
      if (dirty & /*plugin*/
      1)
        loggedin_changes.plugin = /*plugin*/
        ctx2[0];
      if (dirty & /*$$scope, plugin*/
      1048577) {
        loggedin_changes.$$scope = { dirty, ctx: ctx2 };
      }
      loggedin.$set(loggedin_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(loggedin.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loggedin.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loggedin, detaching);
    }
  };
}
function create_if_block_25(ctx) {
  let managerelay;
  let current;
  managerelay = new ManageRelay_default({
    props: {
      plugin: (
        /*plugin*/
        ctx[0]
      ),
      relayRoles: (
        /*relayRoles*/
        ctx[3]
      ),
      relay: (
        /*currentRelay*/
        ctx[2]
      ),
      sharedFolders: (
        /*sharedFolders*/
        ctx[5]
      )
    }
  });
  managerelay.$on(
    "goBack",
    /*handleGoBack*/
    ctx[9]
  );
  managerelay.$on(
    "close",
    /*handleClose*/
    ctx[10]
  );
  managerelay.$on(
    "manageSharedFolder",
    /*handleManageSharedFolderEvent*/
    ctx[7]
  );
  return {
    c() {
      create_component(managerelay.$$.fragment);
    },
    m(target, anchor) {
      mount_component(managerelay, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const managerelay_changes = {};
      if (dirty & /*plugin*/
      1)
        managerelay_changes.plugin = /*plugin*/
        ctx2[0];
      if (dirty & /*currentRelay*/
      4)
        managerelay_changes.relay = /*currentRelay*/
        ctx2[2];
      managerelay.$set(managerelay_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(managerelay.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(managerelay.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(managerelay, detaching);
    }
  };
}
function create_if_block_19(ctx) {
  let managesharedfolder;
  let current;
  managesharedfolder = new ManageSharedFolder_default({
    props: {
      plugin: (
        /*plugin*/
        ctx[0]
      ),
      relayRoles: (
        /*relayRoles*/
        ctx[3]
      ),
      sharedFolder: (
        /*sharedFolder*/
        ctx[1]
      ),
      sharedFolders: (
        /*sharedFolders*/
        ctx[5]
      )
    }
  });
  managesharedfolder.$on(
    "goBack",
    /*handleGoBack*/
    ctx[9]
  );
  managesharedfolder.$on(
    "close",
    /*handleClose*/
    ctx[10]
  );
  managesharedfolder.$on(
    "manageRelay",
    /*handleManageRelayEvent*/
    ctx[6]
  );
  return {
    c() {
      create_component(managesharedfolder.$$.fragment);
    },
    m(target, anchor) {
      mount_component(managesharedfolder, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const managesharedfolder_changes = {};
      if (dirty & /*plugin*/
      1)
        managesharedfolder_changes.plugin = /*plugin*/
        ctx2[0];
      if (dirty & /*sharedFolder*/
      2)
        managesharedfolder_changes.sharedFolder = /*sharedFolder*/
        ctx2[1];
      managesharedfolder.$set(managesharedfolder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(managesharedfolder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(managesharedfolder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(managesharedfolder, detaching);
    }
  };
}
function create_default_slot27(ctx) {
  let relays_1;
  let current;
  relays_1 = new Relays_default({
    props: {
      relays: (
        /*relays*/
        ctx[4]
      ),
      plugin: (
        /*plugin*/
        ctx[0]
      )
    }
  });
  relays_1.$on(
    "manageRelay",
    /*handleManageRelayEvent*/
    ctx[6]
  );
  relays_1.$on(
    "manageSharedFolder",
    /*handleManageSharedFolderEvent*/
    ctx[7]
  );
  relays_1.$on(
    "createRelay",
    /*handleCreateRelayEvent*/
    ctx[8]
  );
  relays_1.$on(
    "joinRelay",
    /*handleJoinRelay*/
    ctx[11]
  );
  return {
    c() {
      create_component(relays_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(relays_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const relays_1_changes = {};
      if (dirty & /*plugin*/
      1)
        relays_1_changes.plugin = /*plugin*/
        ctx2[0];
      relays_1.$set(relays_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(relays_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(relays_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(relays_1, detaching);
    }
  };
}
function create_if_block16(ctx) {
  let span;
  let t_value = (
    /*plugin*/
    ctx[0].version + ""
  );
  let t2;
  return {
    c() {
      span = element2("span");
      t2 = text2(t_value);
      attr(span, "class", "relay-version svelte-iv3x1u");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append2(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*plugin*/
      1 && t_value !== (t_value = /*plugin*/
      ctx2[0].version + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_fragment48(ctx) {
  let current_block_type_index;
  let if_block0;
  let t0;
  let div;
  let current_block_type_index_1;
  let if_block1;
  let t1;
  let if_block2_anchor;
  let current;
  const if_block_creators = [create_if_block_33, create_if_block_43];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*currentRelay*/
      ctx2[2] || /*sharedFolder*/
      ctx2[1]
    )
      return 0;
    if (
      /*plugin*/
      ctx2[0].networkStatus.status
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const if_block_creators_1 = [create_if_block_19, create_if_block_25, create_else_block11];
  const if_blocks_1 = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*sharedFolder*/
      ctx2[1]
    )
      return 0;
    if (
      /*currentRelay*/
      ctx2[2]
    )
      return 1;
    return 2;
  }
  current_block_type_index_1 = select_block_type_1(ctx, -1);
  if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
  let if_block2 = (
    /*plugin*/
    ctx[0].manifest.version !== /*plugin*/
    ctx[0].version && create_if_block16(ctx)
  );
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      div = element2("div");
      if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
      attr(div, "class", "vertical-tab-content svelte-iv3x1u");
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, t0, anchor);
      insert(target, div, anchor);
      if_blocks_1[current_block_type_index_1].m(div, null);
      insert(target, t1, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block0) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block0 = if_blocks[current_block_type_index];
          if (!if_block0) {
            if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block0.c();
          } else {
            if_block0.p(ctx2, dirty);
          }
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        } else {
          if_block0 = null;
        }
      }
      let previous_block_index_1 = current_block_type_index_1;
      current_block_type_index_1 = select_block_type_1(ctx2, dirty);
      if (current_block_type_index_1 === previous_block_index_1) {
        if_blocks_1[current_block_type_index_1].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
          if_blocks_1[previous_block_index_1] = null;
        });
        check_outros();
        if_block1 = if_blocks_1[current_block_type_index_1];
        if (!if_block1) {
          if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(div, null);
      }
      if (
        /*plugin*/
        ctx2[0].manifest.version !== /*plugin*/
        ctx2[0].version
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block16(ctx2);
          if_block2.c();
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(div);
        detach(t1);
        detach(if_block2_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if_blocks_1[current_block_type_index_1].d();
      if (if_block2)
        if_block2.d(detaching);
    }
  };
}
function instance47($$self, $$props, $$invalidate) {
  let $relays;
  let { plugin } = $$props;
  let { path = void 0 } = $$props;
  const app = plugin.app;
  const relayManager = plugin.relayManager;
  const relayRoles = relayManager.relayRoles;
  const relays = relayManager.relays;
  component_subscribe($$self, relays, (value) => $$invalidate(15, $relays = value));
  const sharedFolders = plugin.sharedFolders;
  let sharedFolder;
  let currentComponent = Relays_default;
  let currentRelay;
  const history = [{ component: Relays_default }];
  let { close } = $$props;
  function setPath(path2) {
    $$invalidate(2, currentRelay = void 0);
    $$invalidate(1, sharedFolder = void 0);
    if (path2 === "/") {
      $$invalidate(14, currentComponent = Relays_default);
      return;
    }
    const urlParams = new URLSearchParams(path2.split("?")[1] || "");
    const id2 = urlParams.get("id");
    if (path2.startsWith("/relays")) {
      if (id2) {
        $$invalidate(2, currentRelay = relayManager.relays.find((relay) => relay.guid === id2));
        $$invalidate(14, currentComponent = ManageRelay_default);
      } else {
        $$invalidate(14, currentComponent = Relays_default);
      }
      return;
    }
    if (path2.startsWith("/shared-folders")) {
      if (id2) {
        $$invalidate(1, sharedFolder = sharedFolders.find((f) => f.guid === id2));
        const relayId = urlParams.get("relay");
        if (relayId) {
          $$invalidate(2, currentRelay = relayManager.relays.get(relayId));
        }
        $$invalidate(14, currentComponent = ManageSharedFolder_default);
      }
      return;
    }
  }
  function handleManageRelayEvent(event) {
    history.push({
      currentRelay,
      sharedFolder,
      component: currentComponent
    });
    $$invalidate(2, currentRelay = event.detail.relay);
    $$invalidate(1, sharedFolder = void 0);
    $$invalidate(14, currentComponent = ManageRelay_default);
  }
  function handleManageSharedFolderEvent(event) {
    history.push({
      currentRelay,
      sharedFolder,
      component: currentComponent
    });
    $$invalidate(1, sharedFolder = event.detail.folder);
    $$invalidate(2, currentRelay = event.detail.relay);
  }
  function handleCreateRelayEvent(event) {
    return __awaiter(this, void 0, void 0, function* () {
      history.push({
        currentRelay,
        sharedFolder,
        component: currentComponent
      });
      $$invalidate(2, currentRelay = yield plugin.relayManager.createRelay(""));
      $$invalidate(14, currentComponent = ManageRelay_default);
    });
  }
  function handleGoBack(event) {
    if (event.detail.clear) {
      history.length = 0;
      $$invalidate(2, currentRelay = void 0);
      $$invalidate(1, sharedFolder = void 0);
      $$invalidate(14, currentComponent = Relays_default);
      return;
    }
    let view = history.pop();
    if (view) {
      while (view) {
        if (!view.currentRelay && !view.sharedFolder) {
          $$invalidate(2, currentRelay = view.currentRelay);
          $$invalidate(1, sharedFolder = view.sharedFolder);
          $$invalidate(14, currentComponent = view.component);
        } else if (view.sharedFolder && sharedFolders.has(view.sharedFolder)) {
          $$invalidate(2, currentRelay = view.currentRelay);
          $$invalidate(1, sharedFolder = view.sharedFolder);
          $$invalidate(14, currentComponent = view.component);
          break;
        } else if (view.currentRelay && relayManager.relays.get(view.currentRelay.id)) {
          $$invalidate(2, currentRelay = view.currentRelay);
          $$invalidate(1, sharedFolder = view.sharedFolder);
          $$invalidate(14, currentComponent = view.component);
          break;
        }
        view = history.pop();
      }
    } else {
      $$invalidate(2, currentRelay = void 0);
      $$invalidate(1, sharedFolder = void 0);
      $$invalidate(14, currentComponent = Relays_default);
    }
  }
  function handleClose(event) {
    history.length = 0;
    close();
  }
  function handleJoinRelay(event) {
    $$invalidate(2, currentRelay = event.detail.relay);
    $$invalidate(14, currentComponent = ManageRelay_default);
  }
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
    if ("path" in $$props2)
      $$invalidate(12, path = $$props2.path);
    if ("close" in $$props2)
      $$invalidate(13, close = $$props2.close);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*path*/
    4096) {
      $: {
        if (path) {
          setPath(path);
        }
      }
    }
    if ($$self.$$.dirty & /*currentRelay, $relays*/
    32772) {
      $: {
        if (currentRelay && !$relays.has(currentRelay.id)) {
          $$invalidate(2, currentRelay = void 0);
          $$invalidate(14, currentComponent = Relays_default);
        }
      }
    }
    if ($$self.$$.dirty & /*sharedFolder*/
    2) {
      $: {
        if (sharedFolder && !sharedFolders.has(sharedFolder)) {
          $$invalidate(1, sharedFolder = void 0);
          $$invalidate(14, currentComponent = Relays_default);
        }
      }
    }
    if ($$self.$$.dirty & /*currentComponent, currentRelay, sharedFolder*/
    16390) {
      $:
        if (currentComponent || currentRelay || sharedFolder) {
          setTimeout(
            () => {
              const content = document.querySelector(".vertical-tab-content");
              if (content) {
                content.scrollTop = 0;
              }
            },
            0
          );
        }
    }
  };
  return [
    plugin,
    sharedFolder,
    currentRelay,
    relayRoles,
    relays,
    sharedFolders,
    handleManageRelayEvent,
    handleManageSharedFolderEvent,
    handleCreateRelayEvent,
    handleGoBack,
    handleClose,
    handleJoinRelay,
    path,
    close,
    currentComponent,
    $relays
  ];
}
var PluginSettings = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance47, create_fragment48, safe_not_equal, { plugin: 0, path: 12, close: 13 }, add_css17);
  }
};
var PluginSettings_default = PluginSettings;

// src/ui/SettingsTab.ts
var LiveSettingsTab = class extends import_obsidian19.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    this.targetEl = containerEl.parentElement;
    this.targetEl.empty();
    this.plugin.relayManager.update();
    this.component = new PluginSettings_default({
      target: this.targetEl,
      props: {
        plugin: this.plugin,
        close: () => {
          this.setting.close();
        }
      }
    });
  }
  navigateTo(path) {
    var _a2;
    (_a2 = this.component) == null ? void 0 : _a2.$set({
      path
    });
  }
  hide() {
    var _a2;
    try {
      (_a2 = this.component) == null ? void 0 : _a2.$destroy();
    } catch (e2) {
      console.warn(e2);
    }
  }
  destroy() {
    this.hide();
    this.plugin = null;
  }
};

// src/LoginManager.ts
var import_obsidian20 = require("obsidian");

// node_modules/pocketbase/dist/pocketbase.es.mjs
var ClientResponseError = class extends Error {
  constructor(e2) {
    var _a2, _b2, _c, _d;
    super("ClientResponseError"), this.url = "", this.status = 0, this.response = {}, this.isAbort = false, this.originalError = null, Object.setPrototypeOf(this, ClientResponseError.prototype), null !== e2 && "object" == typeof e2 && (this.url = "string" == typeof e2.url ? e2.url : "", this.status = "number" == typeof e2.status ? e2.status : 0, this.isAbort = !!e2.isAbort, this.originalError = e2.originalError, null !== e2.response && "object" == typeof e2.response ? this.response = e2.response : null !== e2.data && "object" == typeof e2.data ? this.response = e2.data : this.response = {}), this.originalError || e2 instanceof ClientResponseError || (this.originalError = e2), "undefined" != typeof DOMException && e2 instanceof DOMException && (this.isAbort = true), this.name = "ClientResponseError " + this.status, this.message = (_a2 = this.response) == null ? void 0 : _a2.message, this.message || (this.isAbort ? this.message = "The request was autocancelled. You can find more info in https://github.com/pocketbase/js-sdk#auto-cancellation." : ((_d = (_c = (_b2 = this.originalError) == null ? void 0 : _b2.cause) == null ? void 0 : _c.message) == null ? void 0 : _d.includes("ECONNREFUSED ::1")) ? this.message = "Failed to connect to the PocketBase server. Try changing the SDK URL from localhost to 127.0.0.1 (https://github.com/pocketbase/js-sdk/issues/21)." : this.message = "Something went wrong while processing your request.");
  }
  get data() {
    return this.response;
  }
  toJSON() {
    return { ...this };
  }
};
var e = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
function cookieParse(e2, t2) {
  const s2 = {};
  if ("string" != typeof e2)
    return s2;
  const i2 = Object.assign({}, t2 || {}).decode || defaultDecode;
  let n = 0;
  for (; n < e2.length; ) {
    const t3 = e2.indexOf("=", n);
    if (-1 === t3)
      break;
    let r = e2.indexOf(";", n);
    if (-1 === r)
      r = e2.length;
    else if (r < t3) {
      n = e2.lastIndexOf(";", t3 - 1) + 1;
      continue;
    }
    const o = e2.slice(n, t3).trim();
    if (void 0 === s2[o]) {
      let n2 = e2.slice(t3 + 1, r).trim();
      34 === n2.charCodeAt(0) && (n2 = n2.slice(1, -1));
      try {
        s2[o] = i2(n2);
      } catch (e3) {
        s2[o] = n2;
      }
    }
    n = r + 1;
  }
  return s2;
}
function cookieSerialize(t2, s2, i2) {
  const n = Object.assign({}, i2 || {}), r = n.encode || defaultEncode;
  if (!e.test(t2))
    throw new TypeError("argument name is invalid");
  const o = r(s2);
  if (o && !e.test(o))
    throw new TypeError("argument val is invalid");
  let a = t2 + "=" + o;
  if (null != n.maxAge) {
    const e2 = n.maxAge - 0;
    if (isNaN(e2) || !isFinite(e2))
      throw new TypeError("option maxAge is invalid");
    a += "; Max-Age=" + Math.floor(e2);
  }
  if (n.domain) {
    if (!e.test(n.domain))
      throw new TypeError("option domain is invalid");
    a += "; Domain=" + n.domain;
  }
  if (n.path) {
    if (!e.test(n.path))
      throw new TypeError("option path is invalid");
    a += "; Path=" + n.path;
  }
  if (n.expires) {
    if (!function isDate(e2) {
      return "[object Date]" === Object.prototype.toString.call(e2) || e2 instanceof Date;
    }(n.expires) || isNaN(n.expires.valueOf()))
      throw new TypeError("option expires is invalid");
    a += "; Expires=" + n.expires.toUTCString();
  }
  if (n.httpOnly && (a += "; HttpOnly"), n.secure && (a += "; Secure"), n.priority) {
    switch ("string" == typeof n.priority ? n.priority.toLowerCase() : n.priority) {
      case "low":
        a += "; Priority=Low";
        break;
      case "medium":
        a += "; Priority=Medium";
        break;
      case "high":
        a += "; Priority=High";
        break;
      default:
        throw new TypeError("option priority is invalid");
    }
  }
  if (n.sameSite) {
    switch ("string" == typeof n.sameSite ? n.sameSite.toLowerCase() : n.sameSite) {
      case true:
        a += "; SameSite=Strict";
        break;
      case "lax":
        a += "; SameSite=Lax";
        break;
      case "strict":
        a += "; SameSite=Strict";
        break;
      case "none":
        a += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return a;
}
function defaultDecode(e2) {
  return -1 !== e2.indexOf("%") ? decodeURIComponent(e2) : e2;
}
function defaultEncode(e2) {
  return encodeURIComponent(e2);
}
var t;
function getTokenPayload(e2) {
  if (e2)
    try {
      const s2 = decodeURIComponent(t(e2.split(".")[1]).split("").map(function(e3) {
        return "%" + ("00" + e3.charCodeAt(0).toString(16)).slice(-2);
      }).join(""));
      return JSON.parse(s2) || {};
    } catch (e3) {
    }
  return {};
}
function isTokenExpired(e2, t2 = 0) {
  let s2 = getTokenPayload(e2);
  return !(Object.keys(s2).length > 0 && (!s2.exp || s2.exp - t2 > Date.now() / 1e3));
}
t = "function" == typeof atob ? atob : (e2) => {
  let t2 = String(e2).replace(/=+$/, "");
  if (t2.length % 4 == 1)
    throw new Error("'atob' failed: The string to be decoded is not correctly encoded.");
  for (var s2, i2, n = 0, r = 0, o = ""; i2 = t2.charAt(r++); ~i2 && (s2 = n % 4 ? 64 * s2 + i2 : i2, n++ % 4) ? o += String.fromCharCode(255 & s2 >> (-2 * n & 6)) : 0)
    i2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(i2);
  return o;
};
var s = "pb_auth";
var BaseAuthStore = class {
  constructor() {
    this.baseToken = "", this.baseModel = null, this._onChangeCallbacks = [];
  }
  get token() {
    return this.baseToken;
  }
  get model() {
    return this.baseModel;
  }
  get isValid() {
    return !isTokenExpired(this.token);
  }
  get isAdmin() {
    return "admin" === getTokenPayload(this.token).type;
  }
  get isAuthRecord() {
    return "authRecord" === getTokenPayload(this.token).type;
  }
  save(e2, t2) {
    this.baseToken = e2 || "", this.baseModel = t2 || null, this.triggerChange();
  }
  clear() {
    this.baseToken = "", this.baseModel = null, this.triggerChange();
  }
  loadFromCookie(e2, t2 = s) {
    const i2 = cookieParse(e2 || "")[t2] || "";
    let n = {};
    try {
      n = JSON.parse(i2), (null === typeof n || "object" != typeof n || Array.isArray(n)) && (n = {});
    } catch (e3) {
    }
    this.save(n.token || "", n.model || null);
  }
  exportToCookie(e2, t2 = s) {
    var _a2, _b2;
    const i2 = { secure: true, sameSite: true, httpOnly: true, path: "/" }, n = getTokenPayload(this.token);
    i2.expires = (n == null ? void 0 : n.exp) ? new Date(1e3 * n.exp) : new Date("1970-01-01"), e2 = Object.assign({}, i2, e2);
    const r = { token: this.token, model: this.model ? JSON.parse(JSON.stringify(this.model)) : null };
    let o = cookieSerialize(t2, JSON.stringify(r), e2);
    const a = "undefined" != typeof Blob ? new Blob([o]).size : o.length;
    if (r.model && a > 4096) {
      r.model = { id: (_a2 = r == null ? void 0 : r.model) == null ? void 0 : _a2.id, email: (_b2 = r == null ? void 0 : r.model) == null ? void 0 : _b2.email };
      const s2 = ["collectionId", "username", "verified"];
      for (const e3 in this.model)
        s2.includes(e3) && (r.model[e3] = this.model[e3]);
      o = cookieSerialize(t2, JSON.stringify(r), e2);
    }
    return o;
  }
  onChange(e2, t2 = false) {
    return this._onChangeCallbacks.push(e2), t2 && e2(this.token, this.model), () => {
      for (let t3 = this._onChangeCallbacks.length - 1; t3 >= 0; t3--)
        if (this._onChangeCallbacks[t3] == e2)
          return delete this._onChangeCallbacks[t3], void this._onChangeCallbacks.splice(t3, 1);
    };
  }
  triggerChange() {
    for (const e2 of this._onChangeCallbacks)
      e2 && e2(this.token, this.model);
  }
};
var LocalAuthStore = class extends BaseAuthStore {
  constructor(e2 = "pocketbase_auth") {
    super(), this.storageFallback = {}, this.storageKey = e2, this._bindStorageEvent();
  }
  get token() {
    return (this._storageGet(this.storageKey) || {}).token || "";
  }
  get model() {
    return (this._storageGet(this.storageKey) || {}).model || null;
  }
  save(e2, t2) {
    this._storageSet(this.storageKey, { token: e2, model: t2 }), super.save(e2, t2);
  }
  clear() {
    this._storageRemove(this.storageKey), super.clear();
  }
  _storageGet(e2) {
    if ("undefined" != typeof window && (window == null ? void 0 : window.localStorage)) {
      const t2 = window.localStorage.getItem(e2) || "";
      try {
        return JSON.parse(t2);
      } catch (e3) {
        return t2;
      }
    }
    return this.storageFallback[e2];
  }
  _storageSet(e2, t2) {
    if ("undefined" != typeof window && (window == null ? void 0 : window.localStorage)) {
      let s2 = t2;
      "string" != typeof t2 && (s2 = JSON.stringify(t2)), window.localStorage.setItem(e2, s2);
    } else
      this.storageFallback[e2] = t2;
  }
  _storageRemove(e2) {
    var _a2;
    "undefined" != typeof window && (window == null ? void 0 : window.localStorage) && ((_a2 = window.localStorage) == null ? void 0 : _a2.removeItem(e2)), delete this.storageFallback[e2];
  }
  _bindStorageEvent() {
    "undefined" != typeof window && (window == null ? void 0 : window.localStorage) && window.addEventListener && window.addEventListener("storage", (e2) => {
      if (e2.key != this.storageKey)
        return;
      const t2 = this._storageGet(this.storageKey) || {};
      super.save(t2.token || "", t2.model || null);
    });
  }
};
var BaseService = class {
  constructor(e2) {
    this.client = e2;
  }
};
var SettingsService = class extends BaseService {
  async getAll(e2) {
    return e2 = Object.assign({ method: "GET" }, e2), this.client.send("/api/settings", e2);
  }
  async update(e2, t2) {
    return t2 = Object.assign({ method: "PATCH", body: e2 }, t2), this.client.send("/api/settings", t2);
  }
  async testS3(e2 = "storage", t2) {
    return t2 = Object.assign({ method: "POST", body: { filesystem: e2 } }, t2), this.client.send("/api/settings/test/s3", t2).then(() => true);
  }
  async testEmail(e2, t2, s2) {
    return s2 = Object.assign({ method: "POST", body: { email: e2, template: t2 } }, s2), this.client.send("/api/settings/test/email", s2).then(() => true);
  }
  async generateAppleClientSecret(e2, t2, s2, i2, n, r) {
    return r = Object.assign({ method: "POST", body: { clientId: e2, teamId: t2, keyId: s2, privateKey: i2, duration: n } }, r), this.client.send("/api/settings/apple/generate-client-secret", r);
  }
};
var CrudService = class extends BaseService {
  decode(e2) {
    return e2;
  }
  async getFullList(e2, t2) {
    if ("number" == typeof e2)
      return this._getFullList(e2, t2);
    let s2 = 500;
    return (t2 = Object.assign({}, e2, t2)).batch && (s2 = t2.batch, delete t2.batch), this._getFullList(s2, t2);
  }
  async getList(e2 = 1, t2 = 30, s2) {
    return (s2 = Object.assign({ method: "GET" }, s2)).query = Object.assign({ page: e2, perPage: t2 }, s2.query), this.client.send(this.baseCrudPath, s2).then((e3) => {
      var _a2;
      return e3.items = ((_a2 = e3.items) == null ? void 0 : _a2.map((e4) => this.decode(e4))) || [], e3;
    });
  }
  async getFirstListItem(e2, t2) {
    return (t2 = Object.assign({ requestKey: "one_by_filter_" + this.baseCrudPath + "_" + e2 }, t2)).query = Object.assign({ filter: e2, skipTotal: 1 }, t2.query), this.getList(1, 1, t2).then((e3) => {
      var _a2;
      if (!((_a2 = e3 == null ? void 0 : e3.items) == null ? void 0 : _a2.length))
        throw new ClientResponseError({ status: 404, response: { code: 404, message: "The requested resource wasn't found.", data: {} } });
      return e3.items[0];
    });
  }
  async getOne(e2, t2) {
    if (!e2)
      throw new ClientResponseError({ url: this.client.buildUrl(this.baseCrudPath + "/"), status: 404, response: { code: 404, message: "Missing required record id.", data: {} } });
    return t2 = Object.assign({ method: "GET" }, t2), this.client.send(this.baseCrudPath + "/" + encodeURIComponent(e2), t2).then((e3) => this.decode(e3));
  }
  async create(e2, t2) {
    return t2 = Object.assign({ method: "POST", body: e2 }, t2), this.client.send(this.baseCrudPath, t2).then((e3) => this.decode(e3));
  }
  async update(e2, t2, s2) {
    return s2 = Object.assign({ method: "PATCH", body: t2 }, s2), this.client.send(this.baseCrudPath + "/" + encodeURIComponent(e2), s2).then((e3) => this.decode(e3));
  }
  async delete(e2, t2) {
    return t2 = Object.assign({ method: "DELETE" }, t2), this.client.send(this.baseCrudPath + "/" + encodeURIComponent(e2), t2).then(() => true);
  }
  _getFullList(e2 = 500, t2) {
    (t2 = t2 || {}).query = Object.assign({ skipTotal: 1 }, t2.query);
    let s2 = [], request = async (i2) => this.getList(i2, e2 || 500, t2).then((e3) => {
      const t3 = e3.items;
      return s2 = s2.concat(t3), t3.length == e3.perPage ? request(i2 + 1) : s2;
    });
    return request(1);
  }
};
function normalizeLegacyOptionsArgs(e2, t2, s2, i2) {
  const n = void 0 !== i2;
  return n || void 0 !== s2 ? n ? (console.warn(e2), t2.body = Object.assign({}, t2.body, s2), t2.query = Object.assign({}, t2.query, i2), t2) : Object.assign(t2, s2) : t2;
}
function resetAutoRefresh(e2) {
  var _a2;
  (_a2 = e2._resetAutoRefresh) == null ? void 0 : _a2.call(e2);
}
var AdminService = class extends CrudService {
  get baseCrudPath() {
    return "/api/admins";
  }
  async update(e2, t2, s2) {
    return super.update(e2, t2, s2).then((e3) => {
      var _a2, _b2;
      return ((_a2 = this.client.authStore.model) == null ? void 0 : _a2.id) === e3.id && void 0 === ((_b2 = this.client.authStore.model) == null ? void 0 : _b2.collectionId) && this.client.authStore.save(this.client.authStore.token, e3), e3;
    });
  }
  async delete(e2, t2) {
    return super.delete(e2, t2).then((t3) => {
      var _a2, _b2;
      return t3 && ((_a2 = this.client.authStore.model) == null ? void 0 : _a2.id) === e2 && void 0 === ((_b2 = this.client.authStore.model) == null ? void 0 : _b2.collectionId) && this.client.authStore.clear(), t3;
    });
  }
  authResponse(e2) {
    const t2 = this.decode((e2 == null ? void 0 : e2.admin) || {});
    return (e2 == null ? void 0 : e2.token) && (e2 == null ? void 0 : e2.admin) && this.client.authStore.save(e2.token, t2), Object.assign({}, e2, { token: (e2 == null ? void 0 : e2.token) || "", admin: t2 });
  }
  async authWithPassword(e2, t2, s2, i2) {
    let n = { method: "POST", body: { identity: e2, password: t2 } };
    n = normalizeLegacyOptionsArgs("This form of authWithPassword(email, pass, body?, query?) is deprecated. Consider replacing it with authWithPassword(email, pass, options?).", n, s2, i2);
    const r = n.autoRefreshThreshold;
    delete n.autoRefreshThreshold, n.autoRefresh || resetAutoRefresh(this.client);
    let o = await this.client.send(this.baseCrudPath + "/auth-with-password", n);
    return o = this.authResponse(o), r && function registerAutoRefresh(e3, t3, s3, i3) {
      resetAutoRefresh(e3);
      const n2 = e3.beforeSend, r2 = e3.authStore.model, o2 = e3.authStore.onChange((t4, s4) => {
        (!t4 || (s4 == null ? void 0 : s4.id) != (r2 == null ? void 0 : r2.id) || ((s4 == null ? void 0 : s4.collectionId) || (r2 == null ? void 0 : r2.collectionId)) && (s4 == null ? void 0 : s4.collectionId) != (r2 == null ? void 0 : r2.collectionId)) && resetAutoRefresh(e3);
      });
      e3._resetAutoRefresh = function() {
        o2(), e3.beforeSend = n2, delete e3._resetAutoRefresh;
      }, e3.beforeSend = async (r3, o3) => {
        var _a2;
        const a = e3.authStore.token;
        if ((_a2 = o3.query) == null ? void 0 : _a2.autoRefresh)
          return n2 ? n2(r3, o3) : { url: r3, sendOptions: o3 };
        let c = e3.authStore.isValid;
        if (c && isTokenExpired(e3.authStore.token, t3))
          try {
            await s3();
          } catch (e4) {
            c = false;
          }
        c || await i3();
        const l = o3.headers || {};
        for (let t4 in l)
          if ("authorization" == t4.toLowerCase() && a == l[t4] && e3.authStore.token) {
            l[t4] = e3.authStore.token;
            break;
          }
        return o3.headers = l, n2 ? n2(r3, o3) : { url: r3, sendOptions: o3 };
      };
    }(this.client, r, () => this.authRefresh({ autoRefresh: true }), () => this.authWithPassword(e2, t2, Object.assign({ autoRefresh: true }, n))), o;
  }
  async authRefresh(e2, t2) {
    let s2 = { method: "POST" };
    return s2 = normalizeLegacyOptionsArgs("This form of authRefresh(body?, query?) is deprecated. Consider replacing it with authRefresh(options?).", s2, e2, t2), this.client.send(this.baseCrudPath + "/auth-refresh", s2).then(this.authResponse.bind(this));
  }
  async requestPasswordReset(e2, t2, s2) {
    let i2 = { method: "POST", body: { email: e2 } };
    return i2 = normalizeLegacyOptionsArgs("This form of requestPasswordReset(email, body?, query?) is deprecated. Consider replacing it with requestPasswordReset(email, options?).", i2, t2, s2), this.client.send(this.baseCrudPath + "/request-password-reset", i2).then(() => true);
  }
  async confirmPasswordReset(e2, t2, s2, i2, n) {
    let r = { method: "POST", body: { token: e2, password: t2, passwordConfirm: s2 } };
    return r = normalizeLegacyOptionsArgs("This form of confirmPasswordReset(resetToken, password, passwordConfirm, body?, query?) is deprecated. Consider replacing it with confirmPasswordReset(resetToken, password, passwordConfirm, options?).", r, i2, n), this.client.send(this.baseCrudPath + "/confirm-password-reset", r).then(() => true);
  }
};
var i = ["requestKey", "$cancelKey", "$autoCancel", "fetch", "headers", "body", "query", "params", "cache", "credentials", "headers", "integrity", "keepalive", "method", "mode", "redirect", "referrer", "referrerPolicy", "signal", "window"];
function normalizeUnknownQueryParams(e2) {
  if (e2) {
    e2.query = e2.query || {};
    for (let t2 in e2)
      i.includes(t2) || (e2.query[t2] = e2[t2], delete e2[t2]);
  }
}
var RealtimeService = class extends BaseService {
  constructor() {
    super(...arguments), this.clientId = "", this.eventSource = null, this.subscriptions = {}, this.lastSentSubscriptions = [], this.maxConnectTimeout = 15e3, this.reconnectAttempts = 0, this.maxReconnectAttempts = 1 / 0, this.predefinedReconnectIntervals = [200, 300, 500, 1e3, 1200, 1500, 2e3], this.pendingConnects = [];
  }
  get isConnected() {
    return !!this.eventSource && !!this.clientId && !this.pendingConnects.length;
  }
  async subscribe(e2, t2, s2) {
    var _a2;
    if (!e2)
      throw new Error("topic must be set.");
    let i2 = e2;
    if (s2) {
      normalizeUnknownQueryParams(s2);
      const e3 = "options=" + encodeURIComponent(JSON.stringify({ query: s2.query, headers: s2.headers }));
      i2 += (i2.includes("?") ? "&" : "?") + e3;
    }
    const listener = function(e3) {
      const s3 = e3;
      let i3;
      try {
        i3 = JSON.parse(s3 == null ? void 0 : s3.data);
      } catch (e4) {
      }
      t2(i3 || {});
    };
    return this.subscriptions[i2] || (this.subscriptions[i2] = []), this.subscriptions[i2].push(listener), this.isConnected ? 1 === this.subscriptions[i2].length ? await this.submitSubscriptions() : (_a2 = this.eventSource) == null ? void 0 : _a2.addEventListener(i2, listener) : await this.connect(), async () => this.unsubscribeByTopicAndListener(e2, listener);
  }
  async unsubscribe(e2) {
    var _a2;
    let t2 = false;
    if (e2) {
      const s2 = this.getSubscriptionsByTopic(e2);
      for (let e3 in s2)
        if (this.hasSubscriptionListeners(e3)) {
          for (let t3 of this.subscriptions[e3])
            (_a2 = this.eventSource) == null ? void 0 : _a2.removeEventListener(e3, t3);
          delete this.subscriptions[e3], t2 || (t2 = true);
        }
    } else
      this.subscriptions = {};
    this.hasSubscriptionListeners() ? t2 && await this.submitSubscriptions() : this.disconnect();
  }
  async unsubscribeByPrefix(e2) {
    var _a2;
    let t2 = false;
    for (let s2 in this.subscriptions)
      if ((s2 + "?").startsWith(e2)) {
        t2 = true;
        for (let e3 of this.subscriptions[s2])
          (_a2 = this.eventSource) == null ? void 0 : _a2.removeEventListener(s2, e3);
        delete this.subscriptions[s2];
      }
    t2 && (this.hasSubscriptionListeners() ? await this.submitSubscriptions() : this.disconnect());
  }
  async unsubscribeByTopicAndListener(e2, t2) {
    var _a2;
    let s2 = false;
    const i2 = this.getSubscriptionsByTopic(e2);
    for (let e3 in i2) {
      if (!Array.isArray(this.subscriptions[e3]) || !this.subscriptions[e3].length)
        continue;
      let i3 = false;
      for (let s3 = this.subscriptions[e3].length - 1; s3 >= 0; s3--)
        this.subscriptions[e3][s3] === t2 && (i3 = true, delete this.subscriptions[e3][s3], this.subscriptions[e3].splice(s3, 1), (_a2 = this.eventSource) == null ? void 0 : _a2.removeEventListener(e3, t2));
      i3 && (this.subscriptions[e3].length || delete this.subscriptions[e3], s2 || this.hasSubscriptionListeners(e3) || (s2 = true));
    }
    this.hasSubscriptionListeners() ? s2 && await this.submitSubscriptions() : this.disconnect();
  }
  hasSubscriptionListeners(e2) {
    var _a2, _b2;
    if (this.subscriptions = this.subscriptions || {}, e2)
      return !!((_a2 = this.subscriptions[e2]) == null ? void 0 : _a2.length);
    for (let e3 in this.subscriptions)
      if ((_b2 = this.subscriptions[e3]) == null ? void 0 : _b2.length)
        return true;
    return false;
  }
  async submitSubscriptions() {
    if (this.clientId)
      return this.addAllSubscriptionListeners(), this.lastSentSubscriptions = this.getNonEmptySubscriptionKeys(), this.client.send("/api/realtime", { method: "POST", body: { clientId: this.clientId, subscriptions: this.lastSentSubscriptions }, requestKey: this.getSubscriptionsCancelKey() }).catch((e2) => {
        if (!(e2 == null ? void 0 : e2.isAbort))
          throw e2;
      });
  }
  getSubscriptionsCancelKey() {
    return "realtime_" + this.clientId;
  }
  getSubscriptionsByTopic(e2) {
    const t2 = {};
    e2 = e2.includes("?") ? e2 : e2 + "?";
    for (let s2 in this.subscriptions)
      (s2 + "?").startsWith(e2) && (t2[s2] = this.subscriptions[s2]);
    return t2;
  }
  getNonEmptySubscriptionKeys() {
    const e2 = [];
    for (let t2 in this.subscriptions)
      this.subscriptions[t2].length && e2.push(t2);
    return e2;
  }
  addAllSubscriptionListeners() {
    if (this.eventSource) {
      this.removeAllSubscriptionListeners();
      for (let e2 in this.subscriptions)
        for (let t2 of this.subscriptions[e2])
          this.eventSource.addEventListener(e2, t2);
    }
  }
  removeAllSubscriptionListeners() {
    if (this.eventSource)
      for (let e2 in this.subscriptions)
        for (let t2 of this.subscriptions[e2])
          this.eventSource.removeEventListener(e2, t2);
  }
  async connect() {
    if (!(this.reconnectAttempts > 0))
      return new Promise((e2, t2) => {
        this.pendingConnects.push({ resolve: e2, reject: t2 }), this.pendingConnects.length > 1 || this.initConnect();
      });
  }
  initConnect() {
    this.disconnect(true), clearTimeout(this.connectTimeoutId), this.connectTimeoutId = setTimeout(() => {
      this.connectErrorHandler(new Error("EventSource connect took too long."));
    }, this.maxConnectTimeout), this.eventSource = new EventSource(this.client.buildUrl("/api/realtime")), this.eventSource.onerror = (e2) => {
      this.connectErrorHandler(new Error("Failed to establish realtime connection."));
    }, this.eventSource.addEventListener("PB_CONNECT", (e2) => {
      const t2 = e2;
      this.clientId = t2 == null ? void 0 : t2.lastEventId, this.submitSubscriptions().then(async () => {
        let e3 = 3;
        for (; this.hasUnsentSubscriptions() && e3 > 0; )
          e3--, await this.submitSubscriptions();
      }).then(() => {
        for (let e3 of this.pendingConnects)
          e3.resolve();
        this.pendingConnects = [], this.reconnectAttempts = 0, clearTimeout(this.reconnectTimeoutId), clearTimeout(this.connectTimeoutId);
        const t3 = this.getSubscriptionsByTopic("PB_CONNECT");
        for (let s2 in t3)
          for (let i2 of t3[s2])
            i2(e2);
      }).catch((e3) => {
        this.clientId = "", this.connectErrorHandler(e3);
      });
    });
  }
  hasUnsentSubscriptions() {
    const e2 = this.getNonEmptySubscriptionKeys();
    if (e2.length != this.lastSentSubscriptions.length)
      return true;
    for (const t2 of e2)
      if (!this.lastSentSubscriptions.includes(t2))
        return true;
    return false;
  }
  connectErrorHandler(e2) {
    if (clearTimeout(this.connectTimeoutId), clearTimeout(this.reconnectTimeoutId), !this.clientId && !this.reconnectAttempts || this.reconnectAttempts > this.maxReconnectAttempts) {
      for (let t3 of this.pendingConnects)
        t3.reject(new ClientResponseError(e2));
      return this.pendingConnects = [], void this.disconnect();
    }
    this.disconnect(true);
    const t2 = this.predefinedReconnectIntervals[this.reconnectAttempts] || this.predefinedReconnectIntervals[this.predefinedReconnectIntervals.length - 1];
    this.reconnectAttempts++, this.reconnectTimeoutId = setTimeout(() => {
      this.initConnect();
    }, t2);
  }
  disconnect(e2 = false) {
    var _a2;
    if (clearTimeout(this.connectTimeoutId), clearTimeout(this.reconnectTimeoutId), this.removeAllSubscriptionListeners(), this.client.cancelRequest(this.getSubscriptionsCancelKey()), (_a2 = this.eventSource) == null ? void 0 : _a2.close(), this.eventSource = null, this.clientId = "", !e2) {
      this.reconnectAttempts = 0;
      for (let e3 of this.pendingConnects)
        e3.resolve();
      this.pendingConnects = [];
    }
  }
};
var RecordService = class extends CrudService {
  constructor(e2, t2) {
    super(e2), this.collectionIdOrName = t2;
  }
  get baseCrudPath() {
    return this.baseCollectionPath + "/records";
  }
  get baseCollectionPath() {
    return "/api/collections/" + encodeURIComponent(this.collectionIdOrName);
  }
  async subscribe(e2, t2, s2) {
    if (!e2)
      throw new Error("Missing topic.");
    if (!t2)
      throw new Error("Missing subscription callback.");
    return this.client.realtime.subscribe(this.collectionIdOrName + "/" + e2, t2, s2);
  }
  async unsubscribe(e2) {
    return e2 ? this.client.realtime.unsubscribe(this.collectionIdOrName + "/" + e2) : this.client.realtime.unsubscribeByPrefix(this.collectionIdOrName);
  }
  async getFullList(e2, t2) {
    if ("number" == typeof e2)
      return super.getFullList(e2, t2);
    const s2 = Object.assign({}, e2, t2);
    return super.getFullList(s2);
  }
  async getList(e2 = 1, t2 = 30, s2) {
    return super.getList(e2, t2, s2);
  }
  async getFirstListItem(e2, t2) {
    return super.getFirstListItem(e2, t2);
  }
  async getOne(e2, t2) {
    return super.getOne(e2, t2);
  }
  async create(e2, t2) {
    return super.create(e2, t2);
  }
  async update(e2, t2, s2) {
    return super.update(e2, t2, s2).then((e3) => {
      var _a2, _b2, _c;
      return ((_a2 = this.client.authStore.model) == null ? void 0 : _a2.id) !== (e3 == null ? void 0 : e3.id) || ((_b2 = this.client.authStore.model) == null ? void 0 : _b2.collectionId) !== this.collectionIdOrName && ((_c = this.client.authStore.model) == null ? void 0 : _c.collectionName) !== this.collectionIdOrName || this.client.authStore.save(this.client.authStore.token, e3), e3;
    });
  }
  async delete(e2, t2) {
    return super.delete(e2, t2).then((t3) => {
      var _a2, _b2, _c;
      return !t3 || ((_a2 = this.client.authStore.model) == null ? void 0 : _a2.id) !== e2 || ((_b2 = this.client.authStore.model) == null ? void 0 : _b2.collectionId) !== this.collectionIdOrName && ((_c = this.client.authStore.model) == null ? void 0 : _c.collectionName) !== this.collectionIdOrName || this.client.authStore.clear(), t3;
    });
  }
  authResponse(e2) {
    const t2 = this.decode((e2 == null ? void 0 : e2.record) || {});
    return this.client.authStore.save(e2 == null ? void 0 : e2.token, t2), Object.assign({}, e2, { token: (e2 == null ? void 0 : e2.token) || "", record: t2 });
  }
  async listAuthMethods(e2) {
    return e2 = Object.assign({ method: "GET" }, e2), this.client.send(this.baseCollectionPath + "/auth-methods", e2).then((e3) => Object.assign({}, e3, { usernamePassword: !!(e3 == null ? void 0 : e3.usernamePassword), emailPassword: !!(e3 == null ? void 0 : e3.emailPassword), authProviders: Array.isArray(e3 == null ? void 0 : e3.authProviders) ? e3 == null ? void 0 : e3.authProviders : [] }));
  }
  async authWithPassword(e2, t2, s2, i2) {
    let n = { method: "POST", body: { identity: e2, password: t2 } };
    return n = normalizeLegacyOptionsArgs("This form of authWithPassword(usernameOrEmail, pass, body?, query?) is deprecated. Consider replacing it with authWithPassword(usernameOrEmail, pass, options?).", n, s2, i2), this.client.send(this.baseCollectionPath + "/auth-with-password", n).then((e3) => this.authResponse(e3));
  }
  async authWithOAuth2Code(e2, t2, s2, i2, n, r, o) {
    let a = { method: "POST", body: { provider: e2, code: t2, codeVerifier: s2, redirectUrl: i2, createData: n } };
    return a = normalizeLegacyOptionsArgs("This form of authWithOAuth2Code(provider, code, codeVerifier, redirectUrl, createData?, body?, query?) is deprecated. Consider replacing it with authWithOAuth2Code(provider, code, codeVerifier, redirectUrl, createData?, options?).", a, r, o), this.client.send(this.baseCollectionPath + "/auth-with-oauth2", a).then((e3) => this.authResponse(e3));
  }
  async authWithOAuth2(...e2) {
    if (e2.length > 1 || "string" == typeof (e2 == null ? void 0 : e2[0]))
      return console.warn("PocketBase: This form of authWithOAuth2() is deprecated and may get removed in the future. Please replace with authWithOAuth2Code() OR use the authWithOAuth2() realtime form as shown in https://pocketbase.io/docs/authentication/#oauth2-integration."), this.authWithOAuth2Code((e2 == null ? void 0 : e2[0]) || "", (e2 == null ? void 0 : e2[1]) || "", (e2 == null ? void 0 : e2[2]) || "", (e2 == null ? void 0 : e2[3]) || "", (e2 == null ? void 0 : e2[4]) || {}, (e2 == null ? void 0 : e2[5]) || {}, (e2 == null ? void 0 : e2[6]) || {});
    const t2 = (e2 == null ? void 0 : e2[0]) || {}, s2 = (await this.listAuthMethods()).authProviders.find((e3) => e3.name === t2.provider);
    if (!s2)
      throw new ClientResponseError(new Error(`Missing or invalid provider "${t2.provider}".`));
    const i2 = this.client.buildUrl("/api/oauth2-redirect"), n = new RealtimeService(this.client);
    let r = null;
    function cleanup() {
      r == null ? void 0 : r.close(), n.unsubscribe();
    }
    return t2.urlCallback || (r = openBrowserPopup(void 0)), new Promise(async (e3, o) => {
      var _a2;
      try {
        await n.subscribe("@oauth2", async (r2) => {
          const a2 = n.clientId;
          try {
            if (!r2.state || a2 !== r2.state)
              throw new Error("State parameters don't match.");
            const n2 = Object.assign({}, t2);
            delete n2.provider, delete n2.scopes, delete n2.createData, delete n2.urlCallback;
            const o2 = await this.authWithOAuth2Code(s2.name, r2.code, s2.codeVerifier, i2, t2.createData, n2);
            e3(o2);
          } catch (e4) {
            o(new ClientResponseError(e4));
          }
          cleanup();
        });
        const a = { state: n.clientId };
        ((_a2 = t2.scopes) == null ? void 0 : _a2.length) && (a.scope = t2.scopes.join(" "));
        const c = this._replaceQueryParams(s2.authUrl + i2, a);
        let l = t2.urlCallback || function(e4) {
          r ? r.location.href = e4 : r = openBrowserPopup(e4);
        };
        await l(c);
      } catch (e4) {
        cleanup(), o(new ClientResponseError(e4));
      }
    });
  }
  async authRefresh(e2, t2) {
    let s2 = { method: "POST" };
    return s2 = normalizeLegacyOptionsArgs("This form of authRefresh(body?, query?) is deprecated. Consider replacing it with authRefresh(options?).", s2, e2, t2), this.client.send(this.baseCollectionPath + "/auth-refresh", s2).then((e3) => this.authResponse(e3));
  }
  async requestPasswordReset(e2, t2, s2) {
    let i2 = { method: "POST", body: { email: e2 } };
    return i2 = normalizeLegacyOptionsArgs("This form of requestPasswordReset(email, body?, query?) is deprecated. Consider replacing it with requestPasswordReset(email, options?).", i2, t2, s2), this.client.send(this.baseCollectionPath + "/request-password-reset", i2).then(() => true);
  }
  async confirmPasswordReset(e2, t2, s2, i2, n) {
    let r = { method: "POST", body: { token: e2, password: t2, passwordConfirm: s2 } };
    return r = normalizeLegacyOptionsArgs("This form of confirmPasswordReset(token, password, passwordConfirm, body?, query?) is deprecated. Consider replacing it with confirmPasswordReset(token, password, passwordConfirm, options?).", r, i2, n), this.client.send(this.baseCollectionPath + "/confirm-password-reset", r).then(() => true);
  }
  async requestVerification(e2, t2, s2) {
    let i2 = { method: "POST", body: { email: e2 } };
    return i2 = normalizeLegacyOptionsArgs("This form of requestVerification(email, body?, query?) is deprecated. Consider replacing it with requestVerification(email, options?).", i2, t2, s2), this.client.send(this.baseCollectionPath + "/request-verification", i2).then(() => true);
  }
  async confirmVerification(e2, t2, s2) {
    let i2 = { method: "POST", body: { token: e2 } };
    return i2 = normalizeLegacyOptionsArgs("This form of confirmVerification(token, body?, query?) is deprecated. Consider replacing it with confirmVerification(token, options?).", i2, t2, s2), this.client.send(this.baseCollectionPath + "/confirm-verification", i2).then(() => true);
  }
  async requestEmailChange(e2, t2, s2) {
    let i2 = { method: "POST", body: { newEmail: e2 } };
    return i2 = normalizeLegacyOptionsArgs("This form of requestEmailChange(newEmail, body?, query?) is deprecated. Consider replacing it with requestEmailChange(newEmail, options?).", i2, t2, s2), this.client.send(this.baseCollectionPath + "/request-email-change", i2).then(() => true);
  }
  async confirmEmailChange(e2, t2, s2, i2) {
    let n = { method: "POST", body: { token: e2, password: t2 } };
    return n = normalizeLegacyOptionsArgs("This form of confirmEmailChange(token, password, body?, query?) is deprecated. Consider replacing it with confirmEmailChange(token, password, options?).", n, s2, i2), this.client.send(this.baseCollectionPath + "/confirm-email-change", n).then(() => true);
  }
  async listExternalAuths(e2, t2) {
    return t2 = Object.assign({ method: "GET" }, t2), this.client.send(this.baseCrudPath + "/" + encodeURIComponent(e2) + "/external-auths", t2);
  }
  async unlinkExternalAuth(e2, t2, s2) {
    return s2 = Object.assign({ method: "DELETE" }, s2), this.client.send(this.baseCrudPath + "/" + encodeURIComponent(e2) + "/external-auths/" + encodeURIComponent(t2), s2).then(() => true);
  }
  _replaceQueryParams(e2, t2 = {}) {
    let s2 = e2, i2 = "";
    e2.indexOf("?") >= 0 && (s2 = e2.substring(0, e2.indexOf("?")), i2 = e2.substring(e2.indexOf("?") + 1));
    const n = {}, r = i2.split("&");
    for (const e3 of r) {
      if ("" == e3)
        continue;
      const t3 = e3.split("=");
      n[decodeURIComponent(t3[0].replace(/\+/g, " "))] = decodeURIComponent((t3[1] || "").replace(/\+/g, " "));
    }
    for (let e3 in t2)
      t2.hasOwnProperty(e3) && (null == t2[e3] ? delete n[e3] : n[e3] = t2[e3]);
    i2 = "";
    for (let e3 in n)
      n.hasOwnProperty(e3) && ("" != i2 && (i2 += "&"), i2 += encodeURIComponent(e3.replace(/%20/g, "+")) + "=" + encodeURIComponent(n[e3].replace(/%20/g, "+")));
    return "" != i2 ? s2 + "?" + i2 : s2;
  }
};
function openBrowserPopup(e2) {
  if ("undefined" == typeof window || !(window == null ? void 0 : window.open))
    throw new ClientResponseError(new Error("Not in a browser context - please pass a custom urlCallback function."));
  let t2 = 1024, s2 = 768, i2 = window.innerWidth, n = window.innerHeight;
  t2 = t2 > i2 ? i2 : t2, s2 = s2 > n ? n : s2;
  let r = i2 / 2 - t2 / 2, o = n / 2 - s2 / 2;
  return window.open(e2, "popup_window", "width=" + t2 + ",height=" + s2 + ",top=" + o + ",left=" + r + ",resizable,menubar=no");
}
var CollectionService = class extends CrudService {
  get baseCrudPath() {
    return "/api/collections";
  }
  async import(e2, t2 = false, s2) {
    return s2 = Object.assign({ method: "PUT", body: { collections: e2, deleteMissing: t2 } }, s2), this.client.send(this.baseCrudPath + "/import", s2).then(() => true);
  }
};
var LogService = class extends BaseService {
  async getList(e2 = 1, t2 = 30, s2) {
    return (s2 = Object.assign({ method: "GET" }, s2)).query = Object.assign({ page: e2, perPage: t2 }, s2.query), this.client.send("/api/logs", s2);
  }
  async getOne(e2, t2) {
    if (!e2)
      throw new ClientResponseError({ url: this.client.buildUrl("/api/logs/"), status: 404, response: { code: 404, message: "Missing required log id.", data: {} } });
    return t2 = Object.assign({ method: "GET" }, t2), this.client.send("/api/logs/" + encodeURIComponent(e2), t2);
  }
  async getStats(e2) {
    return e2 = Object.assign({ method: "GET" }, e2), this.client.send("/api/logs/stats", e2);
  }
};
var HealthService = class extends BaseService {
  async check(e2) {
    return e2 = Object.assign({ method: "GET" }, e2), this.client.send("/api/health", e2);
  }
};
var FileService = class extends BaseService {
  getUrl(e2, t2, s2 = {}) {
    if (!t2 || !(e2 == null ? void 0 : e2.id) || !(e2 == null ? void 0 : e2.collectionId) && !(e2 == null ? void 0 : e2.collectionName))
      return "";
    const i2 = [];
    i2.push("api"), i2.push("files"), i2.push(encodeURIComponent(e2.collectionId || e2.collectionName)), i2.push(encodeURIComponent(e2.id)), i2.push(encodeURIComponent(t2));
    let n = this.client.buildUrl(i2.join("/"));
    if (Object.keys(s2).length) {
      false === s2.download && delete s2.download;
      const e3 = new URLSearchParams(s2);
      n += (n.includes("?") ? "&" : "?") + e3;
    }
    return n;
  }
  async getToken(e2) {
    return e2 = Object.assign({ method: "POST" }, e2), this.client.send("/api/files/token", e2).then((e3) => (e3 == null ? void 0 : e3.token) || "");
  }
};
var BackupService = class extends BaseService {
  async getFullList(e2) {
    return e2 = Object.assign({ method: "GET" }, e2), this.client.send("/api/backups", e2);
  }
  async create(e2, t2) {
    return t2 = Object.assign({ method: "POST", body: { name: e2 } }, t2), this.client.send("/api/backups", t2).then(() => true);
  }
  async upload(e2, t2) {
    return t2 = Object.assign({ method: "POST", body: e2 }, t2), this.client.send("/api/backups/upload", t2).then(() => true);
  }
  async delete(e2, t2) {
    return t2 = Object.assign({ method: "DELETE" }, t2), this.client.send(`/api/backups/${encodeURIComponent(e2)}`, t2).then(() => true);
  }
  async restore(e2, t2) {
    return t2 = Object.assign({ method: "POST" }, t2), this.client.send(`/api/backups/${encodeURIComponent(e2)}/restore`, t2).then(() => true);
  }
  getDownloadUrl(e2, t2) {
    return this.client.buildUrl(`/api/backups/${encodeURIComponent(t2)}?token=${encodeURIComponent(e2)}`);
  }
};
var Client = class {
  constructor(e2 = "/", t2, s2 = "en-US") {
    this.cancelControllers = {}, this.recordServices = {}, this.enableAutoCancellation = true, this.baseUrl = e2, this.lang = s2, this.authStore = t2 || new LocalAuthStore(), this.admins = new AdminService(this), this.collections = new CollectionService(this), this.files = new FileService(this), this.logs = new LogService(this), this.settings = new SettingsService(this), this.realtime = new RealtimeService(this), this.health = new HealthService(this), this.backups = new BackupService(this);
  }
  collection(e2) {
    return this.recordServices[e2] || (this.recordServices[e2] = new RecordService(this, e2)), this.recordServices[e2];
  }
  autoCancellation(e2) {
    return this.enableAutoCancellation = !!e2, this;
  }
  cancelRequest(e2) {
    return this.cancelControllers[e2] && (this.cancelControllers[e2].abort(), delete this.cancelControllers[e2]), this;
  }
  cancelAllRequests() {
    for (let e2 in this.cancelControllers)
      this.cancelControllers[e2].abort();
    return this.cancelControllers = {}, this;
  }
  filter(e2, t2) {
    if (!t2)
      return e2;
    for (let s2 in t2) {
      let i2 = t2[s2];
      switch (typeof i2) {
        case "boolean":
        case "number":
          i2 = "" + i2;
          break;
        case "string":
          i2 = "'" + i2.replace(/'/g, "\\'") + "'";
          break;
        default:
          i2 = null === i2 ? "null" : i2 instanceof Date ? "'" + i2.toISOString().replace("T", " ") + "'" : "'" + JSON.stringify(i2).replace(/'/g, "\\'") + "'";
      }
      e2 = e2.replaceAll("{:" + s2 + "}", i2);
    }
    return e2;
  }
  getFileUrl(e2, t2, s2 = {}) {
    return this.files.getUrl(e2, t2, s2);
  }
  buildUrl(e2) {
    var _a2;
    let t2 = this.baseUrl;
    return "undefined" == typeof window || !window.location || t2.startsWith("https://") || t2.startsWith("http://") || (t2 = ((_a2 = window.location.origin) == null ? void 0 : _a2.endsWith("/")) ? window.location.origin.substring(0, window.location.origin.length - 1) : window.location.origin || "", this.baseUrl.startsWith("/") || (t2 += window.location.pathname || "/", t2 += t2.endsWith("/") ? "" : "/"), t2 += this.baseUrl), e2 && (t2 += t2.endsWith("/") ? "" : "/", t2 += e2.startsWith("/") ? e2.substring(1) : e2), t2;
  }
  async send(e2, t2) {
    t2 = this.initSendOptions(e2, t2);
    let s2 = this.buildUrl(e2);
    if (this.beforeSend) {
      const e3 = Object.assign({}, await this.beforeSend(s2, t2));
      void 0 !== e3.url || void 0 !== e3.options ? (s2 = e3.url || s2, t2 = e3.options || t2) : Object.keys(e3).length && (t2 = e3, (console == null ? void 0 : console.warn) && console.warn("Deprecated format of beforeSend return: please use `return { url, options }`, instead of `return options`."));
    }
    if (void 0 !== t2.query) {
      const e3 = this.serializeQueryParams(t2.query);
      e3 && (s2 += (s2.includes("?") ? "&" : "?") + e3), delete t2.query;
    }
    "application/json" == this.getHeader(t2.headers, "Content-Type") && t2.body && "string" != typeof t2.body && (t2.body = JSON.stringify(t2.body));
    return (t2.fetch || fetch)(s2, t2).then(async (e3) => {
      let t3 = {};
      try {
        t3 = await e3.json();
      } catch (e4) {
      }
      if (this.afterSend && (t3 = await this.afterSend(e3, t3)), e3.status >= 400)
        throw new ClientResponseError({ url: e3.url, status: e3.status, data: t3 });
      return t3;
    }).catch((e3) => {
      throw new ClientResponseError(e3);
    });
  }
  initSendOptions(e2, t2) {
    if ((t2 = Object.assign({ method: "GET" }, t2)).body = this.convertToFormDataIfNeeded(t2.body), normalizeUnknownQueryParams(t2), t2.query = Object.assign({}, t2.params, t2.query), void 0 === t2.requestKey && (false === t2.$autoCancel || false === t2.query.$autoCancel ? t2.requestKey = null : (t2.$cancelKey || t2.query.$cancelKey) && (t2.requestKey = t2.$cancelKey || t2.query.$cancelKey)), delete t2.$autoCancel, delete t2.query.$autoCancel, delete t2.$cancelKey, delete t2.query.$cancelKey, null !== this.getHeader(t2.headers, "Content-Type") || this.isFormData(t2.body) || (t2.headers = Object.assign({}, t2.headers, { "Content-Type": "application/json" })), null === this.getHeader(t2.headers, "Accept-Language") && (t2.headers = Object.assign({}, t2.headers, { "Accept-Language": this.lang })), this.authStore.token && null === this.getHeader(t2.headers, "Authorization") && (t2.headers = Object.assign({}, t2.headers, { Authorization: this.authStore.token })), this.enableAutoCancellation && null !== t2.requestKey) {
      const s2 = t2.requestKey || (t2.method || "GET") + e2;
      delete t2.requestKey, this.cancelRequest(s2);
      const i2 = new AbortController();
      this.cancelControllers[s2] = i2, t2.signal = i2.signal;
    }
    return t2;
  }
  convertToFormDataIfNeeded(e2) {
    if ("undefined" == typeof FormData || void 0 === e2 || "object" != typeof e2 || null === e2 || this.isFormData(e2) || !this.hasBlobField(e2))
      return e2;
    const t2 = new FormData();
    for (let s2 in e2) {
      const i2 = this.normalizeFormDataValue(e2[s2]), n = Array.isArray(i2) ? i2 : [i2];
      if (n.length)
        for (const e3 of n)
          t2.append(s2, e3);
      else
        t2.append(s2, "");
    }
    return t2;
  }
  normalizeFormDataValue(e2) {
    return null === e2 || "object" != typeof e2 || e2 instanceof Date || this.hasBlobField({ data: e2 }) || Array.isArray(e2) && !e2.filter((e3) => "string" != typeof e3).length ? e2 : JSON.stringify(e2);
  }
  hasBlobField(e2) {
    for (let t2 in e2) {
      const s2 = Array.isArray(e2[t2]) ? e2[t2] : [e2[t2]];
      for (let e3 of s2)
        if ("undefined" != typeof Blob && e3 instanceof Blob || "undefined" != typeof File && e3 instanceof File)
          return true;
    }
    return false;
  }
  getHeader(e2, t2) {
    e2 = e2 || {}, t2 = t2.toLowerCase();
    for (let s2 in e2)
      if (s2.toLowerCase() == t2)
        return e2[s2];
    return null;
  }
  isFormData(e2) {
    return e2 && ("FormData" === e2.constructor.name || "undefined" != typeof FormData && e2 instanceof FormData);
  }
  serializeQueryParams(e2) {
    const t2 = [];
    for (const s2 in e2) {
      if (null === e2[s2])
        continue;
      const i2 = e2[s2], n = encodeURIComponent(s2);
      if (Array.isArray(i2))
        for (const e3 of i2)
          t2.push(n + "=" + encodeURIComponent(e3));
      else
        i2 instanceof Date ? t2.push(n + "=" + encodeURIComponent(i2.toISOString())) : null !== typeof i2 && "object" == typeof i2 ? t2.push(n + "=" + encodeURIComponent(JSON.stringify(i2))) : t2.push(n + "=" + encodeURIComponent(i2));
    }
    return t2.join("&");
  }
};

// src/pocketbase/LocalAuthStore.ts
var LocalAuthStore2 = class extends BaseAuthStore {
  constructor(storageKey = "pocketbase_auth") {
    super();
    this.storageFallback = {};
    this._storageChangeHandler = (e2) => {
      if (e2.key != this.storageKey) {
        return;
      }
      const data = this._storageGet(this.storageKey) || {};
      super.save(data.token || "", data.model || null);
    };
    this.storageKey = storageKey;
    this._bindStorageEvent();
  }
  /**
   * @inheritdoc
   */
  get token() {
    const data = this._storageGet(this.storageKey) || {};
    return data.token || "";
  }
  /**
   * @inheritdoc
   */
  get model() {
    const data = this._storageGet(this.storageKey) || {};
    return data.model || null;
  }
  /**
   * @inheritdoc
   */
  save(token, model) {
    this._storageSet(this.storageKey, {
      token,
      model
    });
    super.save(token, model);
  }
  /**
   * @inheritdoc
   */
  clear() {
    this._storageRemove(this.storageKey);
    super.clear();
  }
  destroy() {
    this._unbindStorageEvent();
  }
  // ---------------------------------------------------------------
  // Internal helpers:
  // ---------------------------------------------------------------
  /**
   * Retrieves `key` from the browser's local storage
   * (or runtime/memory if local storage is undefined).
   */
  _storageGet(key) {
    if (typeof window !== "undefined" && (window == null ? void 0 : window.localStorage)) {
      const rawValue = window.localStorage.getItem(key) || "";
      try {
        return JSON.parse(rawValue);
      } catch (e2) {
        return rawValue;
      }
    }
    return this.storageFallback[key];
  }
  /**
   * Stores a new data in the browser's local storage
   * (or runtime/memory if local storage is undefined).
   */
  _storageSet(key, value) {
    if (typeof window !== "undefined" && (window == null ? void 0 : window.localStorage)) {
      let normalizedVal = value;
      if (typeof value !== "string") {
        normalizedVal = JSON.stringify(value);
      }
      window.localStorage.setItem(key, normalizedVal);
    } else {
      this.storageFallback[key] = value;
    }
  }
  /**
   * Removes `key` from the browser's local storage and the runtime/memory.
   */
  _storageRemove(key) {
    var _a2;
    if (typeof window !== "undefined" && (window == null ? void 0 : window.localStorage)) {
      (_a2 = window.localStorage) == null ? void 0 : _a2.removeItem(key);
    }
    delete this.storageFallback[key];
  }
  /**
   * Updates the current store state on localStorage change.
   */
  _bindStorageEvent() {
    if (typeof window === "undefined" || !(window == null ? void 0 : window.localStorage) || !window.addEventListener) {
      return () => {
      };
    }
    window.addEventListener("storage", this._storageChangeHandler);
  }
  _unbindStorageEvent() {
    if (typeof window === "undefined" || !(window == null ? void 0 : window.localStorage) || !window.addEventListener) {
      return () => {
      };
    }
    window.removeEventListener("storage", this._storageChangeHandler);
  }
};

// src/LoginManager.ts
var LoginManager = class extends Observable3 {
  constructor(vaultName, openSettings, timeProvider, beforeLogin) {
    super();
    this.beforeLogin = beforeLogin;
    const pbLog = curryLog("[Pocketbase]", "debug");
    this.authStore = new LocalAuthStore2(`pocketbase_auth_${vaultName}`);
    this.pb = new Client("https://auth.system3.md", this.authStore);
    this.pb.beforeSend = (url, options) => {
      pbLog(url, options);
      options.fetch = customFetch;
      options.headers = Object.assign({}, options.headers, {
        "Relay-Version": "0.4.5"
      });
      return { url, options };
    };
    this.refreshToken();
    timeProvider.setInterval(() => this.refreshToken(), 864e5);
    this.openSettings = openSettings;
    RelayInstances.set(this, "loginManager");
  }
  refreshToken() {
    if (this.pb.authStore.isValid) {
      this.user = this.makeUser(this.pb.authStore);
      this.pb.collection("users").authRefresh().then((authData) => {
        const token = authData.token;
        const [, payload] = token.split(".");
        const decodedPayload = JSON.parse(atob(payload));
        const expiryDate = new Date(decodedPayload.exp * 1e3);
        const now2 = new Date();
        const daysUntilExpiry = Math.ceil(
          (expiryDate.getTime() - now2.getTime()) / (1e3 * 60 * 60 * 24)
        );
        this.log("Token Refreshed");
        this.log("JWT Info:", {
          expiresAt: expiryDate.toLocaleString(),
          expiresIn: `${daysUntilExpiry} days`,
          userId: decodedPayload.id,
          email: decodedPayload.email
        });
      });
    }
  }
  setup(authData) {
    var _a2, _b2;
    if (!this.pb.authStore.isValid) {
      this.notifyListeners();
      return false;
    }
    this.user = this.makeUser(this.pb.authStore, (_a2 = authData == null ? void 0 : authData.meta) == null ? void 0 : _a2.rawUser);
    this.notifyListeners();
    if (authData) {
      this.pb.collection("oauth2_response").create({
        user: authData.record.id,
        oauth_response: (_b2 = authData.meta) == null ? void 0 : _b2.rawUser
      }).then(() => {
        this.notifyListeners();
      }).catch((reason) => {
        this.log(reason);
      });
    }
    return true;
  }
  whoami() {
    const headers = {
      Authorization: `Bearer ${this.pb.authStore.token}`
    };
    (0, import_obsidian20.requestUrl)({
      url: `${"https://api.system3.md"}/whoami`,
      method: "GET",
      headers
    }).then((response) => {
      this.log(response.json);
    }).catch((reason) => {
      this.log(reason);
    });
  }
  get loggedIn() {
    return this.user !== void 0;
  }
  get hasUser() {
    return this.user !== void 0;
  }
  makeUser(authStore, rawUser) {
    var _a2, _b2, _c, _d;
    return new User(
      (_a2 = authStore.model) == null ? void 0 : _a2.id,
      ((_b2 = authStore.model) == null ? void 0 : _b2.name) || (rawUser == null ? void 0 : rawUser.name),
      (_c = authStore.model) == null ? void 0 : _c.email,
      ((_d = authStore.model) == null ? void 0 : _d.picture) || (rawUser == null ? void 0 : rawUser.picture),
      authStore.token
    );
  }
  logout() {
    this.pb.cancelAllRequests();
    this.pb.authStore.clear();
    this.user = void 0;
    this.notifyListeners();
  }
  webviewIntercept() {
    const redirectUrl = this.pb.buildUrl("/api/oauth2-redirect");
    const authProvider = "https:\\/\\/accounts\\.google\\.com\\/o\\/oauth2\\/auth";
    return new RegExp(
      `^${authProvider}.*?[?&]redirect_uri=${encodeURIComponent(redirectUrl)}`,
      "i"
    );
  }
  async initiateManualOAuth2CodeFlow(whichFetch) {
    this.beforeLogin();
    const authMethods = await this.pb.collection("users").listAuthMethods({ fetch: whichFetch }).catch((e2) => {
      throw e2.originalError;
    });
    const provider = authMethods.authProviders[0];
    const redirectUrl = this.pb.buildUrl("/api/oauth2-redirect");
    return [
      provider.authUrl + redirectUrl,
      provider,
      async (code) => {
        return this.pb.collection("users").authWithOAuth2Code(
          provider.name,
          code,
          provider.codeVerifier,
          redirectUrl,
          {
            fetch: whichFetch
          }
        ).then((authData) => {
          this.setup(authData);
          return authData;
        });
      }
    ];
  }
  async poll(provider, authWithCode) {
    let counter = 0;
    const interval = 1e3;
    return new Promise((resolve, reject) => {
      const timer = setInterval(() => {
        counter += 1;
        if (counter >= 30) {
          clearInterval(timer);
          return reject(
            new Error(
              `Auth timeout: Timed out after ${counter * interval / 1e3} seconds`
            )
          );
        }
        this.pb.collection("code_exchange").getOne(provider.state.slice(0, 15)).then((response) => {
          if (response) {
            clearInterval(timer);
            return resolve(authWithCode(response.code));
          }
        }).catch((e2) => {
        });
      }, interval);
    });
  }
  async login() {
    this.beforeLogin();
    const authData = await this.pb.collection("users").authWithOAuth2({
      provider: "google"
    });
    return this.setup(authData);
  }
  async openLoginPage() {
    await this.openSettings();
    const promise = new Promise((resolve, reject) => {
      const isLoggedIn = () => {
        if (this.loggedIn) {
          this.off(isLoggedIn);
          resolve(true);
        }
        resolve(false);
      };
      this.on(isLoggedIn);
    });
    return await promise;
  }
  destroy() {
    this.pb.cancelAllRequests();
    this.pb.realtime.unsubscribe();
    this.pb = null;
    this.authStore.destroy();
    this.authStore = null;
    this.user = void 0;
    this.openSettings = null;
    super.destroy();
  }
};

// node_modules/jose/dist/browser/runtime/webcrypto.js
var webcrypto_default = crypto;

// node_modules/jose/dist/browser/lib/buffer_utils.js
var encoder = new TextEncoder();
var decoder = new TextDecoder();
var MAX_INT32 = 2 ** 32;

// node_modules/jose/dist/browser/runtime/base64url.js
var encodeBase64 = (input) => {
  let unencoded = input;
  if (typeof unencoded === "string") {
    unencoded = encoder.encode(unencoded);
  }
  const CHUNK_SIZE = 32768;
  const arr = [];
  for (let i2 = 0; i2 < unencoded.length; i2 += CHUNK_SIZE) {
    arr.push(String.fromCharCode.apply(null, unencoded.subarray(i2, i2 + CHUNK_SIZE)));
  }
  return btoa(arr.join(""));
};
var encode = (input) => {
  return encodeBase64(input).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
};
var decodeBase64 = (encoded) => {
  const binary = atob(encoded);
  const bytes = new Uint8Array(binary.length);
  for (let i2 = 0; i2 < binary.length; i2++) {
    bytes[i2] = binary.charCodeAt(i2);
  }
  return bytes;
};
var decode = (input) => {
  let encoded = input;
  if (encoded instanceof Uint8Array) {
    encoded = decoder.decode(encoded);
  }
  encoded = encoded.replace(/-/g, "+").replace(/_/g, "/").replace(/\s/g, "");
  try {
    return decodeBase64(encoded);
  } catch (e2) {
    throw new TypeError("The input to be decoded is not correctly encoded.");
  }
};

// node_modules/jose/dist/browser/util/errors.js
var errors_exports = {};
__export(errors_exports, {
  JOSEAlgNotAllowed: () => JOSEAlgNotAllowed,
  JOSEError: () => JOSEError,
  JOSENotSupported: () => JOSENotSupported,
  JWEDecryptionFailed: () => JWEDecryptionFailed,
  JWEInvalid: () => JWEInvalid,
  JWKInvalid: () => JWKInvalid,
  JWKSInvalid: () => JWKSInvalid,
  JWKSMultipleMatchingKeys: () => JWKSMultipleMatchingKeys,
  JWKSNoMatchingKey: () => JWKSNoMatchingKey,
  JWKSTimeout: () => JWKSTimeout,
  JWSInvalid: () => JWSInvalid,
  JWSSignatureVerificationFailed: () => JWSSignatureVerificationFailed,
  JWTClaimValidationFailed: () => JWTClaimValidationFailed,
  JWTExpired: () => JWTExpired,
  JWTInvalid: () => JWTInvalid
});
var JOSEError = class extends Error {
  static get code() {
    return "ERR_JOSE_GENERIC";
  }
  constructor(message) {
    var _a2;
    super(message);
    this.code = "ERR_JOSE_GENERIC";
    this.name = this.constructor.name;
    (_a2 = Error.captureStackTrace) == null ? void 0 : _a2.call(Error, this, this.constructor);
  }
};
var JWTClaimValidationFailed = class extends JOSEError {
  static get code() {
    return "ERR_JWT_CLAIM_VALIDATION_FAILED";
  }
  constructor(message, claim = "unspecified", reason = "unspecified") {
    super(message);
    this.code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
    this.claim = claim;
    this.reason = reason;
  }
};
var JWTExpired = class extends JOSEError {
  static get code() {
    return "ERR_JWT_EXPIRED";
  }
  constructor(message, claim = "unspecified", reason = "unspecified") {
    super(message);
    this.code = "ERR_JWT_EXPIRED";
    this.claim = claim;
    this.reason = reason;
  }
};
var JOSEAlgNotAllowed = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JOSE_ALG_NOT_ALLOWED";
  }
  static get code() {
    return "ERR_JOSE_ALG_NOT_ALLOWED";
  }
};
var JOSENotSupported = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JOSE_NOT_SUPPORTED";
  }
  static get code() {
    return "ERR_JOSE_NOT_SUPPORTED";
  }
};
var JWEDecryptionFailed = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWE_DECRYPTION_FAILED";
    this.message = "decryption operation failed";
  }
  static get code() {
    return "ERR_JWE_DECRYPTION_FAILED";
  }
};
var JWEInvalid = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWE_INVALID";
  }
  static get code() {
    return "ERR_JWE_INVALID";
  }
};
var JWSInvalid = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWS_INVALID";
  }
  static get code() {
    return "ERR_JWS_INVALID";
  }
};
var JWTInvalid = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWT_INVALID";
  }
  static get code() {
    return "ERR_JWT_INVALID";
  }
};
var JWKInvalid = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWK_INVALID";
  }
  static get code() {
    return "ERR_JWK_INVALID";
  }
};
var JWKSInvalid = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWKS_INVALID";
  }
  static get code() {
    return "ERR_JWKS_INVALID";
  }
};
var JWKSNoMatchingKey = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWKS_NO_MATCHING_KEY";
    this.message = "no applicable key found in the JSON Web Key Set";
  }
  static get code() {
    return "ERR_JWKS_NO_MATCHING_KEY";
  }
};
var JWKSMultipleMatchingKeys = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
    this.message = "multiple matching keys found in the JSON Web Key Set";
  }
  static get code() {
    return "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
  }
};
var JWKSTimeout = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWKS_TIMEOUT";
    this.message = "request timed out";
  }
  static get code() {
    return "ERR_JWKS_TIMEOUT";
  }
};
var JWSSignatureVerificationFailed = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
    this.message = "signature verification failed";
  }
  static get code() {
    return "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
  }
};

// node_modules/jose/dist/browser/runtime/random.js
var random_default = webcrypto_default.getRandomValues.bind(webcrypto_default);

// node_modules/jose/dist/browser/lib/is_object.js
function isObjectLike(value) {
  return typeof value === "object" && value !== null;
}
function isObject(input) {
  if (!isObjectLike(input) || Object.prototype.toString.call(input) !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(input) === null) {
    return true;
  }
  let proto = input;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(input) === proto;
}

// node_modules/jose/dist/browser/jwe/flattened/encrypt.js
var unprotected = Symbol();

// node_modules/jose/dist/browser/lib/secs.js
var minute = 60;
var hour = minute * 60;
var day = hour * 24;
var week = day * 7;
var year = day * 365.25;

// node_modules/jose/dist/browser/jwks/remote.js
var USER_AGENT;
var _a, _b;
if (typeof navigator === "undefined" || !((_b = (_a = navigator.userAgent) == null ? void 0 : _a.startsWith) == null ? void 0 : _b.call(_a, "Mozilla/5.0 "))) {
  const NAME = "jose";
  const VERSION2 = "v5.3.0";
  USER_AGENT = `${NAME}/${VERSION2}`;
}

// node_modules/jose/dist/browser/util/base64url.js
var base64url_exports2 = {};
__export(base64url_exports2, {
  decode: () => decode2,
  encode: () => encode2
});
var encode2 = encode;
var decode2 = decode;

// node_modules/jose/dist/browser/util/decode_jwt.js
function decodeJwt(jwt) {
  if (typeof jwt !== "string")
    throw new JWTInvalid("JWTs must use Compact JWS serialization, JWT must be a string");
  const { 1: payload, length: length4 } = jwt.split(".");
  if (length4 === 5)
    throw new JWTInvalid("Only JWTs using Compact JWS serialization can be decoded");
  if (length4 !== 3)
    throw new JWTInvalid("Invalid JWT");
  if (!payload)
    throw new JWTInvalid("JWTs must contain a payload");
  let decoded;
  try {
    decoded = decode2(payload);
  } catch (e2) {
    throw new JWTInvalid("Failed to base64url decode the payload");
  }
  let result;
  try {
    result = JSON.parse(decoder.decode(decoded));
  } catch (e2) {
    throw new JWTInvalid("Failed to parse the decoded payload as JSON");
  }
  if (!isObject(result))
    throw new JWTInvalid("Invalid JWT Claims Set");
  return result;
}

// src/Exceptions.ts
var RelayException = class extends Error {
  constructor(message) {
    super(message);
    this.name = "[System3] Relay Error";
  }
};

// src/TokenStore.ts
function formatTime(milliseconds) {
  if (milliseconds < 1e3) {
    return `${milliseconds}ms`;
  } else if (milliseconds < 6e4) {
    return `${Math.round(milliseconds / 1e3)}s`;
  } else if (milliseconds < 36e5) {
    return `${Math.round(milliseconds / 6e4)}m`;
  } else {
    return `${Math.round(milliseconds / 36e5)}h`;
  }
}
function _getJwtExpiry(token) {
  const decoded = decodeJwt(token.token);
  if (typeof decoded === "string") {
    return 0;
  }
  const exp = decoded == null ? void 0 : decoded.exp;
  if (!exp) {
    return 0;
  }
  return exp * 1e3;
}
var TokenStore = class {
  constructor(config, maxConnections = 5) {
    this.expiryMargin = 5 * 60 * 1e3;
    // 5 minutes in milliseconds
    this.activeConnections = 0;
    this._activePromises = /* @__PURE__ */ new Map();
    if (config.getStorage) {
      this.tokenMap = config.getStorage();
    } else {
      this.tokenMap = /* @__PURE__ */ new Map();
    }
    this.callbacks = /* @__PURE__ */ new Map();
    this.refreshQueue = /* @__PURE__ */ new Set();
    this._log = config.log;
    this.refresh = config.refresh;
    this.timeProvider = config.getTimeProvider();
    if (config.getJwtExpiry) {
      this.getJwtExpiry = config.getJwtExpiry;
    } else {
      this.getJwtExpiry = _getJwtExpiry;
    }
    this.maxConnections = maxConnections;
    this.refreshInterval = null;
  }
  onRefresh(documentId) {
    const promise = new Promise((resolve, reject) => {
      const onSuccess = (token) => {
        resolve(token);
      };
      const onError = (error) => {
        this.removeFromRefreshQueue(documentId);
        reject(error);
      };
      this.refresh(documentId, onSuccess, onError);
    });
    return promise;
  }
  start() {
    this.log("starting");
    this.report();
    this.refreshInterval = this.timeProvider.setInterval(
      () => this.checkAndRefreshTokens(),
      60 * 1e3
    );
    this.checkAndRefreshTokens();
  }
  stop() {
    this.log("stopping");
    if (this.refreshInterval) {
      this.timeProvider.clearInterval(this.refreshInterval);
      this.refreshInterval = null;
    }
  }
  _cleanupInvalidTokens() {
    const toDelete = [];
    for (const [documentId, tokenInfo] of this.tokenMap.entries()) {
      if (!this.isTokenValid(tokenInfo)) {
        toDelete.push(documentId);
      }
    }
    for (const documentId of toDelete) {
      this.tokenMap.delete(documentId);
    }
  }
  checkAndRefreshTokens() {
    this.log("check and refresh tokens");
    this._cleanupInvalidTokens();
    for (const [documentId, tokenInfo] of this.tokenMap.entries()) {
      if (this.callbacks.has(documentId) && this.shouldRefresh(tokenInfo)) {
        this.log("adding to refresh queue");
        this.addToRefreshQueue(documentId);
      }
    }
    this.log(this.report());
  }
  dequeue() {
    this.log("getting next item in queue");
    if (this.refreshQueue.size > 0) {
      const nextDocumentId = this.refreshQueue.values().next().value;
      this.refreshQueue.delete(nextDocumentId);
      return nextDocumentId;
    }
    return null;
  }
  addToRefreshQueue(documentId) {
    if (this.activeConnections < this.maxConnections) {
      this.log(`immediate refresh of ${documentId}`);
      this.activeConnections++;
      const onSuccess = (newToken) => {
        this.onTokenRefreshed(documentId, newToken);
        this.activeConnections--;
        const next = this.dequeue();
        if (next) {
          this.addToRefreshQueue(next);
        }
      };
      const onError = () => {
        this.onRefreshFailure(documentId);
        this.activeConnections--;
        const next = this.dequeue();
        if (next) {
          this.addToRefreshQueue(next);
        }
      };
      this.refresh(documentId, onSuccess, onError);
    } else {
      this.log(`enqueued refresh of ${documentId}`);
      this.refreshQueue.add(documentId);
    }
  }
  removeFromRefreshQueue(documentId) {
    this.log(`removing ${documentId} from refresh queue`);
    if (this.refreshQueue.has(documentId)) {
      this.refreshQueue.delete(documentId);
      return true;
    }
    return false;
  }
  log(text3) {
    this._log(text3);
  }
  onTokenRefreshed(documentId, token) {
    const expiryTime = this.getJwtExpiry(token);
    if (this.tokenMap.has(documentId)) {
      const existing = this.tokenMap.get(documentId);
      const callback = this.callbacks.get(documentId);
      this.log(`new expiry time is ${expiryTime}`);
      this.tokenMap.set(documentId, {
        ...existing,
        token,
        expiryTime
      });
      callback(token);
      this.log(`Token refreshed for ${existing.friendlyName} (${documentId})`);
    }
  }
  onRefreshFailure(documentId) {
    const existing = this.tokenMap.get(documentId);
    const attempts = (existing == null ? void 0 : existing.attempts) || 0 + 1;
    if (attempts <= 3) {
      this.tokenMap.set(documentId, {
        ...existing,
        attempts
      });
    } else {
      this.tokenMap.delete(documentId);
    }
  }
  isTokenValid(token) {
    const currentTime = this.timeProvider.getTime();
    return currentTime < token.expiryTime;
  }
  shouldRefresh(token) {
    const currentTime = this.timeProvider.getTime();
    return currentTime + this.expiryMargin > token.expiryTime;
  }
  getTokenSync(documentId) {
    var _a2, _b2;
    return (_b2 = (_a2 = this.tokenMap) == null ? void 0 : _a2.get(documentId)) == null ? void 0 : _b2.token;
  }
  getTokenFromNetwork(documentId, friendlyName, callback) {
    const activePromise = this._activePromises.get(documentId);
    if (activePromise) {
      return activePromise;
    }
    this.tokenMap.set(documentId, {
      token: null,
      friendlyName,
      expiryTime: 0,
      attempts: 0
    });
    this.callbacks.set(documentId, callback);
    const sharedPromise = this.onRefresh(documentId).then((newToken) => {
      this.onTokenRefreshed(documentId, newToken);
      this._activePromises.delete(documentId);
      return newToken;
    }).catch((err) => {
      this.onRefreshFailure(documentId);
      this._activePromises.delete(documentId);
      throw err;
    });
    this._activePromises.set(documentId, sharedPromise);
    return sharedPromise;
  }
  async getToken(documentId, friendlyName, callback) {
    this.log(`getting token ${friendlyName}`);
    if (!this.tokenMap) {
      Promise.reject(
        new RelayException(
          "attempted to get token after TokenStore was destroyed."
        )
      );
    }
    if (this.tokenMap.has(documentId)) {
      const tokenInfo = this.tokenMap.get(documentId);
      if (tokenInfo.token && this.isTokenValid(tokenInfo)) {
        this.callbacks.set(documentId, callback);
        tokenInfo.friendlyName = friendlyName;
        callback(tokenInfo.token);
        this.log("token was valid, cache hit!");
        this._activePromises.delete(documentId);
        return Promise.resolve(tokenInfo.token);
      }
    }
    return this.getTokenFromNetwork(documentId, friendlyName, callback);
  }
  _reportWithFilter(filter) {
    const reportLines = [];
    const currentTime = this.timeProvider.getTime();
    const tokens = Array.from(this.tokenMap.entries()).sort((a, b) => {
      return a[1].expiryTime - b[1].expiryTime;
    });
    for (const [documentId, { friendlyName, expiryTime, attempts }] of tokens) {
      if (!filter(documentId)) {
        continue;
      }
      const timeUntilExpiry = expiryTime - currentTime;
      let timeReport = "";
      if (timeUntilExpiry > 0) {
        timeReport = `expires in ${formatTime(
          timeUntilExpiry - this.expiryMargin
        )}`;
      } else {
        timeReport = "expired";
      }
      reportLines.push(
        `${documentId} (${friendlyName}): ${attempts} attempts, (${timeReport})`
      );
    }
    return reportLines;
  }
  report() {
    const reportLines = [];
    reportLines.push("Token Store Report:");
    reportLines.push(`Expiry Margin: ${formatTime(this.expiryMargin)}`);
    reportLines.push("Active Tokens:");
    reportLines.push(
      ...this._reportWithFilter((documentId) => {
        return this.callbacks.has(documentId);
      })
    );
    reportLines.push("Stale Tokens:");
    reportLines.push(
      ...this._reportWithFilter((documentId) => {
        return !this.callbacks.has(documentId);
      })
    );
    reportLines.push(`Queue size: ${this.refreshQueue.size}`);
    return reportLines.join("\n");
  }
  async waitForQueue() {
    return new Promise((resolve) => {
      setInterval(() => {
        if (this.refreshQueue.size == 0) {
          return resolve();
        }
      }, 100);
    });
  }
  clearState() {
    this.refreshQueue.clear();
    for (const [documentId, tokenInfo] of this.tokenMap.entries()) {
      if (this.isTokenValid(tokenInfo)) {
        this.tokenMap.set(documentId, { ...tokenInfo, attempts: 0 });
      } else {
        this.tokenMap.delete(documentId);
      }
    }
  }
  clear() {
    this.tokenMap.clear();
    this.refreshQueue.clear();
  }
  destroy() {
    this.clear();
    this.timeProvider.destroy();
    this.timeProvider = null;
    this.refresh = null;
    this.callbacks.clear();
    this.callbacks = null;
    this._activePromises.clear();
    this._activePromises = null;
    this.tokenMap = null;
  }
};

// src/LiveTokenStore.ts
function getJwtExpiryFromClientToken(clientToken) {
  return clientToken.expiryTime || 0;
}
function withLoginManager(loginManager, fn) {
  return (...args3) => fn(loginManager, ...args3);
}
async function refresh(loginManager, documentId, onSuccess, onError) {
  var _a2;
  const debug2 = curryLog("[TokenStore][Refresh]", "debug");
  const error = curryLog("[TokenStore][Refresh]", "error");
  debug2(`${documentId}`);
  const entity = S3RN.decode(documentId);
  let payload;
  if (entity instanceof S3RemoteDocument) {
    payload = JSON.stringify({
      docId: entity.documentId,
      relay: entity.relayId,
      folder: entity.folderId
    });
  } else if (entity instanceof S3RemoteFolder) {
    payload = JSON.stringify({
      docId: entity.folderId,
      relay: entity.relayId,
      folder: entity.folderId
    });
  } else {
    onError(new Error("No remote to connect to"));
    return;
  }
  if (!loginManager.loggedIn) {
    onError(Error("Not logged in"));
    return;
  }
  const headers = {
    Authorization: `Bearer ${(_a2 = loginManager.user) == null ? void 0 : _a2.token}`,
    "Relay-Version": "0.4.5"
  };
  try {
    const response = await customFetch(`${"https://api.system3.md"}/token`, {
      method: "POST",
      headers,
      body: payload
    });
    if (!response.ok) {
      debug2(response.status, await response.text());
      onError(Error(`Received status code ${response.status} from an API.`));
      return;
    }
    const clientToken = await response.json();
    onSuccess(clientToken);
  } catch (reason) {
    error(reason, payload);
    onError(reason);
  }
}
var LiveTokenStore = class extends TokenStore {
  constructor(loginManager, timeProvider, vaultName, maxConnections = 5) {
    super(
      {
        log: curryLog("[LiveTokenStore]", "debug"),
        refresh: withLoginManager(loginManager, refresh),
        getJwtExpiry: getJwtExpiryFromClientToken,
        getStorage: function() {
          return new LocalStorage(
            "TokenStore/" + vaultName
          );
        },
        getTimeProvider: () => {
          return timeProvider;
        }
      },
      maxConnections
    );
  }
};

// src/NetworkStatus.ts
var import_obsidian21 = require("obsidian");
var NetworkStatus = class {
  constructor(timeProvider, url, interval = 1e4) {
    this.timeProvider = timeProvider;
    this.onOnline = [];
    this.onOffline = [];
    this.online = true;
    this._log = curryLog("[NetworkStatus]");
    this.url = url;
    this.interval = interval;
    this._onceOnline = /* @__PURE__ */ new Set();
  }
  log(message, ...args3) {
    this._log(message, ...args3);
  }
  start() {
    if (!this.timer) {
      this.timer = this.checkStatusRepeatedly();
    }
  }
  stop() {
    if (this.timer) {
      clearInterval(this.timer);
    }
  }
  checkStatusRepeatedly() {
    return this.timeProvider.setInterval(
      this._checkStatus.bind(this),
      this.interval
    );
  }
  checkStatus() {
    if (this.online) {
      return Promise.resolve(true);
    }
    return new Promise((resolve) => {
      this._checkStatus().then(() => {
        resolve(this.online);
      });
    });
  }
  async _checkStatus() {
    return (0, import_obsidian21.requestUrl)({
      url: this.url,
      method: "GET",
      headers: { "Relay-Version": "0.4.5" }
    }).then((response) => {
      if (response.status === 200) {
        if (response.json && response.json.status) {
          this.status = response.json.status;
        }
        if (!this.online) {
          this.log("back online");
          this.online = true;
          this.onOnline.forEach((callback) => callback(this.status));
          this._onceOnline.forEach((callback) => callback(this.status));
          this._onceOnline.clear();
          return;
        }
      } else if (response.status !== 200 && this.online) {
        throw new Error("disconnected");
      }
    }).catch((error) => {
      if (error.message.includes("ERR_NETWORK_CHANGED")) {
        this._checkStatus();
        return;
      }
      this.online = false;
      this.onOffline.forEach((callback) => callback(this.status));
    });
  }
  onceOnline(callback) {
    this._onceOnline.add(callback);
  }
  addEventListener(eventType, callback) {
    if (eventType === "online") {
      this.onOnline.push(callback);
    } else if (eventType === "offline") {
      this.onOffline.push(callback);
    }
  }
  destroy() {
    this._onceOnline.clear();
    this._onceOnline = null;
    this.onOnline = null;
    this.onOffline = null;
    this.timeProvider = null;
  }
};
var NetworkStatus_default = NetworkStatus;

// src/RelayManager.ts
function hasId(obj) {
  return typeof obj.id === "string";
}
function hasName(obj) {
  return typeof obj.name === "string";
}
var RoleCollection = class {
  constructor(roles) {
    this.collectionName = "roles";
    this.roles = roles;
  }
  items() {
    return this.roles.values();
  }
  clear() {
    this.roles.clear();
  }
  get(id2) {
    return this.roles.get(id2);
  }
  ingest(update2) {
    this.roles.set(update2.id, update2);
    return update2;
  }
  delete(id2) {
    this.roles.delete(id2);
  }
};
function hasRoot(obj) {
  return typeof obj.aggregate_root === "object";
}
function hasACL(obj) {
  return typeof obj.acl === "object";
}
var Auto = class {
  get aggregate_root() {
    return;
  }
  get acl() {
    return;
  }
};
var RelayUserAuto = class extends Auto {
  constructor(user) {
    super();
    this.user = user;
  }
  get id() {
    return this.user.id;
  }
  get name() {
    return this.user.name;
  }
  update(update2) {
    this.user = update2;
    return this;
  }
};
var RemoteFolderAuto = class extends Auto {
  constructor(remoteFolder, relays, users) {
    super();
    this.remoteFolder = remoteFolder;
    this.relays = relays;
    this.users = users;
  }
  update(update2) {
    this.remoteFolder = update2;
    return this;
  }
  get id() {
    return this.remoteFolder.id;
  }
  get guid() {
    return this.remoteFolder.guid;
  }
  get name() {
    return this.remoteFolder.name;
  }
  get private() {
    return this.remoteFolder.private;
  }
  get creator() {
    const user = this.users.get(this.remoteFolder.creator);
    if (!user) {
      throw new Error("invalid remote folder");
    }
    return user;
  }
  get relay() {
    const relay = this.relays.get(this.remoteFolder.relay);
    if (!relay) {
      throw new Error("invalid remote folder");
    }
    return relay;
  }
  get aggregate_root() {
    return ["relays", this.remoteFolder.relay];
  }
  get acl() {
    return ["relays", this.remoteFolder.relay];
  }
};
var RemoteFolderCollection = class {
  constructor(remoteFolders, relays, users) {
    this.remoteFolders = remoteFolders;
    this.relays = relays;
    this.users = users;
    this.collectionName = "shared_folders";
  }
  items() {
    return this.remoteFolders.values();
  }
  clear() {
    this.remoteFolders.clear();
  }
  get(id2) {
    return this.remoteFolders.get(id2);
  }
  ingest(update2) {
    const existingFolder = this.remoteFolders.get(update2.id);
    if (existingFolder) {
      existingFolder.update(update2);
      this.remoteFolders.notifyListeners();
      return existingFolder;
    }
    const folder = new RemoteFolderAuto(update2, this.relays, this.users);
    this.remoteFolders.set(update2.id, folder);
    return folder;
  }
  delete(id2) {
    this.remoteFolders.delete(id2);
  }
};
var RelayCollection = class {
  constructor(relays, roles, relayRoles, relayInvitations, remoteFolders, subscriptions, user) {
    this.relays = relays;
    this.roles = roles;
    this.relayRoles = relayRoles;
    this.relayInvitations = relayInvitations;
    this.remoteFolders = remoteFolders;
    this.subscriptions = subscriptions;
    this.user = user;
    this.collectionName = "relays";
  }
  items() {
    return this.relays.values();
  }
  clear() {
    this.relays.clear();
  }
  get(id2) {
    return this.relays.get(id2);
  }
  ingest(update2) {
    const existingRelay = this.relays.get(update2.id);
    if (existingRelay) {
      existingRelay.update(update2);
      this.relays.notifyListeners();
      return existingRelay;
    }
    const relay = new RelayAuto(
      update2,
      this.relayRoles,
      this.relayInvitations,
      this.remoteFolders,
      this.subscriptions,
      this.user
    );
    this.relays.set(relay.id, relay);
    return relay;
  }
  delete(id2) {
    this.relays.delete(id2);
  }
};
var RelayRolesCollection = class {
  constructor(relayRoles, relays, users, roles) {
    this.collectionName = "relay_roles";
    this.relayRoles = relayRoles;
    this.relays = relays;
    this.users = users;
    this.roles = roles;
  }
  items() {
    return this.relayRoles.values();
  }
  clear() {
    this.relayRoles.clear();
  }
  get(id2) {
    return this.relayRoles.get(id2);
  }
  ingest(update2) {
    const existingRole = this.relayRoles.get(update2.id);
    if (existingRole) {
      existingRole.update(update2);
      this.relayRoles.notifyListeners();
      return existingRole;
    }
    const role = new RelayRoleAuto(update2, this.relays, this.users, this.roles);
    this.relayRoles.set(role.id, role);
    return role;
  }
  delete(id2) {
    const relayRole = this.relayRoles.get(id2);
    if (!relayRole) {
      return;
    }
    this.relayRoles.delete(id2);
  }
};
var RelayInvitationsCollection = class {
  constructor(relayInvitations, relays, roles) {
    this.collectionName = "relay_invitations";
    this.relayInvitations = relayInvitations;
    this.relays = relays;
    this.roles = roles;
  }
  items() {
    return this.relayInvitations.values();
  }
  clear() {
    this.relayInvitations.clear();
  }
  get(id2) {
    return this.relayInvitations.get(id2);
  }
  ingest(update2) {
    const existingInvitation = this.relayInvitations.get(update2.id);
    if (existingInvitation) {
      existingInvitation.update(update2);
      this.relayInvitations.notifyListeners();
      return existingInvitation;
    }
    const invitation = new RelayInvitationAuto(update2, this.relays, this.roles);
    this.relayInvitations.set(invitation.id, invitation);
    return invitation;
  }
  delete(id2) {
    this.relayInvitations.delete(id2);
  }
};
var UserCollection = class {
  constructor(users) {
    this.users = users;
    this.collectionName = "users";
  }
  items() {
    return this.users.values();
  }
  clear() {
    this.users.clear();
  }
  get(id2) {
    return this.users.get(id2);
  }
  ingest(update2) {
    const existingUser = this.users.get(update2.id);
    if (existingUser) {
      existingUser.update(update2);
      this.users.notifyListeners();
      return existingUser;
    }
    const user = new RelayUserAuto(update2);
    this.users.set(update2.id, user);
    return user;
  }
  delete(id2) {
    this.users.delete(id2);
  }
};
var RelaySubscriptionCollection = class {
  constructor(subscriptions, relays, users) {
    this.subscriptions = subscriptions;
    this.relays = relays;
    this.users = users;
    this.collectionName = "subscriptions";
  }
  items() {
    return this.subscriptions.values();
  }
  clear() {
    this.subscriptions.clear();
  }
  get(id2) {
    return this.subscriptions.get(id2);
  }
  ingest(update2) {
    const existingsubscription = this.subscriptions.get(update2.id);
    if (existingsubscription) {
      existingsubscription.update(update2);
      this.subscriptions.notifyListeners();
      return existingsubscription;
    }
    const subscription = new RelaySubscriptionAuto(
      update2,
      this.relays,
      this.users
    );
    this.subscriptions.set(update2.id, subscription);
    return subscription;
  }
  delete(id2) {
    this.subscriptions.delete(id2);
  }
};
var Store = class extends HasLogging {
  constructor(collections) {
    super();
    this.collections = /* @__PURE__ */ new Map();
    this.relationships = /* @__PURE__ */ new Map();
    for (const collection of collections) {
      this.collections.set(collection.collectionName, collection);
    }
    RelayInstances.set(this, "Store");
  }
  getCollection(collecitonName) {
    const collection = this.collections.get(collecitonName);
    if (!collection) {
      this.error("No collection found for", collecitonName);
      throw new Error("No collection found for " + collecitonName);
    }
    return collection;
  }
  clear() {
    const postie = PostOffice.getInstance();
    postie.beginTransaction();
    this.collections.forEach((collection) => {
      collection.clear();
    });
    this.collections.clear();
    this.relationships.clear();
    postie.commitTransaction();
  }
  destroy() {
    this.clear();
    this.collections = null;
    this.relationships = null;
  }
  ingestPage(result) {
    return this.ingestBatch(result == null ? void 0 : result.items);
  }
  ingestBatch(records) {
    if (!records) {
      return;
    }
    return records.map((record) => {
      return this.ingest(record);
    });
  }
  ingest(record) {
    const postie = PostOffice.getInstance();
    postie.beginTransaction();
    const result = this._ingest(record);
    postie.commitTransaction();
    return result;
  }
  _ingest(record) {
    if (!record) {
      return;
    }
    let result;
    const collection = this.collections.get(record.collectionName);
    if (collection) {
      result = collection.ingest(record);
    } else {
      this.error("No collection found for record", record);
    }
    if (hasRoot(result)) {
      const aggregate_root = result.aggregate_root;
      if (aggregate_root) {
        const pointer = record.id;
        const refs = this.relationships.get(aggregate_root.join(":")) || /* @__PURE__ */ new Set();
        refs.add([record.collectionName, pointer].join(":"));
        this.relationships.set(aggregate_root.join(":"), refs);
      }
    }
    if (hasACL(result)) {
      const acl = result.acl;
      if (acl) {
        const pointer = record.id;
        const refs = this.relationships.get(acl.join(":")) || /* @__PURE__ */ new Set();
        refs.add([record.collectionName, pointer].join(":"));
        this.relationships.set(acl.join(":"), refs);
      }
    }
    if (record.expand) {
      for (const [, value] of Object.entries(record.expand)) {
        if (Array.isArray(value)) {
          this.ingestBatch(value);
        } else {
          this.ingest(value);
        }
      }
    }
    return result;
  }
  delete(record) {
    this.cascade(record.collectionName, record.id);
  }
  graphviz() {
    let dot = "digraph G {\n";
    for (const [collectionName, collection] of this.collections) {
      for (const record of collection.items()) {
        if (!hasId(record)) {
          this.warn("record has no id", record);
          continue;
        }
        let name = collectionName + "_" + record.id;
        if (hasName(record)) {
          name = collectionName + "_" + record.name;
        }
        dot += `  ${collectionName}_${record.id} [label="${name}"];
`;
        if (hasId(record) && hasRoot(record)) {
          if (record.aggregate_root) {
            const [rootCollection, rootId] = record.aggregate_root;
            dot += `  ${collectionName}_${record.id} -> ${rootCollection}_${rootId};
`;
          }
        }
        if (hasId(record) && hasACL(record)) {
          if (record.acl) {
            const [aclCollection, aclId] = record.acl;
            dot += `  ${collectionName}_${record.id} -> ${aclCollection}_${aclId} [style=dotted];
`;
          }
        }
      }
    }
    dot += "}";
    return dot;
  }
  cascade(collectionName, id2) {
    const collection = this.collections.get(collectionName);
    const children2 = this.relationships.get([collectionName, id2].join(":"));
    const postie = PostOffice.getInstance();
    postie.beginTransaction();
    if (collection) {
      this.warn("cascade delete parent", collectionName, id2);
      collection.delete(id2);
    }
    this.relationships.delete([collectionName, id2].join(":"));
    for (const fqid of children2 || []) {
      const [childCollection, childId] = fqid.split(":");
      this.warn("cascade delete child", childCollection, childId);
      const collection2 = this.getCollection(childCollection);
      if (collection2) {
        this.cascade(childCollection, childId);
      }
    }
    postie.commitTransaction();
  }
};
var RelayRoleAuto = class extends Auto {
  constructor(relayRole, relays, users, roles) {
    super();
    this.users = users;
    this.roles = roles;
    this.relays = relays;
    this.relayRole = relayRole;
  }
  update(relayRole) {
    this.relayRole = relayRole;
    return this;
  }
  get id() {
    return this.relayRole.id;
  }
  get userId() {
    return this.relayRole.user;
  }
  get user() {
    const user = this.users.get(this.relayRole.user);
    if (!user) {
      throw new Error(`Unable to find user: ${this.relayRole.user}`);
    }
    return user;
  }
  get role() {
    var _a2;
    return (_a2 = this.roles.get(this.relayRole.role)) == null ? void 0 : _a2.name;
  }
  get relayId() {
    return this.relayRole.relay;
  }
  get relay() {
    const relay = this.relays.get(this.relayRole.relay);
    if (!relay) {
      throw new Error(
        `invalid role: unable to find relay ${this.relayRole.relay} on role ${this.relayRole.id}`
      );
    }
    return relay;
  }
  get aggregate_root() {
    return ["relays", this.relayRole.relay];
  }
  get acl() {
    return ["users", this.relayRole.user];
  }
};
var RelayInvitationAuto = class {
  constructor(relayInvitation, relays, roles) {
    this.relayInvitation = relayInvitation;
    this.roles = roles;
    this.relays = relays;
  }
  update(relayInvitation) {
    this.relayInvitation = relayInvitation;
    return this;
  }
  get key() {
    return this.relayInvitation.key;
  }
  get id() {
    return this.relayInvitation.id;
  }
  get role() {
    var _a2;
    return (_a2 = this.roles.get(this.relayInvitation.role)) == null ? void 0 : _a2.name;
  }
  get relayId() {
    return this.relayInvitation.relay;
  }
  get relay() {
    const relay = this.relays.get(this.relayInvitation.relay);
    if (!relay) {
      throw new Error("invalid invitation");
    }
    return relay;
  }
  get aggregate_root() {
    return ["relays", this.relayInvitation.relay];
  }
};
var RelaySubscriptionAuto = class extends Observable3 {
  constructor(subscription, relays, users) {
    super();
    this.subscription = subscription;
    this.relays = relays;
    this.users = users;
  }
  update(subscription) {
    this.subscription = subscription;
    this.notifyListeners();
    return this;
  }
  get id() {
    return this.subscription.id;
  }
  get token() {
    return this.subscription.token;
  }
  get active() {
    return this.subscription.active;
  }
  get user() {
    const user = this.users.get(this.subscription.user);
    if (!user) {
      throw new Error("invalid subscription");
    }
    return user;
  }
  get relayId() {
    return this.subscription.relay;
  }
  get relay() {
    const relay = this.relays.get(this.subscription.relay);
    if (!relay) {
      throw new Error("invalid subscription");
    }
    return relay;
  }
  get stripe_cancel_at() {
    return this.subscription.stripe_cancel_at;
  }
  get cancelAt() {
    return this.subscription.stripe_cancel_at !== 0 ? new Date(this.subscription.stripe_cancel_at * 1e3) : null;
  }
  get quantity() {
    return this.subscription.stripe_quantity;
  }
  get aggregate_root() {
    return ["relays", this.subscription.relay];
  }
  get acl() {
    return ["users", this.subscription.user];
  }
};
var RelayAuto = class extends Observable3 {
  constructor(relay, relayRoles, relayInvitations, remoteFolders, _subscriptions, user) {
    super();
    this.relay = relay;
    this.relayRoles = relayRoles;
    this.relayInvitations = relayInvitations;
    this.remoteFolders = remoteFolders;
    this._subscriptions = _subscriptions;
    this.user = user;
  }
  update(update2) {
    this.relay = update2;
    this.notifyListeners();
    return this;
  }
  get cta() {
    return this.relay.cta;
  }
  get plan() {
    return this.relay.plan;
  }
  get id() {
    return this.relay.id;
  }
  get guid() {
    return this.relay.guid;
  }
  get name() {
    return this.relay.name;
  }
  set name(value) {
    this.relay.name = value;
  }
  get userLimit() {
    return this.relay.user_limit;
  }
  get role() {
    var _a2;
    const isCreator = this.relay.creator === this.user.id;
    const role = (_a2 = this.relayRoles.find(
      (role2) => role2.relayId === this.relay.id && role2.userId === this.user.id
    )) == null ? void 0 : _a2.role;
    if (role) {
      return role;
    }
    this.warn("couldn't find role", this.relay.id, this.user, isCreator);
    return isCreator ? "Owner" : "Member";
  }
  get owner() {
    return this.role === "Owner";
  }
  get invitation() {
    return this.relayInvitations.find(
      (invite) => invite.relay.id === this.relay.id
    );
  }
  get folders() {
    return this.remoteFolders.filter((folder) => folder.relay.id === this.id);
  }
  get subscriptions() {
    return this._subscriptions.filter(
      (subscription) => subscription.relay.id === this.id
    );
  }
  get acl() {
    var _a2;
    const id2 = (_a2 = this.relayRoles.find((role) => {
      return role.relayId === this.id && role.userId === this.user.id;
    })) == null ? void 0 : _a2.id;
    if (id2) {
      return ["relay_roles", id2];
    }
  }
  get provider() {
    return this.relay.provider;
  }
};
var RelayManager = class extends HasLogging {
  constructor(loginManager) {
    super();
    this.loginManager = loginManager;
    this.destroyed = false;
    this.pb = this.loginManager.pb;
    this.users = new ObservableMap("users");
    this.relays = new ObservableMap("relays");
    this.remoteFolders = new ObservableMap(
      "remote folders"
    );
    this.relayInvitations = new ObservableMap(
      "relay invitations"
    );
    this.relayRoles = new ObservableMap("relay roles");
    this.roles = new ObservableMap("roles");
    this.roles.set("2arnubkcv7jpce8", {
      name: "Owner",
      id: "2arnubkcv7jpce8"
    });
    this.roles.set("x6lllh2qsf9lxk6", {
      name: "Member",
      id: "x6lllh2qsf9lxk6"
    });
    this.subscriptions = new ObservableMap(
      "subscriptions"
    );
    this._offLoginManager = this.loginManager.on(() => {
      this.login();
    });
    this.setUser();
    if (!this.user) {
      return;
    }
    RelayInstances.set(this, "RelayManager");
    this.buildGraph();
    this.subscribe();
    this.update();
  }
  buildGraph() {
    if (!this.user) {
      return;
    }
    if (this.store) {
      return;
    }
    const roleCollection = new RoleCollection(this.roles);
    const userCollection = new UserCollection(this.users);
    const relayCollection = new RelayCollection(
      this.relays,
      this.roles,
      this.relayRoles,
      this.relayInvitations,
      this.remoteFolders,
      this.subscriptions,
      this.user
    );
    const relayRolesCollection = new RelayRolesCollection(
      this.relayRoles,
      this.relays,
      this.users,
      this.roles
    );
    const relayInvitationsCollection = new RelayInvitationsCollection(
      this.relayInvitations,
      this.relays,
      this.roles
    );
    const sharedFolderCollection = new RemoteFolderCollection(
      this.remoteFolders,
      this.relays,
      this.users
    );
    const subscriptionCollection = new RelaySubscriptionCollection(
      this.subscriptions,
      this.relays,
      this.users
    );
    this.store = new Store([
      roleCollection,
      userCollection,
      relayCollection,
      relayRolesCollection,
      relayInvitationsCollection,
      sharedFolderCollection,
      subscriptionCollection
    ]);
  }
  setUser() {
    var _a2;
    this.authUser = (_a2 = this.pb) == null ? void 0 : _a2.authStore.model;
    if (this.authUser) {
      this.user = new RelayUserAuto(this.authUser);
      this.users.set(this.user.id, this.user);
    }
  }
  login() {
    this.setUser();
    this.buildGraph();
    this.subscribe();
    this.update();
  }
  logout() {
    var _a2;
    (_a2 = this.store) == null ? void 0 : _a2.clear();
    this.user = void 0;
    this.store = void 0;
  }
  async getRelayInvitationKey(relay) {
    if (!this.pb)
      return "";
    const relayInvitation = this.relayInvitations.find((invite) => {
      return invite.relay.id === relay.id;
    });
    if (relayInvitation == null ? void 0 : relayInvitation.key) {
      return relayInvitation.key;
    }
    return this.pb.collection("relay_invitations").getList(0, 200).then((invitations) => {
      invitations.items.forEach((invite2) => {
        var _a2;
        (_a2 = this.store) == null ? void 0 : _a2.ingest(invite2);
      });
      const invite = this.relayInvitations.find((invite2) => {
        return invite2.relay.id === relay.id;
      });
      if (invite) {
        return invite.key;
      }
      return "";
    });
  }
  async getSubscriptionToken(subscription) {
    if (!this.pb || !this.pb.authStore.isValid) {
      throw new Error("Auth is not valid");
    }
    const url = `/api/subscription/${subscription.id}/token`;
    const response = await this.pb.send(url, {
      method: "POST"
    });
    if (response !== 200) {
      throw new Error("Token API failed");
    }
    return response.json()["token"];
  }
  async subscribe() {
    var _a2;
    if (!this.pb || !this.pb.authStore.isValid || ((_a2 = this.pb.authStore.model) == null ? void 0 : _a2.id) === void 0) {
      return;
    }
    const collections = [
      {
        name: "relays",
        expand: [
          "relay_invitations_via_relay",
          "shared_folders_via_relay",
          "shared_folders_via_relay.creator",
          "subscriptions_via_relay",
          "subscriptions_via_relay.relay",
          "creator"
        ]
      },
      { name: "relay_invitations", expand: ["relay"] },
      { name: "relay_roles", expand: ["user", "relay"] },
      { name: "shared_folders", expand: ["relay", "creator"] },
      { name: "subscriptions", expand: ["user", "relay"] }
    ];
    const handleEvent = (collectionName, e2) => {
      var _a3, _b2;
      this.debug(`[Event]: ${collectionName}`, e2.action, e2.record);
      if (e2.action === "delete") {
        (_a3 = this.store) == null ? void 0 : _a3.delete(e2.record);
      } else {
        (_b2 = this.store) == null ? void 0 : _b2.ingest(e2.record);
      }
    };
    for (const collection of collections) {
      this.pb.collection(collection.name).subscribe("*", (e2) => handleEvent(collection.name, e2), {
        expand: collection.expand.join(","),
        fetch: customFetch
      });
    }
  }
  collection(collectionName) {
    if (!this.pb)
      return;
  }
  async update() {
    const withPb = (collection, options = {}) => {
      var _a2;
      if (!this.pb || !this.pb.authStore.isValid || ((_a2 = this.pb.authStore.model) == null ? void 0 : _a2.id) === void 0) {
        return Promise.resolve([]);
      }
      if (typeof options === "function") {
        options = options(this.pb.authStore.model.id);
      }
      return this.pb.collection(collection).getFullList(options);
    };
    const promises = [
      withPb("users", (userId) => ({
        filter: `id="${userId}"`,
        expand: "relay_roles_via_user,relay_roles_via_user.relay,relay_roles_via_user.role"
      })),
      withPb("relay_roles", {
        expand: "user"
      }),
      withPb("relay_invitations"),
      withPb("shared_folders", {
        expand: "relay,creator"
      }),
      withPb("subscriptions", {
        expand: "relay,user"
      })
    ];
    promises.forEach(async (promise) => {
      const result = await promise;
      for (const record of result) {
        if (!this.destroyed && this.store) {
          this.store.ingest(record);
        }
      }
    });
  }
  async acceptInvitation(shareKey) {
    var _a2;
    if (!this.pb)
      throw new Error("Failed to accept invitation");
    const response = await this.pb.send("/api/accept-invitation", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        key: shareKey
      })
    });
    this.debug("[InviteAccept]", response);
    const relay = (_a2 = this.store) == null ? void 0 : _a2.ingest(response);
    if (!relay) {
      throw new Error("Failed to accept invitation");
    }
    return relay;
  }
  async createRelay(name) {
    var _a2;
    const guid = v4_default();
    const record = await ((_a2 = this.pb) == null ? void 0 : _a2.collection("relays").create({
      guid,
      name,
      path: null
    }));
    if (!record) {
      throw new Error("Failed to create Relay");
    }
    if (!this.user) {
      throw new Error("Not Logged In");
    }
    const relay = new RelayAuto(
      record,
      this.relayRoles,
      this.relayInvitations,
      this.remoteFolders,
      this.subscriptions,
      this.user
    );
    this.relays.set(relay.id, relay);
    return relay;
  }
  async updateRelay(relay) {
    var _a2;
    if (!this.pb)
      throw new Error("Failed to update relay");
    const record = await this.pb.collection("relays").update(relay.id, {
      name: relay.name.trim()
    });
    const updated = (_a2 = this.store) == null ? void 0 : _a2.ingest(record);
    if (!updated) {
      throw new Error("Failed to update relay");
    }
    return updated;
  }
  async deleteRemote(folder) {
    var _a2;
    folder.remote = void 0;
    const remote = this.remoteFolders.find(
      (remote2) => remote2.guid === folder.guid
    );
    if (!remote) {
      return false;
    }
    await ((_a2 = this.pb) == null ? void 0 : _a2.collection("shared_folders").delete(remote.id));
    folder.remote = void 0;
    return true;
  }
  async createRemoteFolder(sharedFolder, relay) {
    var _a2, _b2;
    if (!this.pb)
      throw new Error("Failed to create folder");
    const record = await this.pb.collection("shared_folders").create(
      {
        name: sharedFolder.name,
        guid: sharedFolder.guid,
        relay: relay.id,
        creator: (_a2 = this.user) == null ? void 0 : _a2.id,
        private: false
      },
      { expand: "relay" }
    );
    const folder = (_b2 = this.store) == null ? void 0 : _b2.ingest(record);
    if (!folder) {
      throw new Error("Failed to create folder");
    }
    return folder;
  }
  async destroyRelay(relay) {
    var _a2, _b2;
    await ((_a2 = this.pb) == null ? void 0 : _a2.collection("relays").delete(relay.id));
    (_b2 = this.store) == null ? void 0 : _b2.cascade("relays", relay.id);
    return true;
  }
  async leaveRelay(relay) {
    var _a2, _b2;
    const role = this.relayRoles.find((role2) => {
      var _a3;
      return role2.userId === ((_a3 = this.user) == null ? void 0 : _a3.id) && role2.relayId === relay.id;
    });
    if (role) {
      await ((_a2 = this.pb) == null ? void 0 : _a2.collection("relay_roles").delete(role.id));
    } else {
      this.warn("No role found to leave relay");
    }
    (_b2 = this.store) == null ? void 0 : _b2.cascade("relay", relay.id);
  }
  async kick(relay_role) {
    var _a2;
    return (_a2 = this.pb) == null ? void 0 : _a2.collection("relay_roles").delete(relay_role.id);
  }
  destroy() {
    var _a2, _b2;
    this.destroyed = true;
    if (this._offLoginManager) {
      this._offLoginManager();
    }
    (_a2 = this.pb) == null ? void 0 : _a2.cancelAllRequests();
    this.loginManager = null;
    this.pb = null;
    (_b2 = this.store) == null ? void 0 : _b2.destroy();
    this.authUser = null;
    this.store = null;
  }
};

// src/main.ts
var import_obsidian34 = require("obsidian");

// src/ui/FeatureFlagModal.ts
var import_obsidian23 = require("obsidian");

// src/components/FeatureFlagModalContent.svelte
var import_obsidian22 = require("obsidian");
function add_css18(target) {
  append_styles(target, "svelte-4kkvmr", ".feature-flag-toggle-modal.svelte-4kkvmr{padding:1rem}.feature-flag-item.svelte-4kkvmr{display:flex;justify-content:space-between;align-items:center;padding:0.5rem 0;border-top:1px solid var(--background-modifier-border)}.checkbox-container.svelte-4kkvmr{cursor:pointer}");
}
function get_each_context5(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i2][0];
  child_ctx[9] = list[i2][1];
  return child_ctx;
}
function create_each_block5(ctx) {
  let div6;
  let div2;
  let div0;
  let t0_value = (
    /*flagName*/
    ctx[8] + ""
  );
  let t0;
  let t1;
  let div1;
  let t2;
  let t3_value = (
    /*flagName*/
    ctx[8] + ""
  );
  let t3;
  let t4;
  let t5;
  let div5;
  let div4;
  let input;
  let input_checked_value;
  let t6;
  let div3;
  let div4_aria_checked_value;
  let mounted;
  let dispose;
  function keypress_handler2() {
    return (
      /*keypress_handler*/
      ctx[6](
        /*flagName*/
        ctx[8]
      )
    );
  }
  function click_handler() {
    return (
      /*click_handler*/
      ctx[7](
        /*flagName*/
        ctx[8]
      )
    );
  }
  return {
    c() {
      div6 = element2("div");
      div2 = element2("div");
      div0 = element2("div");
      t0 = text2(t0_value);
      t1 = space();
      div1 = element2("div");
      t2 = text2("Toggle ");
      t3 = text2(t3_value);
      t4 = text2(" on or off");
      t5 = space();
      div5 = element2("div");
      div4 = element2("div");
      input = element2("input");
      t6 = space();
      div3 = element2("div");
      attr(div0, "class", "setting-item-name");
      attr(div1, "class", "setting-item-description");
      attr(div2, "class", "setting-item-info");
      attr(input, "type", "checkbox");
      attr(input, "tabindex", "-1");
      input.checked = input_checked_value = /*value*/
      ctx[9];
      attr(div3, "class", "checkbox-toggle");
      attr(div4, "role", "checkbox");
      attr(div4, "aria-checked", div4_aria_checked_value = /*value*/
      ctx[9]);
      attr(div4, "tabindex", "0");
      attr(div4, "class", "checkbox-container svelte-4kkvmr");
      toggle_class(
        div4,
        "is-enabled",
        /*value*/
        ctx[9]
      );
      attr(div5, "class", "setting-item-control");
      attr(div6, "class", "feature-flag-item setting-item svelte-4kkvmr");
    },
    m(target, anchor) {
      insert(target, div6, anchor);
      append2(div6, div2);
      append2(div2, div0);
      append2(div0, t0);
      append2(div2, t1);
      append2(div2, div1);
      append2(div1, t2);
      append2(div1, t3);
      append2(div1, t4);
      append2(div6, t5);
      append2(div6, div5);
      append2(div5, div4);
      append2(div4, input);
      append2(div4, t6);
      append2(div4, div3);
      if (!mounted) {
        dispose = [
          listen(div4, "keypress", keypress_handler2),
          listen(div4, "click", click_handler)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*flags*/
      2 && t0_value !== (t0_value = /*flagName*/
      ctx[8] + ""))
        set_data(t0, t0_value);
      if (dirty & /*flags*/
      2 && t3_value !== (t3_value = /*flagName*/
      ctx[8] + ""))
        set_data(t3, t3_value);
      if (dirty & /*flags*/
      2 && input_checked_value !== (input_checked_value = /*value*/
      ctx[9])) {
        input.checked = input_checked_value;
      }
      if (dirty & /*flags*/
      2 && div4_aria_checked_value !== (div4_aria_checked_value = /*value*/
      ctx[9])) {
        attr(div4, "aria-checked", div4_aria_checked_value);
      }
      if (dirty & /*Object, flags*/
      2) {
        toggle_class(
          div4,
          "is-enabled",
          /*value*/
          ctx[9]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div6);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment49(ctx) {
  let div2;
  let h2;
  let t1;
  let t2;
  let div1;
  let div0;
  let button;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(Object.entries(
    /*flags*/
    ctx[1]
  ));
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block5(get_each_context5(ctx, each_value, i2));
  }
  return {
    c() {
      div2 = element2("div");
      h2 = element2("h2");
      h2.textContent = "Feature Flags";
      t1 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t2 = space();
      div1 = element2("div");
      div0 = element2("div");
      button = element2("button");
      button.textContent = "Apply";
      attr(button, "aria-label", "apply flag settings");
      attr(button, "tabindex", "0");
      attr(div0, "class", "setting-item-control");
      attr(div1, "class", "setting-item");
      attr(div2, "class", "feature-flag-toggle-modal svelte-4kkvmr");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append2(div2, h2);
      append2(div2, t1);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div2, null);
        }
      }
      append2(div2, t2);
      append2(div2, div1);
      append2(div1, div0);
      append2(div0, button);
      if (!mounted) {
        dispose = [
          listen(button, "click", function() {
            if (is_function(
              /*reload*/
              ctx[0]
            ))
              ctx[0].apply(this, arguments);
          }),
          listen(button, "keypress", function() {
            if (is_function(
              /*reload*/
              ctx[0]
            ))
              ctx[0].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & /*Object, flags, isKeyOfFeatureFlags, Error, toggleFlag*/
      26) {
        each_value = ensure_array_like(Object.entries(
          /*flags*/
          ctx[1]
        ));
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context5(ctx, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block5(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div2, t2);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance48($$self, $$props, $$invalidate) {
  let flags2;
  let $flagManager;
  let { reload } = $$props;
  let flagManager = FeatureFlagManager.getInstance();
  component_subscribe($$self, flagManager, (value) => $$invalidate(5, $flagManager = value));
  function toggleFlag(flagName) {
    const flagValue = !flags2[flagName];
    $$invalidate(1, flags2[flagName] = flagValue, flags2);
    flagManager.setFlag(flagName, flags2[flagName]);
  }
  function isKeyOfFeatureFlags(key) {
    return key in flags2;
  }
  onMount(() => {
    Object.keys(flags2).forEach((flagName) => {
      const toggleEl = document.getElementById(`toggle-${flagName}`);
      if (toggleEl) {
        (0, import_obsidian22.setIcon)(toggleEl, "check");
      }
    });
  });
  const keypress_handler2 = (flagName) => {
    if (!isKeyOfFeatureFlags(flagName))
      throw new Error("Unexpected feature flag!");
    toggleFlag(flagName);
  };
  const click_handler = (flagName) => {
    if (!isKeyOfFeatureFlags(flagName))
      throw new Error("Unexpected feature flag!");
    toggleFlag(flagName);
  };
  $$self.$$set = ($$props2) => {
    if ("reload" in $$props2)
      $$invalidate(0, reload = $$props2.reload);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$flagManager*/
    32) {
      $:
        $$invalidate(1, flags2 = Object.assign({}, $flagManager.flags));
    }
  };
  return [
    reload,
    flags2,
    flagManager,
    toggleFlag,
    isKeyOfFeatureFlags,
    $flagManager,
    keypress_handler2,
    click_handler
  ];
}
var FeatureFlagModalContent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance48, create_fragment49, safe_not_equal, { reload: 0 }, add_css18);
  }
};
var FeatureFlagModalContent_default = FeatureFlagModalContent;

// src/ui/FeatureFlagModal.ts
var FeatureFlagToggleModal = class extends import_obsidian23.Modal {
  constructor(app, reload) {
    super(app);
    this.reload = reload;
  }
  onOpen() {
    const { contentEl } = this;
    this.component = new FeatureFlagModalContent_default({
      target: contentEl,
      props: {
        reload: this.reload
      }
    });
  }
  onClose() {
    var _a2;
    const { contentEl } = this;
    contentEl.empty();
    (_a2 = this.component) == null ? void 0 : _a2.$destroy();
  }
};

// src/ui/DebugModal.ts
var import_obsidian25 = require("obsidian");

// src/components/DebugModalContent.svelte
var import_obsidian24 = require("obsidian");
function get_each_context6(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i2];
  return child_ctx;
}
function get_each_context_13(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i2];
  return child_ctx;
}
function create_default_slot_53(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element2("button");
      button.textContent = "Refresh";
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", (0, import_obsidian24.debounce)(
          /*click_handler*/
          ctx[12]
        ));
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_44(ctx) {
  let t_value = navigator.userAgent + "";
  let t2;
  return {
    c() {
      t2 = text2(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_34(ctx) {
  let t2;
  return {
    c() {
      t2 = text2(
        /*$fetchImpl*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$fetchImpl*/
      2)
        set_data(
          t2,
          /*$fetchImpl*/
          ctx2[1]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_24(ctx) {
  let t2;
  return {
    c() {
      t2 = text2(
        /*$responseImpl*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$responseImpl*/
      4)
        set_data(
          t2,
          /*$responseImpl*/
          ctx2[2]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_17(ctx) {
  let t2;
  return {
    c() {
      t2 = text2(
        /*$usingBlink*/
        ctx[3]
      );
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$usingBlink*/
      8)
        set_data(
          t2,
          /*$usingBlink*/
          ctx2[3]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot28(ctx) {
  let t_value = (
    /*plugin*/
    ctx[0].loadTime ? `${/*plugin*/
    ctx[0].loadTime}ms` : "unknown"
  );
  let t2;
  return {
    c() {
      t2 = text2(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*plugin*/
      1 && t_value !== (t_value = /*plugin*/
      ctx2[0].loadTime ? `${/*plugin*/
      ctx2[0].loadTime}ms` : "unknown"))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_each_block_13(ctx) {
  let div;
  let t0_value = `${/*connection*/
  ctx[16]}`;
  let t0;
  let t1;
  return {
    c() {
      div = element2("div");
      t0 = text2(t0_value);
      t1 = space();
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append2(div, t0);
      append2(div, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*$anyPb*/
      16 && t0_value !== (t0_value = `${/*connection*/
      ctx2[16]}`))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_description_slot_12(ctx) {
  let div;
  let each_value_1 = ensure_array_like(Object.keys(
    /*$anyPb*/
    ctx[4].cancelControllers
  ));
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_13(get_each_context_13(ctx, each_value_1, i2));
  }
  return {
    c() {
      div = element2("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "slot", "description");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*Object, $anyPb*/
      16) {
        each_value_1 = ensure_array_like(Object.keys(
          /*$anyPb*/
          ctx2[4].cancelControllers
        ));
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_13(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_13(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block6(ctx) {
  let div;
  let t0_value = `${/*lfile*/
  ctx[13]}`;
  let t0;
  let t1;
  return {
    c() {
      div = element2("div");
      t0 = text2(t0_value);
      t1 = space();
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append2(div, t0);
      append2(div, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*$logFiles*/
      32 && t0_value !== (t0_value = `${/*lfile*/
      ctx2[13]}`))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_description_slot2(ctx) {
  let div;
  let each_value = ensure_array_like(
    /*$logFiles*/
    ctx[5]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block6(get_each_context6(ctx, each_value, i2));
  }
  return {
    c() {
      div = element2("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "slot", "description");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$logFiles*/
      32) {
        each_value = ensure_array_like(
          /*$logFiles*/
          ctx2[5]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context6(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block6(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_fragment50(ctx) {
  let div0;
  let t1;
  let div1;
  let settingitemheading0;
  let t2;
  let settingitem0;
  let t3;
  let settingitem1;
  let t4;
  let settingitem2;
  let t5;
  let settingitem3;
  let t6;
  let settingitem4;
  let t7;
  let settingitemheading1;
  let t8;
  let settingitem5;
  let t9;
  let settingitemheading2;
  let t10;
  let settingitem6;
  let current;
  settingitemheading0 = new SettingItemHeading_default({
    props: {
      name: "Environment",
      $$slots: { default: [create_default_slot_53] },
      $$scope: { ctx }
    }
  });
  settingitem0 = new SettingItem_default({
    props: {
      name: "User Agent",
      description: "",
      $$slots: { default: [create_default_slot_44] },
      $$scope: { ctx }
    }
  });
  settingitem1 = new SettingItem_default({
    props: {
      name: "Fetch",
      description: "",
      $$slots: { default: [create_default_slot_34] },
      $$scope: { ctx }
    }
  });
  settingitem2 = new SettingItem_default({
    props: {
      name: "Response",
      description: "",
      $$slots: { default: [create_default_slot_24] },
      $$scope: { ctx }
    }
  });
  settingitem3 = new SettingItem_default({
    props: {
      name: "Blink Fetch",
      description: "",
      $$slots: { default: [create_default_slot_17] },
      $$scope: { ctx }
    }
  });
  settingitem4 = new SettingItem_default({
    props: {
      name: "Startup Time",
      description: "",
      $$slots: { default: [create_default_slot28] },
      $$scope: { ctx }
    }
  });
  settingitemheading1 = new SettingItemHeading_default({ props: { name: "Connections" } });
  settingitem5 = new SettingItem_default({
    props: {
      name: "",
      description: "",
      $$slots: { description: [create_description_slot_12] },
      $$scope: { ctx }
    }
  });
  settingitemheading2 = new SettingItemHeading_default({ props: { name: "Log Files" } });
  settingitem6 = new SettingItem_default({
    props: {
      name: "",
      description: "",
      $$slots: { description: [create_description_slot2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div0 = element2("div");
      div0.textContent = "Debug Info";
      t1 = space();
      div1 = element2("div");
      create_component(settingitemheading0.$$.fragment);
      t2 = space();
      create_component(settingitem0.$$.fragment);
      t3 = space();
      create_component(settingitem1.$$.fragment);
      t4 = space();
      create_component(settingitem2.$$.fragment);
      t5 = space();
      create_component(settingitem3.$$.fragment);
      t6 = space();
      create_component(settingitem4.$$.fragment);
      t7 = space();
      create_component(settingitemheading1.$$.fragment);
      t8 = space();
      create_component(settingitem5.$$.fragment);
      t9 = space();
      create_component(settingitemheading2.$$.fragment);
      t10 = space();
      create_component(settingitem6.$$.fragment);
      attr(div0, "class", "modal-title");
      attr(div1, "class", "modal-content");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      insert(target, t1, anchor);
      insert(target, div1, anchor);
      mount_component(settingitemheading0, div1, null);
      append2(div1, t2);
      mount_component(settingitem0, div1, null);
      append2(div1, t3);
      mount_component(settingitem1, div1, null);
      append2(div1, t4);
      mount_component(settingitem2, div1, null);
      append2(div1, t5);
      mount_component(settingitem3, div1, null);
      append2(div1, t6);
      mount_component(settingitem4, div1, null);
      append2(div1, t7);
      mount_component(settingitemheading1, div1, null);
      append2(div1, t8);
      mount_component(settingitem5, div1, null);
      append2(div1, t9);
      mount_component(settingitemheading2, div1, null);
      append2(div1, t10);
      mount_component(settingitem6, div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const settingitemheading0_changes = {};
      if (dirty & /*$$scope*/
      524288) {
        settingitemheading0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitemheading0.$set(settingitemheading0_changes);
      const settingitem0_changes = {};
      if (dirty & /*$$scope*/
      524288) {
        settingitem0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem0.$set(settingitem0_changes);
      const settingitem1_changes = {};
      if (dirty & /*$$scope, $fetchImpl*/
      524290) {
        settingitem1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem1.$set(settingitem1_changes);
      const settingitem2_changes = {};
      if (dirty & /*$$scope, $responseImpl*/
      524292) {
        settingitem2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem2.$set(settingitem2_changes);
      const settingitem3_changes = {};
      if (dirty & /*$$scope, $usingBlink*/
      524296) {
        settingitem3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem3.$set(settingitem3_changes);
      const settingitem4_changes = {};
      if (dirty & /*$$scope, plugin*/
      524289) {
        settingitem4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem4.$set(settingitem4_changes);
      const settingitem5_changes = {};
      if (dirty & /*$$scope, $anyPb*/
      524304) {
        settingitem5_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem5.$set(settingitem5_changes);
      const settingitem6_changes = {};
      if (dirty & /*$$scope, $logFiles*/
      524320) {
        settingitem6_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem6.$set(settingitem6_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitemheading0.$$.fragment, local);
      transition_in(settingitem0.$$.fragment, local);
      transition_in(settingitem1.$$.fragment, local);
      transition_in(settingitem2.$$.fragment, local);
      transition_in(settingitem3.$$.fragment, local);
      transition_in(settingitem4.$$.fragment, local);
      transition_in(settingitemheading1.$$.fragment, local);
      transition_in(settingitem5.$$.fragment, local);
      transition_in(settingitemheading2.$$.fragment, local);
      transition_in(settingitem6.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitemheading0.$$.fragment, local);
      transition_out(settingitem0.$$.fragment, local);
      transition_out(settingitem1.$$.fragment, local);
      transition_out(settingitem2.$$.fragment, local);
      transition_out(settingitem3.$$.fragment, local);
      transition_out(settingitem4.$$.fragment, local);
      transition_out(settingitemheading1.$$.fragment, local);
      transition_out(settingitem5.$$.fragment, local);
      transition_out(settingitemheading2.$$.fragment, local);
      transition_out(settingitem6.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t1);
        detach(div1);
      }
      destroy_component(settingitemheading0);
      destroy_component(settingitem0);
      destroy_component(settingitem1);
      destroy_component(settingitem2);
      destroy_component(settingitem3);
      destroy_component(settingitem4);
      destroy_component(settingitemheading1);
      destroy_component(settingitem5);
      destroy_component(settingitemheading2);
      destroy_component(settingitem6);
    }
  };
}
function getResponse2() {
  try {
    return Response.toString();
  } catch (e2) {
    return "undefined";
  }
}
function getFetch2() {
  try {
    return fetch.toString();
  } catch (e2) {
    return "undefined";
  }
}
function getUsingBlink2() {
  try {
    return (globalThis === null || globalThis === void 0 ? void 0 : globalThis.blinkfetch) !== void 0 ? "Yes" : "No";
  } catch (e2) {
    return "No";
  }
}
function instance49($$self, $$props, $$invalidate) {
  let $fetchImpl;
  let $responseImpl;
  let $usingBlink;
  let $anyPb;
  let $logFiles;
  let { plugin } = $$props;
  let responseImpl = writable(getResponse2());
  component_subscribe($$self, responseImpl, (value) => $$invalidate(2, $responseImpl = value));
  let fetchImpl = writable(getFetch2());
  component_subscribe($$self, fetchImpl, (value) => $$invalidate(1, $fetchImpl = value));
  let usingBlink = writable(getUsingBlink2());
  component_subscribe($$self, usingBlink, (value) => $$invalidate(3, $usingBlink = value));
  let anyPb = writable(plugin.loginManager.pb);
  component_subscribe($$self, anyPb, (value) => $$invalidate(4, $anyPb = value));
  let logFiles = writable([]);
  component_subscribe($$self, logFiles, (value) => $$invalidate(5, $logFiles = value));
  getAllLogFiles().then((files) => {
    logFiles.set(files);
  });
  function refresh2() {
    responseImpl.set(getResponse2());
    fetchImpl.set(getFetch2());
    usingBlink.set(getUsingBlink2());
    anyPb.set(plugin.loginManager.pb);
  }
  const click_handler = () => {
    refresh2();
  };
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
  };
  return [
    plugin,
    $fetchImpl,
    $responseImpl,
    $usingBlink,
    $anyPb,
    $logFiles,
    responseImpl,
    fetchImpl,
    usingBlink,
    anyPb,
    logFiles,
    refresh2,
    click_handler
  ];
}
var DebugModalContent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance49, create_fragment50, safe_not_equal, { plugin: 0 });
  }
};
var DebugModalContent_default = DebugModalContent;

// src/ui/DebugModal.ts
var DebugModal = class extends import_obsidian25.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    this.component = new DebugModalContent_default({
      target: contentEl,
      props: {
        plugin: this.plugin
      }
    });
  }
  onClose() {
    var _a2;
    const { contentEl } = this;
    contentEl.empty();
    (_a2 = this.component) == null ? void 0 : _a2.$destroy();
  }
};

// src/SettingsStorage.ts
var SettingsError = class extends Error {
  constructor(message, path) {
    super(message);
    this.path = path;
    this.name = "SettingsError";
  }
};
var Settings2 = class extends Observable3 {
  constructor(storage, defaults) {
    super();
    this.storage = storage;
    this.defaults = defaults;
    this._loaded = false;
    this.data = { ...defaults };
  }
  async load() {
    const stored = await this.storage.loadData();
    this.data = {
      ...this.defaults,
      ...stored || {}
    };
    this._loaded = true;
    this.log("Loaded settings from disk:", this.data);
  }
  async save() {
    if (!this._loaded) {
      this.warn("Attempted to save before loading settings from disk");
      return;
    }
    this.warn("Saving settings to disk:", this.data);
    await this.storage.saveData(this.data);
  }
  get() {
    return this.data;
  }
  async update(updater) {
    if (!this._loaded) {
      this.warn("Attempted to update before loading settings from disk");
      return;
    }
    const updated = updater(this.data);
    const stored = await this.storage.loadData();
    if (JSON.stringify(updated) === JSON.stringify(stored)) {
      this.debug("updated matches disk, no change");
      return;
    }
    this.data = updated;
    await this.save();
    this.notifyListeners();
  }
  notifyListeners() {
    for (const listener of this._listeners) {
      listener(this.data);
    }
  }
};
var NamespacedSettings = class extends Observable3 {
  constructor(settings, namespace) {
    super();
    this.settings = settings;
    this.patterns = [];
    this.destroyed = false;
    this.validatePath(namespace);
    [this.path, this.basePath, this.patterns] = this.processPath(namespace);
    this.lastKnown = this.getNestedValue(this.settings.get());
    this.setupSubscription();
  }
  isWildcardPattern(pattern) {
    return pattern.type === "wildcard";
  }
  validatePath(path) {
    if (!path) {
      throw new SettingsError("Path cannot be empty");
    }
    if (path.startsWith("/") || path.endsWith("/")) {
      throw new SettingsError(`Invalid path format: ${path}`);
    }
  }
  createPatternRegex(pattern) {
    return pattern.replace(/[.*+?^${}()|[\]\\]/g, "\\$&").replace("\\*", ".*");
  }
  setupSubscription() {
    this.unsub = this.settings.subscribe(() => {
      const newValue = this.getNestedValue(this.settings.get());
      if (this.lastKnown === void 0 && newValue === void 0)
        return;
      if (JSON.stringify(this.lastKnown) !== JSON.stringify(newValue)) {
        this.lastKnown = newValue;
        this.notifyListeners();
      }
    });
  }
  hasArrayPatterns() {
    return this.patterns.some((p) => p.type === "arrayMatch");
  }
  destroy() {
    if (this.destroyed)
      return;
    if (this.unsub) {
      this.unsub();
      this.unsub = void 0;
    }
    this._listeners.clear();
    this.destroyed = true;
  }
  get() {
    if (this.destroyed) {
      throw new SettingsError("Cannot use destroyed settings", this.getPath());
    }
    const data = this.settings.get();
    if (!data) {
      return {};
    }
    const wildcardPattern = this.patterns.find(this.isWildcardPattern);
    if (wildcardPattern && this.path.length === 1) {
      const regex = new RegExp(`^${wildcardPattern.wildcardPattern}$`);
      const filtered = Object.entries(data).filter(([key]) => regex.test(key)).reduce(
        (obj, [key, value2]) => {
          obj[key] = value2;
          return obj;
        },
        {}
      );
      return filtered;
    }
    const value = this.getNestedValue(data);
    if (value === void 0) {
      return {};
    }
    return value;
  }
  async set(value) {
    if (this.destroyed) {
      throw new SettingsError("Cannot use destroyed settings", this.getPath());
    }
    if (value === void 0) {
      throw new SettingsError("Cannot set undefined value", this.getPath());
    }
    try {
      await this.settings.update((data) => {
        const wildcardPattern = this.patterns.find(this.isWildcardPattern);
        if (wildcardPattern) {
          if (this.path.length === 1) {
            const regex2 = new RegExp(`^${wildcardPattern.wildcardPattern}$`);
            const result2 = { ...data };
            Object.entries(value).forEach(([key, val]) => {
              if (regex2.test(key)) {
                result2[key] = val;
              }
            });
            return result2;
          }
          const result = { ...data };
          let current = result;
          this.path.forEach((key) => {
            current[key] = current[key] || {};
            current = current[key];
          });
          const regex = new RegExp(`^${wildcardPattern.wildcardPattern}$`);
          Object.entries(value).forEach(([key, val]) => {
            if (regex.test(key)) {
              current[key] = val;
            }
          });
          return result;
        }
        return this.setNestedValue(data, value);
      });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      throw new SettingsError(
        `Failed to set value at path ${this.getPath()}: ${errorMessage}`,
        this.getPath()
      );
    }
  }
  async update(updater, force = false) {
    if (this.destroyed) {
      throw new SettingsError("Cannot use destroyed settings", this.getPath());
    }
    const current = this.get();
    const updated = updater(current);
    if (!force && JSON.stringify(current) === JSON.stringify(updated)) {
      return;
    }
    await this.set(updated);
  }
  async flush() {
    if (this.destroyed) {
      throw new SettingsError("Cannot use destroyed settings", this.getPath());
    }
    await this.update((current) => current, true);
  }
  processPath(namespace) {
    const segments = namespace.split("/").filter((p) => p);
    const path = [];
    const basePath = [];
    const patterns = [];
    segments.forEach((segment, index) => {
      const arrayMatch = segment.match(/^\[(\w+)=(.+)\]$/);
      const wildcardMatch = segment.match(/^\((.+?)\)$/);
      if (arrayMatch) {
        const [, key, value] = arrayMatch;
        const baseKey = index > 0 ? basePath[index - 1] : segment.split("[")[0];
        patterns.push({
          type: "arrayMatch",
          key,
          value,
          level: index
        });
        path.push(segment);
        basePath.push(baseKey);
      } else if (wildcardMatch) {
        const [, pattern] = wildcardMatch;
        patterns.push({
          type: "wildcard",
          wildcardPattern: this.createPatternRegex(pattern),
          level: index
        });
        path.push(segment);
        basePath.push(segment);
      } else {
        path.push(segment);
        basePath.push(segment);
      }
    });
    return [path, basePath, patterns];
  }
  getNestedValue(obj) {
    let current = obj;
    const wildcardPattern = this.patterns.find(this.isWildcardPattern);
    if (wildcardPattern && this.path.length === 1) {
      const regex = new RegExp(`^${wildcardPattern.wildcardPattern}$`);
      const filtered = Object.entries(current).filter(([key]) => regex.test(key)).reduce(
        (obj2, [key, value]) => {
          obj2[key] = value;
          return obj2;
        },
        {}
      );
      return filtered;
    }
    const firstPattern = this.patterns[0];
    if ((firstPattern == null ? void 0 : firstPattern.type) === "arrayMatch") {
      const baseKey = this.basePath[0];
      if (!Array.isArray(current[baseKey]))
        return void 0;
      const matchedItem = current[baseKey].find(
        (item) => item[firstPattern.key] === firstPattern.value
      );
      if (!matchedItem)
        return void 0;
      const remainingPath = this.basePath.slice(firstPattern.level + 1);
      if (remainingPath.length > 0) {
        let result = matchedItem;
        for (const key of remainingPath) {
          if (!result || typeof result !== "object")
            return void 0;
          result = result[key];
        }
        return result;
      }
      return matchedItem;
    }
    for (let i2 = 0; i2 < this.basePath.length; i2++) {
      if (!current)
        return void 0;
      current = current[this.basePath[i2]];
    }
    return current;
  }
  setNestedValue(obj, value) {
    const result = { ...obj };
    const arrayPattern = this.patterns.find((p) => p.type === "arrayMatch");
    if (arrayPattern) {
      const baseKey = this.basePath[0];
      if (!result[baseKey]) {
        result[baseKey] = [];
      }
      const index = result[baseKey].findIndex(
        (item) => item[arrayPattern.key] === arrayPattern.value
      );
      const remainingPath = this.basePath.slice(arrayPattern.level + 1);
      if (index >= 0) {
        if (remainingPath.length > 0) {
          let current2 = result[baseKey][index];
          for (let i2 = 0; i2 < remainingPath.length - 1; i2++) {
            const key = remainingPath[i2];
            current2[key] = current2[key] || {};
            current2 = current2[key];
          }
          const lastKey2 = remainingPath[remainingPath.length - 1];
          current2[lastKey2] = value;
        } else {
          result[baseKey][index] = {
            ...result[baseKey][index],
            ...value,
            [arrayPattern.key]: arrayPattern.value
          };
        }
      } else {
        if (remainingPath.length > 0) {
          const newItem = {
            [arrayPattern.key]: arrayPattern.value
          };
          let current2 = newItem;
          for (let i2 = 0; i2 < remainingPath.length - 1; i2++) {
            const key = remainingPath[i2];
            current2[key] = {};
            current2 = current2[key];
          }
          const lastKey2 = remainingPath[remainingPath.length - 1];
          current2[lastKey2] = value;
          result[baseKey].push(newItem);
        } else {
          result[baseKey].push({
            ...value,
            [arrayPattern.key]: arrayPattern.value
          });
        }
      }
      return result;
    }
    let current = result;
    for (let i2 = 0; i2 < this.basePath.length - 1; i2++) {
      const baseKey = this.basePath[i2];
      current[baseKey] = current[baseKey] || {};
      current = current[baseKey];
    }
    const lastKey = this.basePath[this.basePath.length - 1];
    current[lastKey] = value;
    return result;
  }
  getParent() {
    if (this.destroyed) {
      throw new SettingsError("Cannot use destroyed settings", this.getPath());
    }
    const parentPath = this.path.slice(0, -1).join("/");
    return new NamespacedSettings(this.settings, parentPath);
  }
  getChild(childPath, factory) {
    const fullPath = [...this.path, childPath].join("/");
    if (factory) {
      return factory(this.settings, fullPath);
    }
    this.log("getChild", this.path, childPath, fullPath, this.patterns);
    return new NamespacedSettings(this.settings, fullPath);
  }
  getPath() {
    return this.path.join("/");
  }
  exists() {
    if (this.destroyed) {
      throw new SettingsError("Cannot use destroyed settings", this.getPath());
    }
    const data = this.settings.get();
    return this.getNestedValue(data) !== void 0;
  }
  async delete() {
    if (this.destroyed) {
      throw new SettingsError("Cannot use destroyed settings", this.getPath());
    }
    await this.settings.update((data) => {
      const result = { ...data };
      const arrayPattern = this.patterns.find(
        (p) => p.type === "arrayMatch"
      );
      if (arrayPattern) {
        const baseKey = this.basePath[0];
        if (Array.isArray(result[baseKey])) {
          result[baseKey] = result[baseKey].filter(
            (item) => item[arrayPattern.key] !== arrayPattern.value
          );
          if (result[baseKey].length === 0) {
            delete result[baseKey];
          }
        }
        return result;
      }
      let current = result;
      const keys2 = this.basePath.slice(0, -1);
      for (const key of keys2) {
        if (!current[key])
          return result;
        current = current[key];
      }
      const lastKey = this.basePath[this.basePath.length - 1];
      delete current[lastKey];
      return result;
    });
  }
  subscribe(run2) {
    if (this.destroyed) {
      throw new SettingsError("Cannot use destroyed settings", this.getPath());
    }
    this._listeners.add(run2);
    run2(this.get());
    return () => {
      this._listeners.delete(run2);
    };
  }
  notifyListeners() {
    if (this.destroyed) {
      return;
    }
    const value = this.get();
    for (const listener of this._listeners) {
      listener(value);
    }
  }
};

// src/debugObsididan.ts
var import_obsidian26 = require("obsidian");
var ObsidianNotifier = class {
  notify(message) {
    new import_obsidian26.Notice(message);
  }
};
var ObsidianFileAdapter = class {
  constructor(vault) {
    this.vault = vault;
  }
  async append(path, content) {
    return this.vault.adapter.append(path, content);
  }
  async stat(path) {
    return this.vault.adapter.stat(path);
  }
  async exists(path) {
    return this.vault.adapter.exists(path);
  }
  async remove(path) {
    return this.vault.adapter.remove(path);
  }
  async rename(oldPath, newPath) {
    return this.vault.adapter.rename(oldPath, newPath);
  }
  async write(path, content) {
    return this.vault.adapter.write(path, content);
  }
  async read(path) {
    return this.vault.adapter.read(path);
  }
};

// src/main.ts
var import_url = require("url");

// src/ui/BugReportModal.ts
var import_obsidian28 = require("obsidian");

// src/components/BugReportModalContent.svelte
var import_obsidian27 = require("obsidian");
function add_css19(target) {
  append_styles(target, "svelte-jmqfac", ".system3-bug-report.svelte-jmqfac{display:flex;flex-direction:column;height:100%;min-height:30em}.report-container.svelte-jmqfac{display:flex;flex-direction:column;flex:1}.form-content.svelte-jmqfac{flex:1;overflow-y:auto}textarea.svelte-jmqfac{width:100%;height:300px;resize:vertical}.centered-message.svelte-jmqfac{display:flex;flex:1;align-items:center;justify-content:center;padding-bottom:5em}");
}
function get_each_context7(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list[i2];
  return child_ctx;
}
function create_else_block12(ctx) {
  let div1;
  let div0;
  let settingitem0;
  let t0;
  let textarea;
  let t1;
  let settingitem1;
  let t2;
  let t3;
  let settingitem2;
  let current;
  let mounted;
  let dispose;
  settingitem0 = new SettingItem_default({
    props: {
      name: "Description",
      description: "Please describe what went wrong and what you were trying to do."
    }
  });
  settingitem1 = new SettingItem_default({
    props: {
      name: "Include Logs",
      description: "Send logs to the Relay developers to help them debug the issue.",
      $$slots: { default: [create_default_slot_18] },
      $$scope: { ctx }
    }
  });
  let if_block = (
    /*$includeLogs*/
    ctx[4] && create_if_block_26(ctx)
  );
  settingitem2 = new SettingItem_default({
    props: {
      name: "",
      description: "",
      $$slots: { default: [create_default_slot29] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div1 = element2("div");
      div0 = element2("div");
      create_component(settingitem0.$$.fragment);
      t0 = space();
      textarea = element2("textarea");
      t1 = space();
      create_component(settingitem1.$$.fragment);
      t2 = space();
      if (if_block)
        if_block.c();
      t3 = space();
      create_component(settingitem2.$$.fragment);
      attr(textarea, "placeholder", "Describe the issue here...");
      attr(textarea, "class", "svelte-jmqfac");
      attr(div0, "class", "form-content svelte-jmqfac");
      attr(div1, "class", "report-container svelte-jmqfac");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append2(div1, div0);
      mount_component(settingitem0, div0, null);
      append2(div0, t0);
      append2(div0, textarea);
      set_input_value(
        textarea,
        /*$bugDescription*/
        ctx[3]
      );
      append2(div0, t1);
      mount_component(settingitem1, div0, null);
      append2(div0, t2);
      if (if_block)
        if_block.m(div0, null);
      append2(div1, t3);
      mount_component(settingitem2, div1, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          textarea,
          "input",
          /*textarea_input_handler*/
          ctx[13]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$bugDescription*/
      8) {
        set_input_value(
          textarea,
          /*$bugDescription*/
          ctx2[3]
        );
      }
      const settingitem1_changes = {};
      if (dirty & /*$$scope, $includeLogs*/
      16777232) {
        settingitem1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem1.$set(settingitem1_changes);
      if (
        /*$includeLogs*/
        ctx2[4]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$includeLogs*/
          16) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_26(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div0, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const settingitem2_changes = {};
      if (dirty & /*$$scope, $sending, plugin, $anyPb, $bugDescription*/
      16777293) {
        settingitem2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem2.$set(settingitem2_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem0.$$.fragment, local);
      transition_in(settingitem1.$$.fragment, local);
      transition_in(if_block);
      transition_in(settingitem2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem0.$$.fragment, local);
      transition_out(settingitem1.$$.fragment, local);
      transition_out(if_block);
      transition_out(settingitem2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(settingitem0);
      destroy_component(settingitem1);
      if (if_block)
        if_block.d();
      destroy_component(settingitem2);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_110(ctx) {
  let div2;
  return {
    c() {
      div2 = element2("div");
      div2.innerHTML = `<div id="spinner" class="d-flex align-items-center"><strong>Sending Bug Report...</strong> <div class="spinner-border ms-auto" role="status" aria-hidden="true"></div></div>`;
      attr(div2, "class", "centered-message svelte-jmqfac");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
    }
  };
}
function create_if_block17(ctx) {
  let div;
  let settingitem;
  let current;
  settingitem = new SettingItem_default({
    props: {
      name: "Thank you!",
      description: "Your bug report will help us improve Relay."
    }
  });
  return {
    c() {
      div = element2("div");
      create_component(settingitem.$$.fragment);
      attr(div, "class", "centered-message svelte-jmqfac");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(settingitem, div, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(settingitem);
    }
  };
}
function create_default_slot_18(ctx) {
  let div1;
  let input;
  let t2;
  let div0;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element2("div");
      input = element2("input");
      t2 = space();
      div0 = element2("div");
      attr(input, "type", "checkbox");
      attr(input, "tabindex", "-1");
      input.checked = /*$includeLogs*/
      ctx[4];
      attr(div0, "class", "checkbox-toggle");
      attr(div1, "role", "checkbox");
      attr(
        div1,
        "aria-checked",
        /*$includeLogs*/
        ctx[4]
      );
      attr(div1, "tabindex", "0");
      attr(div1, "class", "checkbox-container");
      toggle_class(
        div1,
        "is-enabled",
        /*$includeLogs*/
        ctx[4]
      );
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append2(div1, input);
      append2(div1, t2);
      append2(div1, div0);
      if (!mounted) {
        dispose = [
          listen(div1, "keypress", keypress_handler),
          listen(
            div1,
            "click",
            /*click_handler*/
            ctx[14]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$includeLogs*/
      16) {
        input.checked = /*$includeLogs*/
        ctx2[4];
      }
      if (dirty & /*$includeLogs*/
      16) {
        attr(
          div1,
          "aria-checked",
          /*$includeLogs*/
          ctx2[4]
        );
      }
      if (dirty & /*$includeLogs*/
      16) {
        toggle_class(
          div1,
          "is-enabled",
          /*$includeLogs*/
          ctx2[4]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_26(ctx) {
  let settingitem;
  let current;
  settingitem = new SettingItem_default({
    props: {
      name: "Logs",
      description: "",
      $$slots: { description: [create_description_slot3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const settingitem_changes = {};
      if (dirty & /*$$scope, $logFiles*/
      16777248) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem, detaching);
    }
  };
}
function create_each_block7(ctx) {
  let div;
  let t0_value = `${/*lfile*/
  ctx[21]}
`;
  let t0;
  let t1;
  return {
    c() {
      div = element2("div");
      t0 = text2(t0_value);
      t1 = space();
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append2(div, t0);
      append2(div, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*$logFiles*/
      32 && t0_value !== (t0_value = `${/*lfile*/
      ctx2[21]}
`))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_description_slot3(ctx) {
  let div;
  let each_value = ensure_array_like(
    /*$logFiles*/
    ctx[5]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block7(get_each_context7(ctx, each_value, i2));
  }
  return {
    c() {
      div = element2("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "slot", "description");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$logFiles*/
      32) {
        each_value = ensure_array_like(
          /*$logFiles*/
          ctx2[5]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context7(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block7(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_default_slot29(ctx) {
  let button;
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      button = element2("button");
      t2 = text2("Send");
      button.disabled = /*$sending*/
      ctx[2];
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append2(button, t2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler_1*/
          ctx[15]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$sending*/
      4) {
        button.disabled = /*$sending*/
        ctx2[2];
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment51(ctx) {
  let div0;
  let t1;
  let div1;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block17, create_if_block_110, create_else_block12];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$sent*/
      ctx2[1]
    )
      return 0;
    if (
      /*$sending*/
      ctx2[2] && !/*$sent*/
      ctx2[1]
    )
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div0 = element2("div");
      div0.textContent = "Send Bug Report";
      t1 = space();
      div1 = element2("div");
      if_block.c();
      attr(div0, "class", "modal-title");
      attr(div1, "class", "modal-content system3-bug-report svelte-jmqfac");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      insert(target, t1, anchor);
      insert(target, div1, anchor);
      if_blocks[current_block_type_index].m(div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div1, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t1);
        detach(div1);
      }
      if_blocks[current_block_type_index].d();
    }
  };
}
function getResponse3() {
  try {
    return Response.toString();
  } catch (e2) {
    return "undefined";
  }
}
function getFetch3() {
  try {
    return fetch.toString();
  } catch (e2) {
    return "undefined";
  }
}
function getUsingBlink3() {
  try {
    return (globalThis === null || globalThis === void 0 ? void 0 : globalThis.blinkfetch) !== void 0 ? "Yes" : "No";
  } catch (e2) {
    return "No";
  }
}
var keypress_handler = () => {
};
function instance50($$self, $$props, $$invalidate) {
  let $sent;
  let $sending;
  let $bugDescription;
  let $includeLogs;
  let $logFiles;
  let $anyPb;
  let { plugin } = $$props;
  let responseImpl = writable(getResponse3());
  let fetchImpl = writable(getFetch3());
  let usingBlink = writable(getUsingBlink3());
  let bugDescription = writable("");
  component_subscribe($$self, bugDescription, (value) => $$invalidate(3, $bugDescription = value));
  let includeLogs = writable(false);
  component_subscribe($$self, includeLogs, (value) => $$invalidate(4, $includeLogs = value));
  let showInfo = writable(false);
  let sending = writable(false);
  component_subscribe($$self, sending, (value) => $$invalidate(2, $sending = value));
  let sent = writable(false);
  component_subscribe($$self, sent, (value) => $$invalidate(1, $sent = value));
  let anyPb = writable(plugin.loginManager.pb);
  component_subscribe($$self, anyPb, (value) => $$invalidate(6, $anyPb = value));
  let logFiles = writable([]);
  component_subscribe($$self, logFiles, (value) => $$invalidate(5, $logFiles = value));
  getAllLogFiles().then((files) => {
    logFiles.set(files);
  });
  function refresh2() {
    responseImpl.set(getResponse3());
    fetchImpl.set(getFetch3());
    usingBlink.set(getUsingBlink3());
    anyPb.set(plugin.loginManager.pb);
  }
  function textarea_input_handler() {
    $bugDescription = this.value;
    bugDescription.set($bugDescription);
  }
  const click_handler = () => {
    const newValue = !$includeLogs;
    includeLogs.set(newValue);
  };
  const click_handler_1 = async () => {
    var _a2;
    let bugReport = "Bug Report\n\n";
    bugReport += JSON.stringify(
      {
        userAgent: navigator.userAgent,
        manifest: plugin.manifest,
        user: (_a2 = $anyPb == null ? void 0 : $anyPb.authStore.model) == null ? void 0 : _a2.id,
        loadTime: plugin.loadTime,
        description: $bugDescription
      },
      null,
      2
    );
    bugReport += "\n\n";
    if (includeLogs) {
      const logs = await getAllLogs();
      bugReport += logs;
    }
    (0, import_obsidian27.requestUrl)({
      url: "https://bug-reports.system3.dev",
      method: "PUT",
      body: bugReport,
      headers: { "Content-Type": "text/plain" }
    }).then(() => {
      sent.set(true);
    });
    sending.set(true);
  };
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
  };
  return [
    plugin,
    $sent,
    $sending,
    $bugDescription,
    $includeLogs,
    $logFiles,
    $anyPb,
    bugDescription,
    includeLogs,
    sending,
    sent,
    anyPb,
    logFiles,
    textarea_input_handler,
    click_handler,
    click_handler_1
  ];
}
var BugReportModalContent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance50, create_fragment51, safe_not_equal, { plugin: 0 }, add_css19);
  }
};
var BugReportModalContent_default = BugReportModalContent;

// src/ui/BugReportModal.ts
var BugReportModal = class extends import_obsidian28.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    this.component = new BugReportModalContent_default({
      target: contentEl,
      props: {
        plugin: this.plugin
      }
    });
  }
  onClose() {
    var _a2;
    const { contentEl } = this;
    contentEl.empty();
    (_a2 = this.component) == null ? void 0 : _a2.$destroy();
  }
};

// src/ui/IndexedDBAnalysisModal.ts
var import_obsidian30 = require("obsidian");

// src/DatabaseTools.ts
async function analyzeIndexedDB(options) {
  const { appId, filterByAppId, onProgress } = options;
  const databases = await window.indexedDB.databases();
  const totalDatabases = databases.length;
  const largeStores = [];
  let totalStores = 0;
  let totalItems = 0;
  let totalSize = 0;
  let processedDatabases = 0;
  for (const dbInfo of databases) {
    if (!dbInfo.name)
      continue;
    try {
      const db = await new Promise((resolve, reject) => {
        const request = indexedDB.open(dbInfo.name);
        request.onerror = () => reject(request.error);
        request.onsuccess = (event) => resolve(event.target.result);
      });
      try {
        const storeNames = Array.from(db.objectStoreNames);
        if (!storeNames.includes("updates") || !storeNames.includes("custom")) {
          continue;
        }
        const tx = db.transaction(["updates", "custom"], "readonly");
        const store = tx.objectStore("updates");
        const customStore = tx.objectStore("custom");
        const dbAppId = await new Promise((resolve) => {
          const request = customStore.get("appId");
          request.onsuccess = () => resolve(request.result || "");
        });
        totalStores++;
        const count2 = await new Promise((resolve, reject) => {
          const countRequest = store.count();
          countRequest.onsuccess = () => resolve(countRequest.result);
          countRequest.onerror = () => reject(countRequest.error);
        });
        totalItems += count2;
        if (count2 > 0) {
          let storeSize = 0;
          await new Promise((resolve, reject) => {
            const cursorRequest = store.openCursor();
            cursorRequest.onsuccess = (event) => {
              const cursor = event.target.result;
              if (cursor) {
                const size = cursor.value instanceof Uint8Array ? cursor.value.byteLength : JSON.stringify(cursor.value).length;
                storeSize += size;
                cursor.continue();
              } else {
                resolve();
              }
            };
            cursorRequest.onerror = () => reject(cursorRequest.error);
          });
          totalSize += storeSize;
          if (storeSize > 1024 * 1024 && (!filterByAppId || dbAppId === appId)) {
            const path = await new Promise((resolve) => {
              const request = customStore.get("path");
              request.onsuccess = () => resolve(request.result || "");
            });
            const relay = await new Promise((resolve) => {
              const request = customStore.get("relay");
              request.onsuccess = () => resolve(request.result || "");
            });
            const isLegacy = !dbInfo.name.startsWith(`${appId}-relay`);
            largeStores.push({
              slug: `${dbInfo.name}/${store.name}`,
              path,
              relay,
              appId: dbAppId || "unknown",
              count: count2,
              estimatedSizeMB: Math.round(storeSize / (1024 * 1024) * 100) / 100,
              isLegacy
            });
          }
        }
      } finally {
        db.close();
      }
    } catch (error) {
      console.error(`Error processing database ${dbInfo.name}:`, error);
      continue;
    }
    processedDatabases++;
    if (onProgress) {
      onProgress(processedDatabases / databases.length * 100);
    }
  }
  return {
    totalStores,
    totalItems,
    totalSizeMB: Math.round(totalSize / (1024 * 1024) * 100) / 100,
    databaseCount: totalDatabases,
    largeStores: largeStores.sort(
      (a, b) => b.estimatedSizeMB - a.estimatedSizeMB
    )
  };
}
async function deleteBySlug(slug) {
  const [dbName, storeName] = slug.split("/");
  const db = await new Promise((resolve, reject) => {
    const request = indexedDB.open(dbName);
    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);
  });
  try {
    const tx = db.transaction(storeName, "readwrite");
    const store = tx.objectStore(storeName);
    await new Promise((resolve, reject) => {
      const request = store.clear();
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  } catch (error) {
    console.error(`Error deleting store: ${slug}`, error);
  } finally {
    db.close();
  }
}

// src/components/IndexedDBAnalysisModalContent.svelte
var import_obsidian29 = require("obsidian");
function add_css20(target) {
  append_styles(target, "svelte-1n3w4sk", ".system3-dangerous.svelte-1n3w4sk:enabled{background-color:var(--background-modifier-error)}.system3-indexeddb-analysis.svelte-1n3w4sk{padding:1rem;max-height:500px;overflow-y:auto}.system3-loading-container.svelte-1n3w4sk{display:flex;flex-direction:column;align-items:center;justify-content:center;height:200px;gap:1rem}.system3-loading-spinner.svelte-1n3w4sk{border:4px solid var(--background-modifier-border);border-top:4px solid var(--interactive-accent);border-radius:50%;width:40px;height:40px;animation:svelte-1n3w4sk-spin 1s linear infinite}.system3-progress-bar.svelte-1n3w4sk{width:80%;height:8px;border-radius:4px;background-color:var(--background-secondary);overflow:hidden;margin:0 auto}.system3-progress-fill.svelte-1n3w4sk{height:100%;background-color:var(--color-accent);border-radius:4px;transition:width 0.3s ease;min-width:0%;max-width:100%}.system3-error-message.svelte-1n3w4sk{color:var(--text-error);padding:1rem;background-color:var(--mod-error);border-radius:4px}.system3-actions.svelte-1n3w4sk{display:flex;gap:0.5rem}.system3-summary-stats.svelte-1n3w4sk{display:grid;grid-template-columns:repeat(3, 1fr);gap:1rem;margin-bottom:2rem;padding:1rem;background-color:var(--background-secondary);border-radius:4px}.system3-stat-item.svelte-1n3w4sk{text-align:center}.system3-global-count.svelte-1n3w4sk{grid-column:1 / -1;padding-top:0.5rem;margin-top:0.5rem;border-bottom:1px solid var(--background-modifier-border)}.system3-warning.svelte-1n3w4sk{color:var(--text-warning)}.system3-critical.svelte-1n3w4sk{color:var(--text-error)}.system3-warning-text.svelte-1n3w4sk{font-size:0.8em;margin-top:0.5rem;color:var(--text-warning);line-height:1.4}.system3-warning-text.system3-critical.svelte-1n3w4sk{color:var(--text-error);font-weight:bold}.system3-stat-label.svelte-1n3w4sk{font-size:0.9em;color:var(--text-muted);margin-bottom:0.5rem}.system3-stat-value.svelte-1n3w4sk{font-size:1.2em;font-weight:bold}@keyframes svelte-1n3w4sk-spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}");
}
function get_each_context8(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list[i2][0];
  child_ctx[19] = list[i2][1];
  return child_ctx;
}
function get_each_context_14(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[22] = list[i2];
  return child_ctx;
}
function create_if_block_27(ctx) {
  let div12;
  let div2;
  let div0;
  let t1;
  let div1;
  let t2_value = (
    /*$stats*/
    ctx[0].databaseCount.toLocaleString() + ""
  );
  let t2;
  let t3;
  let t4;
  let t5;
  let div5;
  let div3;
  let t7;
  let div4;
  let t8_value = (
    /*$stats*/
    ctx[0].totalStores + ""
  );
  let t8;
  let t9;
  let div8;
  let div6;
  let t11;
  let div7;
  let t12_value = (
    /*$stats*/
    ctx[0].totalItems.toLocaleString() + ""
  );
  let t12;
  let t13;
  let div11;
  let div9;
  let t15;
  let div10;
  let t16_value = (
    /*$stats*/
    ctx[0].totalSizeMB.toFixed(2) + ""
  );
  let t16;
  let t17;
  let t18;
  let if_block1_anchor;
  let current;
  function select_block_type_1(ctx2, dirty) {
    if (
      /*$stats*/
      ctx2[0].databaseCount > 45e3
    )
      return create_if_block_44;
    if (
      /*$stats*/
      ctx2[0].databaseCount > 4e4
    )
      return create_if_block_52;
  }
  let current_block_type = select_block_type_1(ctx, -1);
  let if_block0 = current_block_type && current_block_type(ctx);
  let if_block1 = (
    /*$stats*/
    ctx[0].largeStores.length > 0 && create_if_block_34(ctx)
  );
  return {
    c() {
      div12 = element2("div");
      div2 = element2("div");
      div0 = element2("div");
      div0.textContent = "Global Database Limit";
      t1 = space();
      div1 = element2("div");
      t2 = text2(t2_value);
      t3 = text2(" / 50,000");
      t4 = space();
      if (if_block0)
        if_block0.c();
      t5 = space();
      div5 = element2("div");
      div3 = element2("div");
      div3.textContent = "Relay Databases";
      t7 = space();
      div4 = element2("div");
      t8 = text2(t8_value);
      t9 = space();
      div8 = element2("div");
      div6 = element2("div");
      div6.textContent = "Document Updates";
      t11 = space();
      div7 = element2("div");
      t12 = text2(t12_value);
      t13 = space();
      div11 = element2("div");
      div9 = element2("div");
      div9.textContent = "Total Size";
      t15 = space();
      div10 = element2("div");
      t16 = text2(t16_value);
      t17 = text2(" MB");
      t18 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
      attr(div0, "class", "system3-stat-label svelte-1n3w4sk");
      attr(div1, "class", "system3-stat-value svelte-1n3w4sk");
      toggle_class(
        div1,
        "system3-warning",
        /*$stats*/
        ctx[0].databaseCount > 4e4
      );
      toggle_class(
        div1,
        "system3-critical",
        /*$stats*/
        ctx[0].databaseCount > 45e3
      );
      attr(div2, "class", "system3-stat-item system3-global-count svelte-1n3w4sk");
      attr(div3, "class", "system3-stat-label svelte-1n3w4sk");
      attr(div4, "class", "system3-stat-value svelte-1n3w4sk");
      attr(div5, "class", "system3-stat-item svelte-1n3w4sk");
      attr(div6, "class", "system3-stat-label svelte-1n3w4sk");
      attr(div7, "class", "system3-stat-value svelte-1n3w4sk");
      attr(div8, "class", "system3-stat-item svelte-1n3w4sk");
      attr(div9, "class", "system3-stat-label svelte-1n3w4sk");
      attr(div10, "class", "system3-stat-value svelte-1n3w4sk");
      attr(div11, "class", "system3-stat-item svelte-1n3w4sk");
      attr(div12, "class", "system3-summary-stats svelte-1n3w4sk");
    },
    m(target, anchor) {
      insert(target, div12, anchor);
      append2(div12, div2);
      append2(div2, div0);
      append2(div2, t1);
      append2(div2, div1);
      append2(div1, t2);
      append2(div1, t3);
      append2(div2, t4);
      if (if_block0)
        if_block0.m(div2, null);
      append2(div12, t5);
      append2(div12, div5);
      append2(div5, div3);
      append2(div5, t7);
      append2(div5, div4);
      append2(div4, t8);
      append2(div12, t9);
      append2(div12, div8);
      append2(div8, div6);
      append2(div8, t11);
      append2(div8, div7);
      append2(div7, t12);
      append2(div12, t13);
      append2(div12, div11);
      append2(div11, div9);
      append2(div11, t15);
      append2(div11, div10);
      append2(div10, t16);
      append2(div10, t17);
      insert(target, t18, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & /*$stats*/
      1) && t2_value !== (t2_value = /*$stats*/
      ctx2[0].databaseCount.toLocaleString() + ""))
        set_data(t2, t2_value);
      if (!current || dirty & /*$stats*/
      1) {
        toggle_class(
          div1,
          "system3-warning",
          /*$stats*/
          ctx2[0].databaseCount > 4e4
        );
      }
      if (!current || dirty & /*$stats*/
      1) {
        toggle_class(
          div1,
          "system3-critical",
          /*$stats*/
          ctx2[0].databaseCount > 45e3
        );
      }
      if (current_block_type !== (current_block_type = select_block_type_1(ctx2, dirty))) {
        if (if_block0)
          if_block0.d(1);
        if_block0 = current_block_type && current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div2, null);
        }
      }
      if ((!current || dirty & /*$stats*/
      1) && t8_value !== (t8_value = /*$stats*/
      ctx2[0].totalStores + ""))
        set_data(t8, t8_value);
      if ((!current || dirty & /*$stats*/
      1) && t12_value !== (t12_value = /*$stats*/
      ctx2[0].totalItems.toLocaleString() + ""))
        set_data(t12, t12_value);
      if ((!current || dirty & /*$stats*/
      1) && t16_value !== (t16_value = /*$stats*/
      ctx2[0].totalSizeMB.toFixed(2) + ""))
        set_data(t16, t16_value);
      if (
        /*$stats*/
        ctx2[0].largeStores.length > 0
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$stats*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_34(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div12);
        detach(t18);
        detach(if_block1_anchor);
      }
      if (if_block0) {
        if_block0.d();
      }
      if (if_block1)
        if_block1.d(detaching);
    }
  };
}
function create_if_block_111(ctx) {
  let div;
  let t2;
  return {
    c() {
      div = element2("div");
      t2 = text2(
        /*$error*/
        ctx[5]
      );
      attr(div, "class", "system3-error-message svelte-1n3w4sk");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append2(div, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*$error*/
      32)
        set_data(
          t2,
          /*$error*/
          ctx2[5]
        );
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block18(ctx) {
  let div4;
  let div0;
  let t0;
  let div1;
  let t2;
  let div3;
  let div2;
  return {
    c() {
      div4 = element2("div");
      div0 = element2("div");
      t0 = space();
      div1 = element2("div");
      div1.textContent = "Analyzing Databases...";
      t2 = space();
      div3 = element2("div");
      div2 = element2("div");
      attr(div0, "class", "system3-loading-spinner svelte-1n3w4sk");
      attr(div1, "class", "loading-text");
      attr(div2, "class", "system3-progress-fill svelte-1n3w4sk");
      set_style(
        div2,
        "width",
        /*$progress*/
        ctx[4] + "%"
      );
      attr(div3, "class", "system3-progress-bar svelte-1n3w4sk");
      attr(div4, "class", "system3-loading-container svelte-1n3w4sk");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append2(div4, div0);
      append2(div4, t0);
      append2(div4, div1);
      append2(div4, t2);
      append2(div4, div3);
      append2(div3, div2);
    },
    p(ctx2, dirty) {
      if (dirty & /*$progress*/
      16) {
        set_style(
          div2,
          "width",
          /*$progress*/
          ctx2[4] + "%"
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
    }
  };
}
function create_if_block_52(ctx) {
  let div;
  return {
    c() {
      div = element2("div");
      div.innerHTML = `Warning: high number of databases.<br/>
						Consider cleaning up unused databases.`;
      attr(div, "class", "system3-warning-text svelte-1n3w4sk");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block_44(ctx) {
  let div;
  return {
    c() {
      div = element2("div");
      div.innerHTML = `Critical: approaching IndexedDB database limit!<br/>
						Your browser may start deleting old databases soon.`;
      attr(div, "class", "system3-warning-text system3-critical svelte-1n3w4sk");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block_34(ctx) {
  let settingitemheading;
  let t2;
  let each_1_anchor;
  let current;
  settingitemheading = new SettingItemHeading_default({ props: { name: "Large Stores (>1MB)" } });
  let each_value = ensure_array_like(
    /*sortedRelayGroups*/
    ctx[2]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block8(get_each_context8(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      create_component(settingitemheading.$$.fragment);
      t2 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(settingitemheading, target, anchor);
      insert(target, t2, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*sortedRelayGroups, handleDelete*/
      2052) {
        each_value = ensure_array_like(
          /*sortedRelayGroups*/
          ctx2[2]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context8(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block8(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitemheading.$$.fragment, local);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(settingitemheading.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(each_1_anchor);
      }
      destroy_component(settingitemheading, detaching);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_default_slot30(ctx) {
  let div;
  let button;
  let t1;
  let mounted;
  let dispose;
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[17](
        /*store*/
        ctx[22]
      )
    );
  }
  return {
    c() {
      div = element2("div");
      button = element2("button");
      button.textContent = "Delete";
      t1 = space();
      attr(button, "class", "mod-warning");
      attr(button, "title", "Delete all data in this store");
      attr(div, "class", "system3-actions svelte-1n3w4sk");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append2(div, button);
      insert(target, t1, anchor);
      if (!mounted) {
        dispose = listen(button, "click", click_handler_1);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t1);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_each_block_14(ctx) {
  let settingitem;
  let current;
  settingitem = new SettingItem_default({
    props: {
      name: (
        /*store*/
        ctx[22].path || /*store*/
        ctx[22].slug
      ),
      description: "Size: " + /*store*/
      ctx[22].estimatedSizeMB + "MB, Items: " + /*store*/
      ctx[22].count,
      $$slots: { default: [create_default_slot30] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const settingitem_changes = {};
      if (dirty & /*sortedRelayGroups*/
      4)
        settingitem_changes.name = /*store*/
        ctx2[22].path || /*store*/
        ctx2[22].slug;
      if (dirty & /*sortedRelayGroups*/
      4)
        settingitem_changes.description = "Size: " + /*store*/
        ctx2[22].estimatedSizeMB + "MB, Items: " + /*store*/
        ctx2[22].count;
      if (dirty & /*$$scope, sortedRelayGroups*/
      33554436) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem, detaching);
    }
  };
}
function create_each_block8(ctx) {
  let settingitemheading;
  let t2;
  let each_1_anchor;
  let current;
  settingitemheading = new SettingItemHeading_default({
    props: {
      name: (
        /*relay*/
        ctx[18] === "local" ? "Tracked Documents" : `Relay: ${/*relay*/
        ctx[18]}`
      )
    }
  });
  let each_value_1 = ensure_array_like(
    /*relayStores*/
    ctx[19]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_14(get_each_context_14(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      create_component(settingitemheading.$$.fragment);
      t2 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(settingitemheading, target, anchor);
      insert(target, t2, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const settingitemheading_changes = {};
      if (dirty & /*sortedRelayGroups*/
      4)
        settingitemheading_changes.name = /*relay*/
        ctx2[18] === "local" ? "Tracked Documents" : `Relay: ${/*relay*/
        ctx2[18]}`;
      settingitemheading.$set(settingitemheading_changes);
      if (dirty & /*sortedRelayGroups, handleDelete*/
      2052) {
        each_value_1 = ensure_array_like(
          /*relayStores*/
          ctx2[19]
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_14(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_14(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitemheading.$$.fragment, local);
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(settingitemheading.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(each_1_anchor);
      }
      destroy_component(settingitemheading, detaching);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_fragment52(ctx) {
  let div0;
  let t1;
  let div9;
  let div8;
  let div4;
  let t5;
  let div7;
  let div6;
  let input;
  let t6;
  let div5;
  let t7;
  let current_block_type_index;
  let if_block;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block18, create_if_block_111, create_if_block_27];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$isLoading*/
      ctx2[3]
    )
      return 0;
    if (
      /*$error*/
      ctx2[5]
    )
      return 1;
    if (
      /*$stats*/
      ctx2[0]
    )
      return 2;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      div0 = element2("div");
      div0.textContent = "Relay database analysis";
      t1 = space();
      div9 = element2("div");
      div8 = element2("div");
      div4 = element2("div");
      div4.innerHTML = `<div class="setting-item-name">Search across vaults</div> <div class="setting-item-description"><div class="mod-warning">Warning: This is a dangerous setting. It allows you to delete relay
					databases from other vaults.</div></div>`;
      t5 = space();
      div7 = element2("div");
      div6 = element2("div");
      input = element2("input");
      t6 = space();
      div5 = element2("div");
      t7 = space();
      if (if_block)
        if_block.c();
      attr(div0, "class", "modal-title");
      attr(div4, "class", "setting-item-info");
      attr(input, "type", "checkbox");
      attr(input, "tabindex", "-1");
      input.checked = /*searchAcrossVaults*/
      ctx[1];
      attr(div5, "class", "checkbox-toggle");
      attr(div6, "role", "checkbox");
      attr(
        div6,
        "aria-checked",
        /*searchAcrossVaults*/
        ctx[1]
      );
      attr(div6, "tabindex", "0");
      attr(div6, "class", "checkbox-container system3-dangerous svelte-1n3w4sk");
      toggle_class(
        div6,
        "is-enabled",
        /*searchAcrossVaults*/
        ctx[1]
      );
      attr(div7, "class", "setting-item-control");
      attr(div8, "class", "setting-item");
      attr(div9, "class", "system3-indexeddb-analysis svelte-1n3w4sk");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      insert(target, t1, anchor);
      insert(target, div9, anchor);
      append2(div9, div8);
      append2(div8, div4);
      append2(div8, t5);
      append2(div8, div7);
      append2(div7, div6);
      append2(div6, input);
      append2(div6, t6);
      append2(div6, div5);
      append2(div9, t7);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div9, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            div6,
            "keypress",
            /*keypress_handler*/
            ctx[15]
          ),
          listen(
            div6,
            "click",
            /*click_handler*/
            ctx[16]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*searchAcrossVaults*/
      2) {
        input.checked = /*searchAcrossVaults*/
        ctx2[1];
      }
      if (!current || dirty & /*searchAcrossVaults*/
      2) {
        attr(
          div6,
          "aria-checked",
          /*searchAcrossVaults*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*searchAcrossVaults*/
      2) {
        toggle_class(
          div6,
          "is-enabled",
          /*searchAcrossVaults*/
          ctx2[1]
        );
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div9, null);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t1);
        detach(div9);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance51($$self, $$props, $$invalidate) {
  let groupedStores;
  let sortedRelayGroups;
  let $stats;
  let $isLoading;
  let $progress;
  let $error;
  var _a2;
  let { plugin } = $$props;
  const isLoading = writable(true);
  component_subscribe($$self, isLoading, (value) => $$invalidate(3, $isLoading = value));
  const progress = writable(0);
  component_subscribe($$self, progress, (value) => $$invalidate(4, $progress = value));
  const stats = writable(null);
  component_subscribe($$self, stats, (value) => $$invalidate(0, $stats = value));
  const error = writable(null);
  component_subscribe($$self, error, (value) => $$invalidate(5, $error = value));
  let searchAcrossVaults = false;
  function analyzeStores() {
    return __awaiter(this, void 0, void 0, function* () {
      isLoading.set(true);
      error.set(null);
      try {
        const results = yield analyzeIndexedDB({
          appId: plugin.appId,
          filterByAppId: !searchAcrossVaults,
          onProgress: (p) => progress.set(p)
        });
        stats.set(results);
      } catch (e2) {
        error.set(`Analysis failed: ${e2.message}`);
      } finally {
        isLoading.set(false);
      }
    });
  }
  function handleDelete(slug) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        yield deleteBySlug(slug);
        if ($stats) {
          set_store_value(stats, $stats.largeStores = $stats.largeStores.filter((store) => store.slug !== slug), $stats);
        }
      } catch (e2) {
        error.set(`Failed to delete ${slug}: ${e2.message}`);
      }
    });
  }
  onMount(() => {
    analyzeStores();
  });
  const keypress_handler2 = () => {
    $$invalidate(1, searchAcrossVaults = !searchAcrossVaults);
    analyzeStores();
  };
  const click_handler = () => {
    $$invalidate(1, searchAcrossVaults = !searchAcrossVaults);
    analyzeStores();
  };
  const click_handler_1 = (store) => handleDelete(store.slug);
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(12, plugin = $$props2.plugin);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$stats, _a*/
    8193) {
      $:
        $$invalidate(14, groupedStores = $$invalidate(13, _a2 = $stats === null || $stats === void 0 ? void 0 : $stats.largeStores.reduce(
          (groups, store) => {
            const relayGroup = store.relay || "local";
            if (!groups[relayGroup]) {
              groups[relayGroup] = [];
            }
            groups[relayGroup].push(store);
            return groups;
          },
          {}
        )) !== null && _a2 !== void 0 ? _a2 : {});
    }
    if ($$self.$$.dirty & /*groupedStores*/
    16384) {
      $:
        $$invalidate(2, sortedRelayGroups = Object.entries(groupedStores).sort(([a], [b]) => {
          if (a === "local")
            return -1;
          if (b === "local")
            return 1;
          return a.localeCompare(b);
        }));
    }
  };
  return [
    $stats,
    searchAcrossVaults,
    sortedRelayGroups,
    $isLoading,
    $progress,
    $error,
    isLoading,
    progress,
    stats,
    error,
    analyzeStores,
    handleDelete,
    plugin,
    _a2,
    groupedStores,
    keypress_handler2,
    click_handler,
    click_handler_1
  ];
}
var IndexedDBAnalysisModalContent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance51, create_fragment52, safe_not_equal, { plugin: 12 }, add_css20);
  }
};
var IndexedDBAnalysisModalContent_default = IndexedDBAnalysisModalContent;

// src/ui/IndexedDBAnalysisModal.ts
var IndexedDBAnalysisModal = class extends import_obsidian30.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    this.component = new IndexedDBAnalysisModalContent_default({
      target: contentEl,
      props: {
        plugin: this.plugin
      }
    });
  }
  onClose() {
    var _a2;
    const { contentEl } = this;
    contentEl.empty();
    (_a2 = this.component) == null ? void 0 : _a2.$destroy();
  }
};

// src/ui/SyncQueueModal.ts
var import_obsidian31 = require("obsidian");

// src/components/FolderSyncStatus.svelte
var { Boolean: Boolean_1 } = globals;
function add_css21(target) {
  append_styles(target, "svelte-18bqwhy", ".file-name.svelte-18bqwhy{display:flex;align-items:center;gap:6px;font-size:0.9rem;flex:1;min-width:0}.details-container.svelte-18bqwhy{margin-left:auto;text-align:right;padding-left:8px;padding-right:8px}.details.svelte-18bqwhy{font-size:0.75rem;color:var(--text-muted)}.error-message.svelte-18bqwhy{color:var(--text-error);margin-top:2px;text-align:right}.more-files.svelte-18bqwhy{font-size:0.8rem;color:var(--text-muted);text-align:center}button.mod-warning.svelte-18bqwhy{display:flex;align-items:center;gap:4px;background-color:var(--background-modifier-error);color:var(--text-error)}.mod-primary{color:var(--interactive-accent)}.mod-success{color:var(--interactive-success)}.mod-warning{color:var(--text-warning)}.show-more-link.svelte-18bqwhy{color:var(--text-accent);cursor:pointer;font-size:0.8rem}.show-more-link.svelte-18bqwhy:hover{text-decoration:underline}");
}
function get_each_context9(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[20] = list[i2];
  return child_ctx;
}
function get_each_context_15(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i2];
  return child_ctx;
}
function create_catch_block(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(groupDocuments(
    /*state*/
    ctx[19].documents
  ));
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block9(get_each_context9(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*groupConfigs, groupDocuments, folderState, showMore, formatRemainingCount, $visibleState, getStatusDisplay, retryOperation, getRelativeTime, $$scope*/
      8311) {
        each_value = ensure_array_like(groupDocuments(
          /*state*/
          ctx2[19].documents
        ));
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context9(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block9(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean_1);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block_35(ctx) {
  let t0;
  let t1_value = getRelativeTime(
    /*doc*/
    ctx[23].queueState.timestamp
  ) + "";
  let t1;
  return {
    c() {
      t0 = text2("\u2022 ");
      t1 = text2(t1_value);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$visibleState, folderState*/
      3 && t1_value !== (t1_value = getRelativeTime(
        /*doc*/
        ctx2[23].queueState.timestamp
      ) + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
    }
  };
}
function create_if_block_28(ctx) {
  let div;
  let t_value = (
    /*doc*/
    ctx[23].queueState.error + ""
  );
  let t2;
  return {
    c() {
      div = element2("div");
      t2 = text2(t_value);
      attr(div, "class", "error-message svelte-18bqwhy");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append2(div, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*$visibleState, folderState*/
      3 && t_value !== (t_value = /*doc*/
      ctx2[23].queueState.error + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block_112(ctx) {
  let button;
  let refreshcw;
  let t2;
  let current;
  let mounted;
  let dispose;
  refreshcw = new refresh_cw_default({
    props: {
      size: 14,
      class: "svg-icon lucide-refresh-cw"
    }
  });
  function click_handler() {
    return (
      /*click_handler*/
      ctx[10](
        /*doc*/
        ctx[23]
      )
    );
  }
  return {
    c() {
      button = element2("button");
      create_component(refreshcw.$$.fragment);
      t2 = text2("\n							Retry");
      attr(button, "class", "mod-warning svelte-18bqwhy");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      mount_component(refreshcw, button, null);
      append2(button, t2);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    i(local) {
      if (current)
        return;
      transition_in(refreshcw.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(refreshcw.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      destroy_component(refreshcw);
      mounted = false;
      dispose();
    }
  };
}
function fallback_block4(ctx) {
  var _a2, _b2, _c;
  let div;
  let span;
  let t0_value = (
    /*getStatusDisplay*/
    ctx[5](
      /*doc*/
      ctx[23]
    ).text + ""
  );
  let t0;
  let t1;
  let t2;
  let t3;
  let if_block2_anchor;
  let current;
  let if_block0 = (
    /*doc*/
    ((_a2 = ctx[23].queueState) == null ? void 0 : _a2.timestamp) && create_if_block_35(ctx)
  );
  let if_block1 = (
    /*doc*/
    ((_b2 = ctx[23].queueState) == null ? void 0 : _b2.error) && create_if_block_28(ctx)
  );
  let if_block2 = (
    /*doc*/
    ((_c = ctx[23].queueState) == null ? void 0 : _c.status) === "failed" && create_if_block_112(ctx)
  );
  return {
    c() {
      div = element2("div");
      span = element2("span");
      t0 = text2(t0_value);
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
      attr(span, "class", "details svelte-18bqwhy");
      attr(div, "class", "details-container svelte-18bqwhy");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append2(div, span);
      append2(span, t0);
      append2(span, t1);
      if (if_block0)
        if_block0.m(span, null);
      append2(span, t2);
      if (if_block1)
        if_block1.m(span, null);
      insert(target, t3, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a3, _b3, _c2;
      if ((!current || dirty & /*$visibleState, folderState*/
      3) && t0_value !== (t0_value = /*getStatusDisplay*/
      ctx2[5](
        /*doc*/
        ctx2[23]
      ).text + ""))
        set_data(t0, t0_value);
      if (
        /*doc*/
        (_a3 = ctx2[23].queueState) == null ? void 0 : _a3.timestamp
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_35(ctx2);
          if_block0.c();
          if_block0.m(span, t2);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*doc*/
        (_b3 = ctx2[23].queueState) == null ? void 0 : _b3.error
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_28(ctx2);
          if_block1.c();
          if_block1.m(span, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*doc*/
        ((_c2 = ctx2[23].queueState) == null ? void 0 : _c2.status) === "failed"
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*$visibleState, folderState*/
          3) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_112(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t3);
        detach(if_block2_anchor);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d(detaching);
    }
  };
}
function create_default_slot31(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block4(ctx);
  return {
    c() {
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
    },
    m(target, anchor) {
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              null
            ),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*$visibleState, folderState*/
        3)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
    }
  };
}
function create_name_slot_13(ctx) {
  let span1;
  let switch_instance;
  let t0;
  let span0;
  let t1_value = (
    /*doc*/
    ctx[23].path.split("/").pop() + ""
  );
  let t1;
  let current;
  var switch_value = (
    /*getStatusDisplay*/
    ctx[5](
      /*doc*/
      ctx[23]
    ).icon
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        size: 16,
        class: "svg-icon " + /*getStatusDisplay*/
        ctx2[5](
          /*doc*/
          ctx2[23]
        ).iconClass
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      span1 = element2("span");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t0 = space();
      span0 = element2("span");
      t1 = text2(t1_value);
      attr(span1, "slot", "name");
      attr(span1, "class", "file-name svelte-18bqwhy");
    },
    m(target, anchor) {
      insert(target, span1, anchor);
      if (switch_instance)
        mount_component(switch_instance, span1, null);
      append2(span1, t0);
      append2(span1, span0);
      append2(span0, t1);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*$visibleState, folderState*/
      3 && switch_value !== (switch_value = /*getStatusDisplay*/
      ctx2[5](
        /*doc*/
        ctx2[23]
      ).icon)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, span1, t0);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*$visibleState, folderState*/
        3)
          switch_instance_changes.class = "svg-icon " + /*getStatusDisplay*/
          ctx2[5](
            /*doc*/
            ctx2[23]
          ).iconClass;
        switch_instance.$set(switch_instance_changes);
      }
      if ((!current || dirty & /*$visibleState, folderState*/
      3) && t1_value !== (t1_value = /*doc*/
      ctx2[23].path.split("/").pop() + ""))
        set_data(t1, t1_value);
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span1);
      }
      if (switch_instance)
        destroy_component(switch_instance);
    }
  };
}
function create_each_block_15(ctx) {
  let slimsettingitem;
  let current;
  slimsettingitem = new SlimSettingItem_default({
    props: {
      $$slots: {
        name: [create_name_slot_13],
        default: [create_default_slot31]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(slimsettingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(slimsettingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const slimsettingitem_changes = {};
      if (dirty & /*$$scope, $visibleState, folderState*/
      8195) {
        slimsettingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      slimsettingitem.$set(slimsettingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(slimsettingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(slimsettingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(slimsettingitem, detaching);
    }
  };
}
function create_if_block19(ctx) {
  let slimsettingitem;
  let current;
  slimsettingitem = new SlimSettingItem_default({
    props: {
      $$slots: { name: [create_name_slot5] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(slimsettingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(slimsettingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const slimsettingitem_changes = {};
      if (dirty & /*$$scope, folderState, $visibleState*/
      8195) {
        slimsettingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      slimsettingitem.$set(slimsettingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(slimsettingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(slimsettingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(slimsettingitem, detaching);
    }
  };
}
function create_name_slot5(ctx) {
  let span1;
  let t0;
  let t1_value = formatRemainingCount(
    /*$visibleState*/
    ctx[1](
      /*group*/
      ctx[20]
    ).remainingCount
  ) + "";
  let t1;
  let t2;
  let t3_value = (
    /*group*/
    ctx[20].title.toLowerCase() + ""
  );
  let t3;
  let t4;
  let span0;
  let t5;
  let span0_aria_label_value;
  let t6;
  let mounted;
  let dispose;
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[11](
        /*group*/
        ctx[20]
      )
    );
  }
  function keydown_handler(...args3) {
    return (
      /*keydown_handler*/
      ctx[12](
        /*group*/
        ctx[20],
        ...args3
      )
    );
  }
  return {
    c() {
      var _a2;
      span1 = element2("span");
      t0 = text2("...and ");
      t1 = text2(t1_value);
      t2 = text2(" more\n					");
      t3 = text2(t3_value);
      t4 = space();
      span0 = element2("span");
      t5 = text2("(show more)");
      t6 = space();
      attr(span0, "class", "show-more-link svelte-18bqwhy");
      attr(span0, "role", "button");
      attr(span0, "tabindex", "0");
      attr(span0, "aria-label", span0_aria_label_value = `Show ${/*groupConfigs*/
      ((_a2 = ctx[2][
        /*group*/
        ctx[20].title
      ]) == null ? void 0 : _a2.incrementCount) || /*groupConfigs*/
      ctx[2].default.incrementCount} more ${/*group*/
      ctx[20].title.toLowerCase()}`);
      attr(span1, "slot", "name");
      attr(span1, "class", "more-files svelte-18bqwhy");
    },
    m(target, anchor) {
      insert(target, span1, anchor);
      append2(span1, t0);
      append2(span1, t1);
      append2(span1, t2);
      append2(span1, t3);
      append2(span1, t4);
      append2(span1, span0);
      append2(span0, t5);
      append2(span1, t6);
      if (!mounted) {
        dispose = [
          listen(span0, "click", click_handler_1),
          listen(span0, "keydown", keydown_handler)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      var _a2;
      ctx = new_ctx;
      if (dirty & /*$visibleState, folderState*/
      3 && t1_value !== (t1_value = formatRemainingCount(
        /*$visibleState*/
        ctx[1](
          /*group*/
          ctx[20]
        ).remainingCount
      ) + ""))
        set_data(t1, t1_value);
      if (dirty & /*folderState*/
      1 && t3_value !== (t3_value = /*group*/
      ctx[20].title.toLowerCase() + ""))
        set_data(t3, t3_value);
      if (dirty & /*folderState*/
      1 && span0_aria_label_value !== (span0_aria_label_value = `Show ${/*groupConfigs*/
      ((_a2 = ctx[2][
        /*group*/
        ctx[20].title
      ]) == null ? void 0 : _a2.incrementCount) || /*groupConfigs*/
      ctx[2].default.incrementCount} more ${/*group*/
      ctx[20].title.toLowerCase()}`)) {
        attr(span0, "aria-label", span0_aria_label_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_each_block9(ctx) {
  let settingitemheading;
  let t0;
  let t1;
  let show_if = (
    /*$visibleState*/
    ctx[1](
      /*group*/
      ctx[20]
    ).remainingCount > 0
  );
  let if_block_anchor;
  let current;
  settingitemheading = new SettingItemHeading_default({ props: { name: (
    /*group*/
    ctx[20].title
  ) } });
  let each_value_1 = ensure_array_like(
    /*$visibleState*/
    ctx[1](
      /*group*/
      ctx[20]
    ).visibleDocs
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_15(get_each_context_15(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  let if_block = show_if && create_if_block19(ctx);
  return {
    c() {
      create_component(settingitemheading.$$.fragment);
      t0 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t1 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(settingitemheading, target, anchor);
      insert(target, t0, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, t1, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const settingitemheading_changes = {};
      if (dirty & /*folderState*/
      1)
        settingitemheading_changes.name = /*group*/
        ctx2[20].title;
      settingitemheading.$set(settingitemheading_changes);
      if (dirty & /*$visibleState, groupDocuments, folderState, getStatusDisplay, retryOperation, getRelativeTime, $$scope*/
      8291) {
        each_value_1 = ensure_array_like(
          /*$visibleState*/
          ctx2[1](
            /*group*/
            ctx2[20]
          ).visibleDocs
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_15(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_15(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(t1.parentNode, t1);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (dirty & /*$visibleState, folderState*/
      3)
        show_if = /*$visibleState*/
        ctx2[1](
          /*group*/
          ctx2[20]
        ).remainingCount > 0;
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$visibleState, folderState*/
          3) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block19(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitemheading.$$.fragment, local);
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(settingitemheading.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean_1);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(if_block_anchor);
      }
      destroy_component(settingitemheading, detaching);
      destroy_each(each_blocks, detaching);
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_pending_block(ctx) {
  let div;
  return {
    c() {
      div = element2("div");
      div.textContent = "Loading...";
      attr(div, "class", "loading");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_fragment53(ctx) {
  let await_block_anchor;
  let promise;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block,
    then: create_then_block,
    catch: create_catch_block,
    value: 19,
    blocks: [, , ,]
  };
  handle_promise(promise = /*folderState*/
  ctx[0], info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      info.ctx = ctx;
      if (dirty & /*folderState*/
      1 && promise !== (promise = /*folderState*/
      ctx[0]) && handle_promise(promise, info)) {
      } else {
        update_await_block_branch(info, ctx, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(await_block_anchor);
      }
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function formatRemainingCount(count2) {
  return new Intl.NumberFormat().format(count2);
}
function getRelativeTime(timestamp) {
  const date = new Date(timestamp);
  const now2 = new Date();
  const diffInMs = now2.getTime() - date.getTime();
  const diffInMinutes = Math.floor(diffInMs / (1e3 * 60));
  if (diffInMinutes < 1)
    return "just now";
  if (diffInMinutes === 1)
    return "1 minute ago";
  if (diffInMinutes < 60)
    return `${diffInMinutes} minutes ago`;
  const diffInHours = Math.floor(diffInMinutes / 60);
  if (diffInHours === 1)
    return "1 hour ago";
  if (diffInHours < 24)
    return `${diffInHours} hours ago`;
  const diffInDays = Math.floor(diffInHours / 24);
  if (diffInDays === 1)
    return "yesterday";
  return `${diffInDays} days ago`;
}
function groupDocuments(documents) {
  const active = documents.filter((d) => {
    var _a2;
    return ((_a2 = d.queueState) === null || _a2 === void 0 ? void 0 : _a2.status) === "running";
  });
  const stuck = documents.filter((d) => {
    var _a2;
    return ((_a2 = d.queueState) === null || _a2 === void 0 ? void 0 : _a2.status) === "failed";
  });
  const queued = documents.filter((d) => {
    var _a2;
    return ((_a2 = d.queueState) === null || _a2 === void 0 ? void 0 : _a2.status) === "pending";
  });
  const completed = documents.filter((d) => {
    var _a2;
    return ((_a2 = d.queueState) === null || _a2 === void 0 ? void 0 : _a2.status) === "completed";
  });
  return [
    active.length > 0 && { title: "Active Files", documents: active },
    stuck.length > 0 && { title: "Stuck Files", documents: stuck },
    queued.length > 0 && { title: "Queued Files", documents: queued },
    completed.length > 0 && {
      title: "Completed Files",
      documents: completed
    }
  ].filter(Boolean);
}
function instance52($$self, $$props, $$invalidate) {
  let activeSyncs;
  let activeDownloads;
  let syncLog;
  let folderState;
  let $visibleState;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { folder } = $$props;
  let { backgroundSync } = $$props;
  const groupConfigs = {
    "Active Files": {
      initialCount: Infinity,
      incrementCount: 100
    },
    "Stuck Files": {
      initialCount: Infinity,
      incrementCount: 100
    },
    "Queued Files": { initialCount: 10, incrementCount: 100 },
    "Completed Files": { initialCount: 5, incrementCount: 100 },
    default: {
      initialCount: Infinity,
      incrementCount: 100
    }
  };
  const expandedCounts = writable({});
  const visibleState = derived(expandedCounts, ($expandedCounts) => (group) => {
    const config = groupConfigs[group.title] || groupConfigs.default;
    const visibleCount = $expandedCounts[group.title] || config.initialCount;
    const visibleDocs = group.documents.slice(0, visibleCount);
    const remainingCount = group.documents.length - visibleCount;
    return {
      visibleCount,
      visibleDocs,
      remainingCount
    };
  });
  component_subscribe($$self, visibleState, (value) => $$invalidate(1, $visibleState = value));
  function showMore(groupTitle) {
    const config = groupConfigs[groupTitle] || groupConfigs.default;
    expandedCounts.update((counts) => Object.assign(Object.assign({}, counts), {
      [groupTitle]: (counts[groupTitle] || config.initialCount) + config.incrementCount
    }));
  }
  function getFolderState(folder2) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a2;
      const documents = [];
      const docs = Array.from(folder2.docs.values());
      for (const doc2 of docs) {
        const origin = yield doc2.getOrigin();
        const serverSynced = yield doc2.getServerSynced();
        const state = {
          guid: doc2.guid,
          path: folder2.getPath(doc2.path),
          doc: doc2,
          origin: origin || "unknown",
          serverSynced
        };
        const syncItem = Array.from(activeSyncs).find((i2) => i2.guid === doc2.guid);
        const downloadItem = Array.from(activeDownloads).find((i2) => i2.guid === doc2.guid);
        const logItem = syncLog.find((i2) => i2.guid === doc2.guid);
        if (syncItem || downloadItem || logItem) {
          const item = syncItem || downloadItem || logItem;
          state.queueState = {
            status: item.status,
            type: "type" in item ? item.type : "sync",
            error: "error" in item ? item.error : void 0,
            timestamp: "timestamp" in item ? item.timestamp : Date.now()
          };
        } else if (origin === "local" && !serverSynced) {
          state.queueState = {
            status: "pending",
            type: "sync",
            timestamp: Date.now()
          };
        } else if (serverSynced) {
          state.queueState = {
            status: "completed",
            type: "sync",
            timestamp: Date.now()
          };
        } else {
          state.queueState = {
            status: "pending",
            type: "sync",
            timestamp: Date.now()
          };
        }
        documents.push(state);
      }
      return {
        folder: folder2,
        documents,
        progress: ((_a2 = backgroundSync.getGroupProgress(folder2)) === null || _a2 === void 0 ? void 0 : _a2.percent) || 0
      };
    });
  }
  function getStatusDisplay(item) {
    const { origin, serverSynced, queueState } = item;
    const status = (queueState === null || queueState === void 0 ? void 0 : queueState.status) || "completed";
    const type = (queueState === null || queueState === void 0 ? void 0 : queueState.type) || "sync";
    if (origin === "remote" && !serverSynced && status === "running" && type === "download") {
      return {
        text: "Downloading",
        description: "Initial acquisition",
        icon: download_default,
        iconClass: "mod-primary"
      };
    }
    if (origin === "remote" && !serverSynced && status === "pending" && type === "download") {
      return {
        text: "Queued for Download",
        description: "Waiting to download",
        icon: clock_default,
        iconClass: ""
      };
    }
    if (origin === "remote" && !serverSynced && status === "failed" && type === "download") {
      return {
        text: "Download stuck",
        description: "Needs retry",
        icon: triangle_alert_default,
        iconClass: "mod-warning"
      };
    }
    if (origin === "local" && !serverSynced && status === "running" && type === "sync") {
      return {
        text: "Uploading",
        description: "First-time upload",
        icon: upload_default,
        iconClass: "mod-primary"
      };
    }
    if (origin === "local" && !serverSynced && status === "pending" && type === "sync") {
      return {
        text: "Queued for Upload",
        description: "Waiting to upload",
        icon: clock_default,
        iconClass: ""
      };
    }
    if (origin === "local" && !serverSynced && status === "failed" && type === "sync") {
      return {
        text: "Upload stuck",
        description: "Needs retry",
        icon: triangle_alert_default,
        iconClass: "mod-warning"
      };
    }
    if (serverSynced && status === "running" && type === "sync") {
      return {
        text: "Syncing",
        description: "Collaborative update",
        icon: arrow_up_down_default,
        iconClass: "mod-primary"
      };
    }
    if (serverSynced && status === "pending" && type === "sync") {
      return {
        text: "Queued for Sync",
        description: "Waiting to sync",
        icon: clock_default,
        iconClass: ""
      };
    }
    if (serverSynced && status === "failed" && type === "sync") {
      return {
        text: "Sync stuck",
        description: "Needs retry",
        icon: triangle_alert_default,
        iconClass: "mod-warning"
      };
    }
    if (serverSynced && status === "completed") {
      return {
        text: "Complete",
        description: "Fully synchronized",
        icon: circle_check_big_default,
        iconClass: "mod-success"
      };
    }
    return {
      text: "Unknown",
      description: "Status unknown",
      icon: info_default,
      iconClass: ""
    };
  }
  function retryOperation(doc2) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a2, _b2;
      const logEntry = {
        id: doc2.guid,
        guid: doc2.guid,
        path: doc2.path,
        timestamp: ((_a2 = doc2.queueState) === null || _a2 === void 0 ? void 0 : _a2.timestamp) || Date.now(),
        type: ((_b2 = doc2.queueState) === null || _b2 === void 0 ? void 0 : _b2.type) || "sync",
        status: "failed",
        sharedFolderGuid: doc2.doc.sharedFolder.guid
      };
      yield backgroundSync.retryLogItem(logEntry);
    });
  }
  const click_handler = (doc2) => retryOperation(doc2);
  const click_handler_1 = (group) => {
    showMore(group.title);
  };
  const keydown_handler = (group, e2) => e2.key === "Enter" && showMore(group.title);
  $$self.$$set = ($$props2) => {
    if ("folder" in $$props2)
      $$invalidate(7, folder = $$props2.folder);
    if ("backgroundSync" in $$props2)
      $$invalidate(8, backgroundSync = $$props2.backgroundSync);
    if ("$$scope" in $$props2)
      $$invalidate(13, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*backgroundSync*/
    256) {
      $:
        activeSyncs = new Set(backgroundSync.activeSync.items());
    }
    if ($$self.$$.dirty & /*backgroundSync*/
    256) {
      $:
        activeDownloads = new Set(backgroundSync.activeDownloads.items());
    }
    if ($$self.$$.dirty & /*backgroundSync*/
    256) {
      $:
        syncLog = backgroundSync.getSyncLog();
    }
    if ($$self.$$.dirty & /*folder*/
    128) {
      $:
        $$invalidate(0, folderState = getFolderState(folder));
    }
  };
  return [
    folderState,
    $visibleState,
    groupConfigs,
    visibleState,
    showMore,
    getStatusDisplay,
    retryOperation,
    folder,
    backgroundSync,
    slots,
    click_handler,
    click_handler_1,
    keydown_handler,
    $$scope
  ];
}
var FolderSyncStatus = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance52, create_fragment53, safe_not_equal, { folder: 7, backgroundSync: 8 }, add_css21);
  }
};
var FolderSyncStatus_default = FolderSyncStatus;

// src/components/SyncQueueModalContent.svelte
var { Map: Map_1 } = globals;
function add_css22(target) {
  append_styles(target, "svelte-ztgdsf", ".folder-header.svelte-ztgdsf{display:flex;align-items:center;cursor:pointer;background:none;border:none;padding:0;width:100%;text-align:left;color:inherit;font:inherit}.arrow.svelte-ztgdsf{margin-right:8px;font-size:0.8em;transition:transform 0.15s ease}.arrow.is-expanded.svelte-ztgdsf{transform:rotate(90deg)}.sync-stats.svelte-ztgdsf{margin-left:8px;display:flex;gap:4px}.tag.svelte-ztgdsf{font-size:0.7em;padding:2px 6px;border-radius:4px;background-color:var(--background-modifier-border);color:var(--text-muted)}.tag.mod-success.svelte-ztgdsf{background-color:var(--interactive-success);color:var(--text-on-accent)}.tag.mod-warning.svelte-ztgdsf{background-color:var(--text-warning);color:var(--text-on-accent)}.progress-container.svelte-ztgdsf{display:flex;align-items:center;margin-top:4px;width:100%}.progress-bar.svelte-ztgdsf{flex:1;height:6px;background-color:var(--background-modifier-border);border-radius:3px;overflow:hidden;margin-right:8px}.progress-value.svelte-ztgdsf{height:100%;background-color:var(--interactive-accent);border-radius:3px}.progress-text.svelte-ztgdsf{font-size:0.75rem;color:var(--text-muted)}");
}
function get_each_context10(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[25] = list[i2];
  const constants_0 = (
    /*folderStatuses*/
    child_ctx[4].get(
      /*folder*/
      child_ctx[25].guid
    )
  );
  child_ctx[26] = constants_0;
  return child_ctx;
}
function create_if_block_132(ctx) {
  let settingitemheading;
  let current;
  settingitemheading = new SettingItemHeading_default({ props: { name: "Sync Status" } });
  return {
    c() {
      create_component(settingitemheading.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitemheading, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitemheading.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitemheading.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitemheading, detaching);
    }
  };
}
function create_if_block_10(ctx) {
  let settingitem;
  let current;
  settingitem = new SettingItem_default({
    props: {
      name: (
        /*isSyncing*/
        ctx[11] ? "Sync in Progress" : (
          /*hasPendingSync*/
          ctx[10] ? "Queued Files" : "Sync Complete"
        )
      ),
      description: `${/*activeFilesCount*/
      ctx[2]} active \u2022 ${/*stuckFilesCount*/
      ctx[7]} stuck \u2022 ${/*queuedFilesCount*/
      ctx[3]} queued \u2022 ${/*completedFilesCount*/
      ctx[8]} complete`,
      $$slots: { default: [create_default_slot_45] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const settingitem_changes = {};
      if (dirty & /*isSyncing, hasPendingSync*/
      3072)
        settingitem_changes.name = /*isSyncing*/
        ctx2[11] ? "Sync in Progress" : (
          /*hasPendingSync*/
          ctx2[10] ? "Queued Files" : "Sync Complete"
        );
      if (dirty & /*activeFilesCount, stuckFilesCount, queuedFilesCount, completedFilesCount*/
      396)
        settingitem_changes.description = `${/*activeFilesCount*/
        ctx2[2]} active \u2022 ${/*stuckFilesCount*/
        ctx2[7]} stuck \u2022 ${/*queuedFilesCount*/
        ctx2[3]} queued \u2022 ${/*completedFilesCount*/
        ctx2[8]} complete`;
      if (dirty & /*$$scope, isPaused, isSyncing, hasPendingSync*/
      536874496) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem, detaching);
    }
  };
}
function create_if_block_11(ctx) {
  let button;
  let current_block_type_index;
  let if_block;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_122, create_else_block_13];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*isPaused*/
      ctx2[9]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      button = element2("button");
      if_block.c();
      attr(button, "class", "mod-cta");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if_blocks[current_block_type_index].m(button, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*togglePause*/
          ctx[16]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
        }
        transition_in(if_block, 1);
        if_block.m(button, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if_blocks[current_block_type_index].d();
      mounted = false;
      dispose();
    }
  };
}
function create_else_block_13(ctx) {
  let pause;
  let t2;
  let current;
  pause = new pause_default({
    props: {
      size: 16,
      class: "svg-icon lucide-pause",
      style: "margin-right: 8px;"
    }
  });
  return {
    c() {
      create_component(pause.$$.fragment);
      t2 = text2("\n						Pause");
    },
    m(target, anchor) {
      mount_component(pause, target, anchor);
      insert(target, t2, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(pause.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pause.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(pause, detaching);
    }
  };
}
function create_if_block_122(ctx) {
  let play;
  let t2;
  let current;
  play = new play_default({
    props: {
      size: 16,
      class: "svg-icon lucide-play",
      style: "margin-right: 8px;"
    }
  });
  return {
    c() {
      create_component(play.$$.fragment);
      t2 = text2("\n						Resume");
    },
    m(target, anchor) {
      mount_component(play, target, anchor);
      insert(target, t2, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(play.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(play.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(play, detaching);
    }
  };
}
function create_default_slot_45(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*isSyncing*/
    (ctx[11] || /*hasPendingSync*/
    ctx[10]) && create_if_block_11(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*isSyncing*/
        ctx2[11] || /*hasPendingSync*/
        ctx2[10]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*isSyncing, hasPendingSync*/
          3072) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_11(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_else_block13(ctx) {
  let each_blocks = [];
  let each_1_lookup = new Map_1();
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*folders*/
    ctx[6]
  );
  const get_key = (ctx2) => (
    /*folder*/
    ctx2[25].guid
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context10(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block10(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*folders, backgroundSync, expandedFolders, toggleFolder, folderStatuses*/
      32851) {
        each_value = ensure_array_like(
          /*folders*/
          ctx2[6]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block10, each_1_anchor, get_each_context10);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
}
function create_if_block20(ctx) {
  let settingitemheading;
  let t2;
  let foldersyncstatus;
  let current;
  settingitemheading = new SettingItemHeading_default({
    props: {
      $$slots: {
        name: [create_name_slot6],
        default: [create_default_slot_19]
      },
      $$scope: { ctx }
    }
  });
  foldersyncstatus = new FolderSyncStatus_default({
    props: {
      folder: (
        /*focusedFolder*/
        ctx[5]
      ),
      backgroundSync: (
        /*backgroundSync*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      create_component(settingitemheading.$$.fragment);
      t2 = space();
      create_component(foldersyncstatus.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitemheading, target, anchor);
      insert(target, t2, anchor);
      mount_component(foldersyncstatus, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const settingitemheading_changes = {};
      if (dirty & /*$$scope, focusedFolder, focusedFolderStatus*/
      536875040) {
        settingitemheading_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitemheading.$set(settingitemheading_changes);
      const foldersyncstatus_changes = {};
      if (dirty & /*focusedFolder*/
      32)
        foldersyncstatus_changes.folder = /*focusedFolder*/
        ctx2[5];
      if (dirty & /*backgroundSync*/
      1)
        foldersyncstatus_changes.backgroundSync = /*backgroundSync*/
        ctx2[0];
      foldersyncstatus.$set(foldersyncstatus_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitemheading.$$.fragment, local);
      transition_in(foldersyncstatus.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitemheading.$$.fragment, local);
      transition_out(foldersyncstatus.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(settingitemheading, detaching);
      destroy_component(foldersyncstatus, detaching);
    }
  };
}
function create_if_block_9(ctx) {
  let div2;
  let div1;
  let div0;
  let t0;
  let span;
  let t1_value = (
    /*status*/
    ctx[26].progress + ""
  );
  let t1;
  let t2;
  return {
    c() {
      div2 = element2("div");
      div1 = element2("div");
      div0 = element2("div");
      t0 = space();
      span = element2("span");
      t1 = text2(t1_value);
      t2 = text2("%");
      attr(div0, "class", "progress-value svelte-ztgdsf");
      set_style(
        div0,
        "width",
        /*status*/
        ctx[26].progress + "%"
      );
      attr(div1, "class", "progress-bar svelte-ztgdsf");
      attr(span, "class", "progress-text svelte-ztgdsf");
      attr(div2, "class", "progress-container svelte-ztgdsf");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append2(div2, div1);
      append2(div1, div0);
      append2(div2, t0);
      append2(div2, span);
      append2(span, t1);
      append2(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*folderStatuses, folders*/
      80) {
        set_style(
          div0,
          "width",
          /*status*/
          ctx2[26].progress + "%"
        );
      }
      if (dirty & /*folderStatuses, folders*/
      80 && t1_value !== (t1_value = /*status*/
      ctx2[26].progress + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
    }
  };
}
function create_default_slot_35(ctx) {
  let if_block_anchor;
  let if_block = (
    /*status*/
    ctx[26] && /*status*/
    (ctx[26].running > 0 || /*status*/
    ctx[26].failed > 0) && create_if_block_9(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (
        /*status*/
        ctx2[26] && /*status*/
        (ctx2[26].running > 0 || /*status*/
        ctx2[26].failed > 0)
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_9(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_if_block_82(ctx) {
  let span;
  let t0_value = (
    /*status*/
    ctx[26].running + ""
  );
  let t0;
  let t1;
  return {
    c() {
      span = element2("span");
      t0 = text2(t0_value);
      t1 = text2(" active");
      attr(span, "class", "tag mod-success svelte-ztgdsf");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append2(span, t0);
      append2(span, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*folderStatuses, folders*/
      80 && t0_value !== (t0_value = /*status*/
      ctx2[26].running + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_72(ctx) {
  let span;
  let t0_value = (
    /*status*/
    ctx[26].failed + ""
  );
  let t0;
  let t1;
  return {
    c() {
      span = element2("span");
      t0 = text2(t0_value);
      t1 = text2(" stuck");
      attr(span, "class", "tag mod-warning svelte-ztgdsf");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append2(span, t0);
      append2(span, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*folderStatuses, folders*/
      80 && t0_value !== (t0_value = /*status*/
      ctx2[26].failed + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_62(ctx) {
  let span;
  let t0_value = (
    /*status*/
    ctx[26].pending + ""
  );
  let t0;
  let t1;
  return {
    c() {
      span = element2("span");
      t0 = text2(t0_value);
      t1 = text2(" queued");
      attr(span, "class", "tag svelte-ztgdsf");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append2(span, t0);
      append2(span, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*folderStatuses, folders*/
      80 && t0_value !== (t0_value = /*status*/
      ctx2[26].pending + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_default_slot_25(ctx) {
  var _a2, _b2, _c;
  let div;
  let span0;
  let t0;
  let span0_class_value;
  let t1;
  let t2_value = (
    /*folder*/
    ctx[25].name + ""
  );
  let t2;
  let t3;
  let span1;
  let t4;
  let t5;
  let div_aria_expanded_value;
  let mounted;
  let dispose;
  let if_block0 = (
    /*status*/
    ((_a2 = ctx[26]) == null ? void 0 : _a2.running) > 0 && create_if_block_82(ctx)
  );
  let if_block1 = (
    /*status*/
    ((_b2 = ctx[26]) == null ? void 0 : _b2.failed) > 0 && create_if_block_72(ctx)
  );
  let if_block2 = (
    /*status*/
    ((_c = ctx[26]) == null ? void 0 : _c.pending) > 0 && create_if_block_62(ctx)
  );
  function click_handler() {
    return (
      /*click_handler*/
      ctx[22](
        /*folder*/
        ctx[25]
      )
    );
  }
  function keydown_handler(...args3) {
    return (
      /*keydown_handler*/
      ctx[23](
        /*folder*/
        ctx[25],
        ...args3
      )
    );
  }
  return {
    c() {
      div = element2("div");
      span0 = element2("span");
      t0 = text2("\u25B6");
      t1 = space();
      t2 = text2(t2_value);
      t3 = space();
      span1 = element2("span");
      if (if_block0)
        if_block0.c();
      t4 = space();
      if (if_block1)
        if_block1.c();
      t5 = space();
      if (if_block2)
        if_block2.c();
      attr(span0, "class", span0_class_value = "arrow " + /*expandedFolders*/
      (ctx[1][
        /*folder*/
        ctx[25].guid
      ] ? "is-expanded" : "") + " svelte-ztgdsf");
      attr(span1, "class", "sync-stats svelte-ztgdsf");
      attr(div, "class", "folder-header svelte-ztgdsf");
      attr(div, "role", "button");
      attr(div, "tabindex", "0");
      attr(div, "aria-expanded", div_aria_expanded_value = !!/*expandedFolders*/
      ctx[1][
        /*folder*/
        ctx[25].guid
      ]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append2(div, span0);
      append2(span0, t0);
      append2(div, t1);
      append2(div, t2);
      append2(div, t3);
      append2(div, span1);
      if (if_block0)
        if_block0.m(span1, null);
      append2(span1, t4);
      if (if_block1)
        if_block1.m(span1, null);
      append2(span1, t5);
      if (if_block2)
        if_block2.m(span1, null);
      if (!mounted) {
        dispose = [
          listen(div, "click", click_handler),
          listen(div, "keydown", keydown_handler)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      var _a3, _b3, _c2;
      ctx = new_ctx;
      if (dirty & /*expandedFolders, folders*/
      66 && span0_class_value !== (span0_class_value = "arrow " + /*expandedFolders*/
      (ctx[1][
        /*folder*/
        ctx[25].guid
      ] ? "is-expanded" : "") + " svelte-ztgdsf")) {
        attr(span0, "class", span0_class_value);
      }
      if (dirty & /*folders*/
      64 && t2_value !== (t2_value = /*folder*/
      ctx[25].name + ""))
        set_data(t2, t2_value);
      if (
        /*status*/
        ((_a3 = ctx[26]) == null ? void 0 : _a3.running) > 0
      ) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0 = create_if_block_82(ctx);
          if_block0.c();
          if_block0.m(span1, t4);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*status*/
        ((_b3 = ctx[26]) == null ? void 0 : _b3.failed) > 0
      ) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if_block1 = create_if_block_72(ctx);
          if_block1.c();
          if_block1.m(span1, t5);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*status*/
        ((_c2 = ctx[26]) == null ? void 0 : _c2.pending) > 0
      ) {
        if (if_block2) {
          if_block2.p(ctx, dirty);
        } else {
          if_block2 = create_if_block_62(ctx);
          if_block2.c();
          if_block2.m(span1, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (dirty & /*expandedFolders, folders*/
      66 && div_aria_expanded_value !== (div_aria_expanded_value = !!/*expandedFolders*/
      ctx[1][
        /*folder*/
        ctx[25].guid
      ])) {
        attr(div, "aria-expanded", div_aria_expanded_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_name_slot_14(ctx) {
  let folder_1;
  let current;
  folder_1 = new Folder_default({
    props: {
      folder: (
        /*folder*/
        ctx[25]
      ),
      $$slots: { default: [create_default_slot_25] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(folder_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(folder_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const folder_1_changes = {};
      if (dirty & /*folders*/
      64)
        folder_1_changes.folder = /*folder*/
        ctx2[25];
      if (dirty & /*$$scope, expandedFolders, folders, folderStatuses*/
      536870994) {
        folder_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      folder_1.$set(folder_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(folder_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(folder_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(folder_1, detaching);
    }
  };
}
function create_if_block_53(ctx) {
  let foldersyncstatus;
  let current;
  foldersyncstatus = new FolderSyncStatus_default({
    props: {
      folder: (
        /*folder*/
        ctx[25]
      ),
      backgroundSync: (
        /*backgroundSync*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      create_component(foldersyncstatus.$$.fragment);
    },
    m(target, anchor) {
      mount_component(foldersyncstatus, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const foldersyncstatus_changes = {};
      if (dirty & /*folders*/
      64)
        foldersyncstatus_changes.folder = /*folder*/
        ctx2[25];
      if (dirty & /*backgroundSync*/
      1)
        foldersyncstatus_changes.backgroundSync = /*backgroundSync*/
        ctx2[0];
      foldersyncstatus.$set(foldersyncstatus_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(foldersyncstatus.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(foldersyncstatus.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(foldersyncstatus, detaching);
    }
  };
}
function create_each_block10(key_1, ctx) {
  let first;
  let settingitemheading;
  let t2;
  let if_block_anchor;
  let current;
  settingitemheading = new SettingItemHeading_default({
    props: {
      $$slots: {
        name: [create_name_slot_14],
        default: [create_default_slot_35]
      },
      $$scope: { ctx }
    }
  });
  let if_block = (
    /*expandedFolders*/
    ctx[1][
      /*folder*/
      ctx[25].guid
    ] && create_if_block_53(ctx)
  );
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(settingitemheading.$$.fragment);
      t2 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(settingitemheading, target, anchor);
      insert(target, t2, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const settingitemheading_changes = {};
      if (dirty & /*$$scope, folders, expandedFolders, folderStatuses*/
      536870994) {
        settingitemheading_changes.$$scope = { dirty, ctx };
      }
      settingitemheading.$set(settingitemheading_changes);
      if (
        /*expandedFolders*/
        ctx[1][
          /*folder*/
          ctx[25].guid
        ]
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & /*expandedFolders, folders*/
          66) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_53(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitemheading.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(settingitemheading.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
        detach(t2);
        detach(if_block_anchor);
      }
      destroy_component(settingitemheading, detaching);
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_if_block_45(ctx) {
  let div2;
  let div1;
  let div0;
  let t0;
  let span;
  let t1_value = (
    /*focusedFolderStatus*/
    ctx[12].progress + ""
  );
  let t1;
  let t2;
  return {
    c() {
      div2 = element2("div");
      div1 = element2("div");
      div0 = element2("div");
      t0 = space();
      span = element2("span");
      t1 = text2(t1_value);
      t2 = text2("%");
      attr(div0, "class", "progress-value svelte-ztgdsf");
      set_style(
        div0,
        "width",
        /*focusedFolderStatus*/
        ctx[12].progress + "%"
      );
      attr(div1, "class", "progress-bar svelte-ztgdsf");
      attr(span, "class", "progress-text svelte-ztgdsf");
      attr(div2, "class", "progress-container svelte-ztgdsf");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append2(div2, div1);
      append2(div1, div0);
      append2(div2, t0);
      append2(div2, span);
      append2(span, t1);
      append2(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*focusedFolderStatus*/
      4096) {
        set_style(
          div0,
          "width",
          /*focusedFolderStatus*/
          ctx2[12].progress + "%"
        );
      }
      if (dirty & /*focusedFolderStatus*/
      4096 && t1_value !== (t1_value = /*focusedFolderStatus*/
      ctx2[12].progress + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
    }
  };
}
function create_default_slot_19(ctx) {
  let if_block_anchor;
  let if_block = (
    /*focusedFolderStatus*/
    (ctx[12].running > 0 || /*focusedFolderStatus*/
    ctx[12].failed > 0) && create_if_block_45(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (
        /*focusedFolderStatus*/
        ctx2[12].running > 0 || /*focusedFolderStatus*/
        ctx2[12].failed > 0
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_45(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_if_block_36(ctx) {
  let span;
  let t0_value = (
    /*focusedFolderStatus*/
    ctx[12].running + ""
  );
  let t0;
  let t1;
  return {
    c() {
      span = element2("span");
      t0 = text2(t0_value);
      t1 = text2(" active");
      attr(span, "class", "tag mod-success svelte-ztgdsf");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append2(span, t0);
      append2(span, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*focusedFolderStatus*/
      4096 && t0_value !== (t0_value = /*focusedFolderStatus*/
      ctx2[12].running + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_29(ctx) {
  let span;
  let t0_value = (
    /*focusedFolderStatus*/
    ctx[12].failed + ""
  );
  let t0;
  let t1;
  return {
    c() {
      span = element2("span");
      t0 = text2(t0_value);
      t1 = text2(" stuck");
      attr(span, "class", "tag mod-warning svelte-ztgdsf");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append2(span, t0);
      append2(span, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*focusedFolderStatus*/
      4096 && t0_value !== (t0_value = /*focusedFolderStatus*/
      ctx2[12].failed + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_113(ctx) {
  let span;
  let t0_value = (
    /*focusedFolderStatus*/
    ctx[12].pending + ""
  );
  let t0;
  let t1;
  return {
    c() {
      span = element2("span");
      t0 = text2(t0_value);
      t1 = text2(" queued");
      attr(span, "class", "tag svelte-ztgdsf");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append2(span, t0);
      append2(span, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*focusedFolderStatus*/
      4096 && t0_value !== (t0_value = /*focusedFolderStatus*/
      ctx2[12].pending + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_default_slot32(ctx) {
  let div;
  let t0_value = (
    /*focusedFolder*/
    ctx[5].name + ""
  );
  let t0;
  let t1;
  let span;
  let t2;
  let t3;
  let if_block0 = (
    /*focusedFolderStatus*/
    ctx[12].running > 0 && create_if_block_36(ctx)
  );
  let if_block1 = (
    /*focusedFolderStatus*/
    ctx[12].failed > 0 && create_if_block_29(ctx)
  );
  let if_block2 = (
    /*focusedFolderStatus*/
    ctx[12].pending > 0 && create_if_block_113(ctx)
  );
  return {
    c() {
      div = element2("div");
      t0 = text2(t0_value);
      t1 = space();
      span = element2("span");
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      attr(span, "class", "sync-stats svelte-ztgdsf");
      attr(div, "class", "folder-header svelte-ztgdsf");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append2(div, t0);
      append2(div, t1);
      append2(div, span);
      if (if_block0)
        if_block0.m(span, null);
      append2(span, t2);
      if (if_block1)
        if_block1.m(span, null);
      append2(span, t3);
      if (if_block2)
        if_block2.m(span, null);
    },
    p(ctx2, dirty) {
      if (dirty & /*focusedFolder*/
      32 && t0_value !== (t0_value = /*focusedFolder*/
      ctx2[5].name + ""))
        set_data(t0, t0_value);
      if (
        /*focusedFolderStatus*/
        ctx2[12].running > 0
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_36(ctx2);
          if_block0.c();
          if_block0.m(span, t2);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*focusedFolderStatus*/
        ctx2[12].failed > 0
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_29(ctx2);
          if_block1.c();
          if_block1.m(span, t3);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*focusedFolderStatus*/
        ctx2[12].pending > 0
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_113(ctx2);
          if_block2.c();
          if_block2.m(span, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
    }
  };
}
function create_name_slot6(ctx) {
  let folder_1;
  let current;
  folder_1 = new Folder_default({
    props: {
      folder: (
        /*focusedFolder*/
        ctx[5]
      ),
      $$slots: { default: [create_default_slot32] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(folder_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(folder_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const folder_1_changes = {};
      if (dirty & /*focusedFolder*/
      32)
        folder_1_changes.folder = /*focusedFolder*/
        ctx2[5];
      if (dirty & /*$$scope, focusedFolderStatus, focusedFolder*/
      536875040) {
        folder_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      folder_1.$set(folder_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(folder_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(folder_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(folder_1, detaching);
    }
  };
}
function create_fragment54(ctx) {
  let div;
  let t0;
  let t1;
  let current_block_type_index;
  let if_block2;
  let current;
  let if_block0 = !/*focusedFolder*/
  ctx[5] && create_if_block_132(ctx);
  let if_block1 = !/*focusedFolder*/
  ctx[5] && create_if_block_10(ctx);
  const if_block_creators = [create_if_block20, create_else_block13];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*focusedFolder*/
      ctx2[5] && /*focusedFolderStatus*/
      ctx2[12]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, -1);
  if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element2("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if_block2.c();
      attr(div, "class", "setting-item-container");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append2(div, t0);
      if (if_block1)
        if_block1.m(div, null);
      append2(div, t1);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!/*focusedFolder*/
      ctx2[5]) {
        if (if_block0) {
          if (dirty & /*focusedFolder*/
          32) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_132(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!/*focusedFolder*/
      ctx2[5]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*focusedFolder*/
          32) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_10(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block2 = if_blocks[current_block_type_index];
        if (!if_block2) {
          if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block2.c();
        } else {
          if_block2.p(ctx2, dirty);
        }
        transition_in(if_block2, 1);
        if_block2.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance53($$self, $$props, $$invalidate) {
  let folders;
  let focusedFolder;
  let folderStatuses;
  let focusedFolderStatus;
  let queueStatus;
  let isPaused;
  let isProcessing;
  let isSyncing;
  let hasPendingSync;
  let $activeDownloads;
  let $activeSync;
  let { backgroundSync } = $$props;
  let { sharedFolders } = $$props;
  let { focusedFolderGuid } = $$props;
  let expandedFolders = {};
  let activeFilesCount = 0;
  let stuckFilesCount = 0;
  let queuedFilesCount = 0;
  let completedFilesCount = 0;
  const { activeSync, activeDownloads } = backgroundSync;
  component_subscribe($$self, activeSync, (value) => $$invalidate(21, $activeSync = value));
  component_subscribe($$self, activeDownloads, (value) => $$invalidate(20, $activeDownloads = value));
  function toggleFolder(folderId) {
    $$invalidate(1, expandedFolders[folderId] = !expandedFolders[folderId], expandedFolders);
    $$invalidate(1, expandedFolders), $$invalidate(6, folders), $$invalidate(17, sharedFolders);
  }
  function togglePause() {
    if (isPaused) {
      backgroundSync.resume();
    } else {
      backgroundSync.pause();
    }
  }
  const click_handler = (folder) => toggleFolder(folder.guid);
  const keydown_handler = (folder, e2) => e2.key === "Enter" && toggleFolder(folder.guid);
  $$self.$$set = ($$props2) => {
    if ("backgroundSync" in $$props2)
      $$invalidate(0, backgroundSync = $$props2.backgroundSync);
    if ("sharedFolders" in $$props2)
      $$invalidate(17, sharedFolders = $$props2.sharedFolders);
    if ("focusedFolderGuid" in $$props2)
      $$invalidate(18, focusedFolderGuid = $$props2.focusedFolderGuid);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*sharedFolders*/
    131072) {
      $:
        $$invalidate(6, folders = sharedFolders.items().sort((a, b) => a.name.localeCompare(b.name)));
    }
    if ($$self.$$.dirty & /*folders, expandedFolders*/
    66) {
      $: {
        folders.forEach((folder) => {
          if (!(folder.guid in expandedFolders)) {
            $$invalidate(1, expandedFolders[folder.guid] = true, expandedFolders);
          }
        });
        $$invalidate(1, expandedFolders), $$invalidate(6, folders), $$invalidate(17, sharedFolders);
      }
    }
    if ($$self.$$.dirty & /*focusedFolderGuid, sharedFolders*/
    393216) {
      $:
        $$invalidate(5, focusedFolder = focusedFolderGuid ? sharedFolders.items().find((f) => f.guid === focusedFolderGuid) : void 0);
    }
    if ($$self.$$.dirty & /*folders, backgroundSync, $activeSync, $activeDownloads*/
    3145793) {
      $:
        $$invalidate(4, folderStatuses = new Map(folders.map((folder) => {
          var _a2, _b2;
          return [
            folder.guid,
            {
              progress: ((_a2 = backgroundSync.getGroupProgress(folder)) === null || _a2 === void 0 ? void 0 : _a2.percent) || 0,
              running: [...$activeSync.items(), ...$activeDownloads.items()].filter((i2) => i2.sharedFolder.guid === folder.guid).length,
              failed: ((_b2 = backgroundSync.syncGroups.get(folder)) === null || _b2 === void 0 ? void 0 : _b2.status) === "failed" ? 1 : 0,
              pending: [...backgroundSync.pendingSyncs, ...backgroundSync.pendingDownloads].filter((i2) => i2.sharedFolder.guid === folder.guid).length,
              completed: (() => {
                const group = backgroundSync.syncGroups.get(folder);
                return ((group === null || group === void 0 ? void 0 : group.completedSyncs) || 0) + ((group === null || group === void 0 ? void 0 : group.completedDownloads) || 0);
              })(),
              sharedFolder: folder
            }
          ];
        })));
    }
    if ($$self.$$.dirty & /*focusedFolder, folderStatuses*/
    48) {
      $:
        $$invalidate(12, focusedFolderStatus = focusedFolder ? folderStatuses.get(focusedFolder.guid) : void 0);
    }
    if ($$self.$$.dirty & /*backgroundSync*/
    1) {
      $:
        $$invalidate(19, queueStatus = backgroundSync.getQueueStatus());
    }
    if ($$self.$$.dirty & /*queueStatus*/
    524288) {
      $:
        $$invalidate(9, isPaused = queueStatus.isPaused);
    }
    if ($$self.$$.dirty & /*queueStatus*/
    524288) {
      $:
        isProcessing = queueStatus.syncsActive > 0 || queueStatus.downloadsActive > 0;
    }
    if ($$self.$$.dirty & /*folderStatuses*/
    16) {
      $: {
        let active = 0;
        let stuck = 0;
        let queued = 0;
        let completed = 0;
        for (const status of folderStatuses.values()) {
          active += status.running;
          stuck += status.failed;
          queued += status.pending;
          completed += status.completed;
        }
        $$invalidate(2, activeFilesCount = active);
        $$invalidate(7, stuckFilesCount = stuck);
        $$invalidate(3, queuedFilesCount = queued);
        $$invalidate(8, completedFilesCount = completed);
      }
    }
    if ($$self.$$.dirty & /*activeFilesCount*/
    4) {
      $:
        $$invalidate(11, isSyncing = activeFilesCount > 0);
    }
    if ($$self.$$.dirty & /*queuedFilesCount*/
    8) {
      $:
        $$invalidate(10, hasPendingSync = queuedFilesCount > 0);
    }
  };
  return [
    backgroundSync,
    expandedFolders,
    activeFilesCount,
    queuedFilesCount,
    folderStatuses,
    focusedFolder,
    folders,
    stuckFilesCount,
    completedFilesCount,
    isPaused,
    hasPendingSync,
    isSyncing,
    focusedFolderStatus,
    activeSync,
    activeDownloads,
    toggleFolder,
    togglePause,
    sharedFolders,
    focusedFolderGuid,
    queueStatus,
    $activeDownloads,
    $activeSync,
    click_handler,
    keydown_handler
  ];
}
var SyncQueueModalContent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance53,
      create_fragment54,
      safe_not_equal,
      {
        backgroundSync: 0,
        sharedFolders: 17,
        focusedFolderGuid: 18
      },
      add_css22
    );
  }
};
var SyncQueueModalContent_default = SyncQueueModalContent;

// src/ui/SyncQueueModal.ts
var SyncQueueModal = class extends import_obsidian31.Modal {
  constructor(app, backgroundSync, sharedFolders, focusedFolderGuid) {
    super(app);
    this.backgroundSync = backgroundSync;
    this.sharedFolders = sharedFolders;
    this.focusedFolderGuid = focusedFolderGuid;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.component = new SyncQueueModalContent_default({
      target: contentEl,
      props: {
        backgroundSync: this.backgroundSync,
        sharedFolders: this.sharedFolders,
        focusedFolderGuid: this.focusedFolderGuid,
        closeModal: () => this.close()
      }
    });
  }
  onClose() {
    var _a2;
    const { contentEl } = this;
    contentEl.empty();
    (_a2 = this.component) == null ? void 0 : _a2.$destroy();
  }
};

// src/main.ts
var DEFAULT_DEBUG_SETTINGS = {
  debugging: false
};
var DEFAULT_SETTINGS = {
  sharedFolders: [],
  ...FeatureFlagDefaults,
  ...DEFAULT_DEBUG_SETTINGS
};
var Live = class extends import_obsidian34.Plugin {
  constructor() {
    super(...arguments);
    this.webviewerPatched = false;
    this.openModals = [];
    this.interceptedUrls = [];
    this.fileDiffMergeWarningKey = "file-diff-merge-warning";
    this.version = "0.4.5";
  }
  enableDebugging(save) {
    setDebugging(true);
    console.warn("RelayInstances", RelayInstances);
    if (save) {
      this.debugSettings.update((settings) => ({
        ...settings,
        debugging: true
      }));
    }
  }
  disableDebugging(save) {
    setDebugging(false);
    if (save) {
      this.debugSettings.update((settings) => ({
        ...settings,
        debugging: false
      }));
    }
  }
  toggleDebugging(save) {
    const setTo = !this.debugSettings.get().debugging;
    setDebugging(setTo);
    if (save) {
      this.debugSettings.update((settings) => ({
        ...settings,
        debugging: setTo
      }));
    }
    return setTo;
  }
  buildApiUrl(path) {
    return "https://api.system3.md" + path;
  }
  async onload() {
    this.appId = this.app.appId;
    const start = import_obsidian32.moment.now();
    RelayInstances.set(this, "plugin");
    this.timeProvider = new DefaultTimeProvider();
    this.register(() => {
      this.timeProvider.destroy();
    });
    initializeLogger(
      new ObsidianFileAdapter(this.app.vault),
      this.timeProvider,
      ".obsidian/plugins/system3-relay/relay.log",
      {
        maxFileSize: 5 * 1024 * 1024,
        // 5MB
        maxBackups: 3,
        disableConsole: false
        // Disable console logging
      }
    );
    this.notifier = new ObsidianNotifier();
    this.toast = createToast(this.notifier);
    this.debug = curryLog("[System 3][Relay]", "debug");
    this.log = curryLog("[System 3][Relay]", "log");
    this.warn = curryLog("[System 3][Relay]", "warn");
    this.error = curryLog("[System 3][Relay]", "error");
    this.settings = new Settings2(this, DEFAULT_SETTINGS);
    await this.settings.load();
    this.featureSettings = new NamespacedSettings(this.settings, "(enable*)");
    this.debugSettings = new NamespacedSettings(this.settings, "(debugging)");
    this.folderSettings = new NamespacedSettings(
      this.settings,
      "sharedFolders"
    );
    const flagManager = FeatureFlagManager.getInstance();
    flagManager.setSettings(this.featureSettings);
    this.settingsTab = new LiveSettingsTab(this.app, this);
    this.addRibbonIcon("satellite", "Relay", () => {
      this.openSettings();
    });
    this.debugSettings.subscribe((settings) => {
      if (settings.debugging) {
        this.enableDebugging();
        this.removeCommand("enable-debugging");
        this.addCommand({
          id: "toggle-feature-flags",
          name: "Feature Flags",
          callback: () => {
            const modal = new FeatureFlagToggleModal(this.app, () => {
              this.reload();
            });
            this.openModals.push(modal);
            modal.open();
          }
        });
        this.addCommand({
          id: "send-bug-report",
          name: "Send bug report",
          callback: () => {
            const modal = new BugReportModal(this.app, this);
            this.openModals.push(modal);
            modal.open();
          }
        });
        this.addCommand({
          id: "show-debug-info",
          name: "Show debug info",
          callback: () => {
            const modal = new DebugModal(this.app, this);
            this.openModals.push(modal);
            modal.open();
          }
        });
        this.addCommand({
          id: "analyze-indexeddb",
          name: "Analyze Database",
          callback: () => {
            const modal = new IndexedDBAnalysisModal(this.app, this);
            this.openModals.push(modal);
            modal.open();
          }
        });
        this.addCommand({
          id: "disable-debugging",
          name: "Disable debugging",
          callback: () => {
            this.disableDebugging(true);
          }
        });
        this.addCommand({
          id: "show-sync-status",
          name: "Sync Status",
          callback: () => {
            const modal = new SyncQueueModal(
              this.app,
              this.backgroundSync,
              this.sharedFolders
            );
            this.openModals.push(modal);
            modal.open();
          }
        });
      } else {
        this.removeCommand("toggle-feature-flags");
        this.removeCommand("send-bug-report");
        this.removeCommand("show-debug-info");
        this.removeCommand("show-sync-status");
        this.removeCommand("disable-debugging");
        this.addCommand({
          id: "enable-debugging",
          name: "Enable debugging",
          callback: () => {
            this.enableDebugging(true);
          }
        });
      }
    });
    this.addCommand({
      id: "reload",
      name: "Reload Relay",
      callback: () => {
        this.reload();
      }
    });
    this.vault = this.app.vault;
    const vaultName = this.vault.getName();
    this.fileManager = this.app.fileManager;
    this.loginManager = new LoginManager(
      this.vault.getName(),
      this.openSettings.bind(this),
      this.timeProvider,
      this.patchWebviewer.bind(this)
    );
    this.relayManager = new RelayManager(this.loginManager);
    this.sharedFolders = new SharedFolders(
      this.relayManager,
      this.vault,
      this._createSharedFolder.bind(this),
      this.folderSettings
    );
    this.tokenStore = new LiveTokenStore(
      this.loginManager,
      this.timeProvider,
      vaultName,
      3
    );
    this.networkStatus = new NetworkStatus_default(this.timeProvider, "https://api.system3.md/health?version=0.4.5");
    this.backgroundSync = new BackgroundSync(
      this.loginManager,
      this.timeProvider,
      this.sharedFolders
    );
    if (!this.loginManager.setup()) {
      new import_obsidian32.Notice("Please sign in to use relay");
    }
    this.app.workspace.onLayoutReady(() => {
      this.sharedFolders.load();
      this._liveViews = new LiveViewManager4(
        this.app,
        this.sharedFolders,
        this.loginManager,
        this.networkStatus
      );
      this.registerEditorExtension(this._liveViews.extensions);
      this.register(
        this.loginManager.on(() => {
          if (this.loginManager.loggedIn) {
            this._onLogin();
          } else {
            this._onLogout();
          }
        })
      );
      this.tokenStore.start();
      if (!import_obsidian33.Platform.isIosApp) {
        this.networkStatus.addEventListener("offline", () => {
          this.tokenStore.stop();
          this.sharedFolders.forEach((folder) => folder.disconnect());
          this._liveViews.goOffline();
        });
        this.networkStatus.addEventListener("online", () => {
          this.tokenStore.start();
          this.relayManager.subscribe();
          this.relayManager.update();
          this._liveViews.goOnline();
        });
        this.networkStatus.start();
      }
      this.registerView(
        VIEW_TYPE_DIFFERENCES,
        (leaf) => new DifferencesView(leaf)
      );
      this.registerEvent(
        this.app.workspace.on("file-menu", (menu, file) => {
          if (file instanceof import_obsidian32.TFolder) {
            const folder = this.sharedFolders.find(
              (sharedFolder) => sharedFolder.path === file.path
            );
            if (!folder) {
              return;
            }
            if (folder.relayId) {
              menu.addItem((item) => {
                item.setTitle(folder.connected ? "Disconnect" : "Connect").setIcon("satellite").onClick(() => {
                  if (folder.connected) {
                    folder.shouldConnect = false;
                    folder.disconnect();
                  } else {
                    folder.shouldConnect = true;
                    folder.connect();
                  }
                  this._liveViews.refresh("folder connection toggle");
                });
              });
            }
            menu.addItem((item) => {
              item.setTitle("Folder settings").setIcon("gear").onClick(() => {
                this.openSettings(
                  `/shared-folders?id=${folder.guid}&relay=${folder.relayId}`
                );
              });
            });
            if (folder.relayId && flags().enableSyncModal) {
              menu.addItem((item) => {
                item.setTitle("Sync Status").setIcon("list-checks").onClick(() => {
                  const modal = new SyncQueueModal(
                    this.app,
                    this.backgroundSync,
                    this.sharedFolders,
                    folder.guid
                  );
                  this.openModals.push(modal);
                  modal.open();
                });
              });
            }
            if (flags().enableSyncMenu && folder.relayId && folder.connected) {
              menu.addItem((item) => {
                item.setTitle("Sync").setIcon("folder-sync").onClick(() => {
                  folder.netSync();
                });
              });
            }
          }
        })
      );
      this.setup();
      this._liveViews.refresh("init");
      this.loadTime = import_obsidian32.moment.now() - start;
    });
  }
  async reload() {
    const pluginId = this.manifest.id;
    const plugins = this.app.plugins;
    await plugins.disablePlugin(pluginId);
    await plugins.enablePlugin(pluginId);
  }
  _createSharedFolder(path, guid, relayId, awaitingUpdates) {
    const folderSettings = new NamespacedSettings(
      this.settings,
      `sharedFolders/[guid=${guid}]`
    );
    folderSettings.flush();
    const folder = new SharedFolder(
      this.appId,
      guid,
      path,
      this.loginManager,
      this.vault,
      this.fileManager,
      this.tokenStore,
      this.relayManager,
      this.backgroundSync,
      folderSettings,
      relayId,
      awaitingUpdates
    );
    return folder;
  }
  _onLogout() {
    var _a2, _b2;
    (_a2 = this.tokenStore) == null ? void 0 : _a2.clear();
    (_b2 = this.relayManager) == null ? void 0 : _b2.logout();
    this._liveViews.refresh("logout");
  }
  _onLogin() {
    var _a2;
    this.sharedFolders.load();
    (_a2 = this.relayManager) == null ? void 0 : _a2.login();
    this._liveViews.refresh("login");
  }
  async openSettings(path = "/") {
    const setting = this.app.setting;
    await setting.open();
    await setting.openTabById("system3-relay");
    this.settingsTab.navigateTo(path);
  }
  patchWebviewer() {
    var _a2, _b2, _c;
    const plugin = this;
    try {
      if (this.webviewerPatched) {
        return;
      }
      const webviewer = (_b2 = (_a2 = this.app.internalPlugins) == null ? void 0 : _a2.plugins) == null ? void 0 : _b2.webviewer;
      if (!((_c = webviewer == null ? void 0 : webviewer.instance) == null ? void 0 : _c.options) || !webviewer.enabled) {
        this.warn("Webviewer plugin not found or not initialized");
        return;
      }
      const options = webviewer.instance.options;
      const originalDesc = Object.getOwnPropertyDescriptor(
        options,
        "openExternalURLs"
      );
      if (!originalDesc) {
        this.warn("Could not find openExternalURLs property");
        return;
      }
      Object.defineProperty(options, "openExternalURLs", {
        get() {
          var _a3;
          const currentEvent = window.event;
          if ((currentEvent == null ? void 0 : currentEvent.type) === "open-url" && ((_a3 = currentEvent == null ? void 0 : currentEvent.detail) == null ? void 0 : _a3.url)) {
            const url = currentEvent.detail.url;
            for (const pattern of plugin.interceptedUrls) {
              if (typeof pattern === "string" && url.startsWith(pattern) || pattern instanceof RegExp && pattern.test(url)) {
                plugin.log(
                  "Intercepted webviewer, opening in default browser",
                  currentEvent.detail.url
                );
                return false;
              }
            }
          }
          return originalDesc.value;
        },
        set(value) {
          originalDesc.value = value;
        },
        configurable: true
      });
      this.register(() => {
        Object.defineProperty(options, "openExternalURLs", originalDesc);
      });
      const re = this.loginManager.webviewIntercept();
      this.debug("Intercepting Webviewer for URL pattern", re.source);
      this.interceptedUrls.push(re);
      const apiRegExp = new RegExp("https://api.system3.md".replace("/", "\\/") + ".*");
      this.debug("Intercepting Webviewer for URL pattern", apiRegExp.source);
      this.interceptedUrls.push(apiRegExp);
      this.webviewerPatched = true;
      this.debug("patched webviewer options");
    } catch (error) {
      this.error("Failed to patch webviewer:", error);
    }
  }
  setup() {
    this.folderNavDecorations = new FolderNavigationDecorations(
      this.vault,
      this.app.workspace,
      this.sharedFolders,
      this.backgroundSync
    );
    this.folderNavDecorations.refresh();
    this.addSettingTab(this.settingsTab);
    const workspaceLog = curryLog("[Live][Workspace]", "log");
    this.registerEvent(
      this.app.workspace.on("file-open", (file) => {
        workspaceLog("file-open");
        plugin._liveViews.refresh("file-open");
      })
    );
    this.registerEvent(
      this.app.workspace.on("layout-change", () => {
        workspaceLog("layout-change");
        this._liveViews.refresh("layout-change");
      })
    );
    const vaultLog = curryLog("[System 3][Relay][Vault]", "log");
    const handleErrorEvent = (event) => {
      const error = event.error;
      if (error) {
        if (error instanceof RelayException) {
          this.toast(error);
        }
      }
    };
    window.addEventListener("error", handleErrorEvent, true);
    this.register(
      () => window.removeEventListener("error", handleErrorEvent, true)
    );
    const handlePromiseRejection = (event) => {
      if (event.reason instanceof RelayException) {
        this.toast(event.reason);
      }
    };
    const rejectionListener = (event) => handlePromiseRejection(event);
    window.addEventListener("unhandledrejection", rejectionListener, true);
    this.register(
      () => window.removeEventListener("unhandledrejection", rejectionListener, true)
    );
    this.registerEvent(
      this.app.vault.on("create", (file) => {
        if (file instanceof import_obsidian32.TFolder) {
          return;
        }
        const folder = this.sharedFolders.lookup(file.path);
        if (folder) {
          folder.whenReady().then((folder2) => {
            folder2.getFile(file.path);
          });
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("delete", (file) => {
        if (file instanceof import_obsidian32.TFolder) {
          const folder2 = this.sharedFolders.find(
            (folder3) => folder3.path === file.path
          );
          if (folder2) {
            this.sharedFolders.delete(folder2);
          }
          return;
        }
        const folder = this.sharedFolders.lookup(file.path);
        if (folder) {
          vaultLog("Delete", file.path);
          folder.whenReady().then((folder2) => {
            folder2.deleteFile(file.path);
          });
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("rename", (file, oldPath) => {
        if (file instanceof import_obsidian32.TFolder) {
          const sharedFolder = this.sharedFolders.find((folder2) => {
            return folder2.path == oldPath;
          });
          if (sharedFolder) {
            sharedFolder.move(file.path);
            this.sharedFolders.update();
          }
          return;
        }
        const fromFolder = this.sharedFolders.lookup(oldPath);
        const toFolder = this.sharedFolders.lookup(file.path);
        const folder = fromFolder || toFolder;
        if (fromFolder && toFolder) {
          vaultLog("Rename", file.path, oldPath);
          fromFolder.renameFile(file.path, oldPath);
          toFolder.renameFile(file.path, oldPath);
          this._liveViews.refresh("rename");
          this.folderNavDecorations.quickRefresh();
        } else if (folder) {
          vaultLog("Rename", file.path, oldPath);
          folder.renameFile(file.path, oldPath);
          this._liveViews.refresh("rename");
          this.folderNavDecorations.quickRefresh();
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("modify", (file) => {
        const folder = this.sharedFolders.lookup(file.path);
        if (folder) {
          vaultLog("Modify", file.path);
          if (flags().enableDesyncPill) {
            this.folderNavDecorations.quickRefresh();
          }
          this.app.metadataCache.trigger("resolve", file);
        }
      })
    );
    const plugin = this;
    const patchOnUnloadFile = around(import_obsidian32.MarkdownView.prototype, {
      // When this is called, the active editors haven't yet updated.
      onUnloadFile(old) {
        return function(file) {
          plugin._liveViews.wipe();
          return old.call(this, file);
        };
      }
    });
    this.register(patchOnUnloadFile);
    this.patchWebviewer();
    withFlag(flag.enableNewLinkFormat, () => {
      const patchFileToLinktext = around(import_obsidian32.MetadataCache.prototype, {
        fileToLinktext(old) {
          return function(file, sourcePath, omitMdExtension) {
            const folder = plugin.sharedFolders.lookup(file.path);
            if (folder) {
              if (omitMdExtension === void 0) {
                omitMdExtension = true;
              }
              const fileName = file.extension === "md" && omitMdExtension ? file.basename : file.name;
              const normalizedFileName = (0, import_obsidian32.normalizePath)(file.name);
              const destinationFiles = plugin.app.metadataCache.uniqueFileLookup.get(normalizedFileName.toLowerCase());
              if (destinationFiles && destinationFiles.length === 1 && destinationFiles[0] === file) {
                return fileName;
              } else {
                const filePath = file.extension === "md" && omitMdExtension ? file.path.slice(0, file.path.length - 3) : file.path;
                const rpath = (0, import_path_browserify3.relative)(sourcePath, filePath);
                if (rpath === "../" + fileName) {
                  return "./" + fileName;
                }
                return rpath;
              }
            }
            return old.call(this, file, sourcePath, omitMdExtension);
          };
        }
      });
      this.register(patchFileToLinktext);
    });
    this.registerObsidianProtocolHandler("relay/settings/relays", async (e2) => {
      const parameters = e2;
      const query = new import_url.URLSearchParams({ ...parameters }).toString();
      const path = `/${parameters.action.split("/").slice(-1)}?${query}`;
      this.openSettings(path);
    });
    this.registerObsidianProtocolHandler(
      "relay/settings/shared-folders",
      async (e2) => {
        const parameters = e2;
        const query = new import_url.URLSearchParams({ ...parameters }).toString();
        const path = `/${parameters.action.split("/").slice(-1)}?${query}`;
        this.openSettings(path);
      }
    );
  }
  removeCommand(command) {
    if ((0, import_obsidian32.requireApiVersion)("1.7.2")) {
      super.removeCommand(command);
    } else {
      const appAny = this.app;
      const appCommands = appAny.commands;
      const qualifiedCommand = `system3-relay:${command}`;
      if (appCommands.commands.hasOwnProperty(qualifiedCommand) || appAny.hotkeyManager.removeDefaultHotkeys(qualifiedCommand)) {
        delete appCommands.commands[qualifiedCommand];
        delete appCommands.editorCommands[qualifiedCommand];
      }
    }
  }
  onunload() {
    var _a2, _b2, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
    (_a2 = this.timeProvider) == null ? void 0 : _a2.destroy();
    (_b2 = this.folderNavDecorations) == null ? void 0 : _b2.destroy();
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_DIFFERENCES);
    (_c = this._liveViews) == null ? void 0 : _c.destroy();
    this._liveViews = null;
    (_d = this.relayManager) == null ? void 0 : _d.destroy();
    this.relayManager = null;
    (_e = this.tokenStore) == null ? void 0 : _e.stop();
    (_f = this.tokenStore) == null ? void 0 : _f.clearState();
    (_g = this.tokenStore) == null ? void 0 : _g.destroy();
    this.tokenStore = null;
    (_h = this.networkStatus) == null ? void 0 : _h.stop();
    (_i = this.networkStatus) == null ? void 0 : _i.destroy();
    this.networkStatus = null;
    this.openModals.forEach((modal) => {
      modal.close();
    });
    this.openModals.length = 0;
    (_j = this.sharedFolders) == null ? void 0 : _j.destroy();
    this.sharedFolders = null;
    (_k = this.settingsTab) == null ? void 0 : _k.destroy();
    this.settingsTab = null;
    (_l = this.loginManager) == null ? void 0 : _l.destroy();
    this.loginManager = null;
    (_m = this.backgroundSync) == null ? void 0 : _m.destroy();
    this.backgroundSync = null;
    (_n = this.app) == null ? void 0 : _n.workspace.updateOptions();
    this.app = null;
    this.fileManager = null;
    this.manifest = null;
    this.vault = null;
    this.debugSettings.destroy();
    this.debugSettings = null;
    this.folderSettings.destroy();
    this.folderSettings = null;
    this.featureSettings.destroy();
    this.featureSettings = null;
    this.interceptedUrls.length = 0;
    FeatureFlagManager.destroy();
    PostOffice.destroy();
    this.notifier = null;
    this.toast = null;
    auditTeardown();
    flushLogs();
  }
  async loadSettings() {
    this.settings.load();
  }
  async saveSettings() {
    await this.settings.save();
  }
};
/*! Bundled license information:

moment/moment.js:
  (*! moment.js *)
  (*! version : 2.29.4 *)
  (*! authors : Tim Wood, Iskren Chernev, Moment.js contributors *)
  (*! license : MIT *)
  (*! momentjs.com *)

lucide-svelte/dist/defaultAttributes.js:
  (**
   * @license lucide-svelte v0.377.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/arrow-right-left.svelte:
  (**
   * @license lucide-svelte v0.377.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/arrow-up-down.svelte:
  (**
   * @license lucide-svelte v0.377.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/chevron-left.svelte:
  (**
   * @license lucide-svelte v0.377.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/chevron-right.svelte:
  (**
   * @license lucide-svelte v0.377.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/circle-check-big.svelte:
  (**
   * @license lucide-svelte v0.377.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/circle-help.svelte:
  (**
   * @license lucide-svelte v0.377.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/clock.svelte:
  (**
   * @license lucide-svelte v0.377.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/download.svelte:
  (**
   * @license lucide-svelte v0.377.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/folder.svelte:
  (**
   * @license lucide-svelte v0.377.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/info.svelte:
  (**
   * @license lucide-svelte v0.377.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/layers.svelte:
  (**
   * @license lucide-svelte v0.377.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/message-square-heart.svelte:
  (**
   * @license lucide-svelte v0.377.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/pause.svelte:
  (**
   * @license lucide-svelte v0.377.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/play.svelte:
  (**
   * @license lucide-svelte v0.377.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/refresh-cw.svelte:
  (**
   * @license lucide-svelte v0.377.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/satellite.svelte:
  (**
   * @license lucide-svelte v0.377.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/settings.svelte:
  (**
   * @license lucide-svelte v0.377.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/triangle-alert.svelte:
  (**
   * @license lucide-svelte v0.377.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/upload.svelte:
  (**
   * @license lucide-svelte v0.377.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/index.js:
  (**
   * @license lucide-svelte v0.377.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/aliases.js:
  (**
   * @license lucide-svelte v0.377.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)
*/


/* nosourcemap */